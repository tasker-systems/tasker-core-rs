name: CI Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # ============================================================================
  # Stage 0: Build PostgreSQL image with PGMQ extension
  # ============================================================================
  build-postgres:
    uses: ./.github/workflows/build-postgres.yml

  # ============================================================================
  # Stage 1-3: Integration Tests (DAG-based execution)
  # Internal structure:
  #   1. workspace-compile  - Build core packages, warm sccache
  #   2. unit-tests        - Run unit tests + doctests (parallel with build-workers)
  #   2. build-workers     - Build Ruby/Python FFI extensions (parallel with unit-tests)
  #   3. integration-tests - Partitioned E2E tests (2 partitions)
  # ============================================================================
  integration-tests:
    needs: build-postgres
    uses: ./.github/workflows/test-integration.yml
    with:
      postgres-image: ${{ needs.build-postgres.outputs.postgres-image }}

  # Code quality runs in parallel with integration tests
  code-quality:
    needs: build-postgres
    uses: ./.github/workflows/code-quality.yml
    with:
      postgres-image: ${{ needs.build-postgres.outputs.postgres-image }}

  # ============================================================================
  # Stage 4: Framework-specific tests (after integration tests complete)
  # These reuse worker artifacts from build-workers job when available
  # ============================================================================
  ruby-framework-tests:
    needs: [build-postgres, integration-tests]
    uses: ./.github/workflows/test-ruby-framework.yml
    with:
      postgres-image: ${{ needs.build-postgres.outputs.postgres-image }}

  python-framework-tests:
    needs: [build-postgres, integration-tests]
    uses: ./.github/workflows/test-python-framework.yml
    with:
      postgres-image: ${{ needs.build-postgres.outputs.postgres-image }}

  # ============================================================================
  # Stage 5: Performance Analysis
  # Aggregates test results from all test stages
  # ============================================================================
  performance-analysis:
    needs: [integration-tests, ruby-framework-tests, python-framework-tests]
    runs-on: ubuntu-22.04
    if: always()
    steps:
      - name: Download test artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: "*-test-results*"
          merge-multiple: true
          path: performance-data/
        continue-on-error: true

      - name: Checkout for scripts
        uses: actions/checkout@v6
        with:
          sparse-checkout: .github/scripts

      - name: Aggregate performance metrics
        run: |
          chmod +x .github/scripts/aggregate-performance-metrics.sh
          .github/scripts/aggregate-performance-metrics.sh performance-data performance-summary.md

      - name: Upload performance analysis
        uses: actions/upload-artifact@v5
        with:
          name: performance-analysis
          path: |
            performance-summary.md
            performance-data/

  # ============================================================================
  # Stage 6: CI Success Gate
  # Final status check - all jobs must pass for CI to succeed
  # ============================================================================
  ci-success:
    needs: [code-quality, integration-tests, ruby-framework-tests, python-framework-tests, performance-analysis]
    uses: ./.github/workflows/ci-success.yml
