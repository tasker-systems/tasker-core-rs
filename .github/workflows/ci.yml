name: CI Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # ============================================================================
  # Stage 0: Build PostgreSQL image with PGMQ extension
  # ============================================================================
  build-postgres:
    uses: ./.github/workflows/build-postgres.yml

  # ============================================================================
  # Stage 1: Build Worker Extensions
  # Builds Ruby/Python FFI extensions and Rust worker binary
  # ============================================================================
  build-workers:
    needs: build-postgres
    uses: ./.github/workflows/build-workers.yml
    with:
      postgres-image: ${{ needs.build-postgres.outputs.postgres-image }}

  # ============================================================================
  # Stage 2: Parallel Test Execution
  # All three test workflows run in parallel after build-workers completes:
  #   - integration-tests: workspace-compile → unit-tests → E2E tests
  #   - ruby-framework-tests: Ruby FFI tests (rspec)
  #   - python-framework-tests: Python FFI tests (pytest)
  # ============================================================================
  integration-tests:
    needs: [build-postgres, build-workers]
    uses: ./.github/workflows/test-integration.yml
    with:
      postgres-image: ${{ needs.build-postgres.outputs.postgres-image }}

  ruby-framework-tests:
    needs: [build-postgres, build-workers]
    uses: ./.github/workflows/test-ruby-framework.yml
    with:
      postgres-image: ${{ needs.build-postgres.outputs.postgres-image }}

  python-framework-tests:
    needs: [build-postgres, build-workers]
    uses: ./.github/workflows/test-python-framework.yml
    with:
      postgres-image: ${{ needs.build-postgres.outputs.postgres-image }}

  # Code quality runs in parallel with everything after postgres is ready
  code-quality:
    needs: build-postgres
    uses: ./.github/workflows/code-quality.yml
    with:
      postgres-image: ${{ needs.build-postgres.outputs.postgres-image }}

  # ============================================================================
  # Stage 3: Performance Analysis
  # Aggregates test results from all test stages
  # ============================================================================
  performance-analysis:
    needs: [integration-tests, ruby-framework-tests, python-framework-tests]
    runs-on: ubuntu-22.04
    if: always()
    steps:
      - name: Download test artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: "*-test-results*"
          merge-multiple: true
          path: performance-data/
        continue-on-error: true

      - name: Checkout for scripts
        uses: actions/checkout@v6
        with:
          sparse-checkout: .github/scripts

      - name: Aggregate performance metrics
        run: |
          chmod +x .github/scripts/aggregate-performance-metrics.sh
          .github/scripts/aggregate-performance-metrics.sh performance-data performance-summary.md

      - name: Upload performance analysis
        uses: actions/upload-artifact@v5
        with:
          name: performance-analysis
          path: |
            performance-summary.md
            performance-data/

  # ============================================================================
  # Stage 4: CI Success Gate
  # Final status check - all jobs must pass for CI to succeed
  # ============================================================================
  ci-success:
    needs: [code-quality, integration-tests, ruby-framework-tests, python-framework-tests, performance-analysis]
    uses: ./.github/workflows/ci-success.yml
