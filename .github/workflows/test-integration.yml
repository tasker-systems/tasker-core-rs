name: Integration Tests

# =============================================================================
# TAS-73: Test Infrastructure Note
# =============================================================================
# Cluster tests (test-cluster feature) are NOT run in CI.
# These tests require multi-instance infrastructure (multiple orchestration +
# worker processes) that exceeds GitHub Actions free tier resource limits.
#
# Run cluster tests locally with:
#   cargo make cluster-start
#   cargo make test-rust-cluster  # or: cargo make tc
#
# See docs/ticket-specs/TAS-73/test-feature-flags-design.md for details.
# =============================================================================

on:
  workflow_call:
    inputs:
      postgres-image:
        required: true
        type: string

jobs:
  # ============================================================================
  # Stage 1: Unit Tests
  # Run library tests and doctests for core packages
  # Uses cache warmed by build-workers workflow
  # ============================================================================
  unit-tests:
    name: Unit Tests + Doctests
    runs-on: ubuntu-22.04
    timeout-minutes: 15

    services:
      postgres:
        image: ${{ inputs.postgres-image }}
        ports:
          - "5432:5432"
        env:
          POSTGRES_USER: tasker
          POSTGRES_PASSWORD: tasker
          POSTGRES_DB: tasker_rust_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      # TAS-171: Dragonfly (Redis + Memcached compatible) for distributed cache
      # Exposes both Redis (6379) and Memcached (11211) protocols
      dragonfly:
        image: docker.dragonflydb.io/dragonflydb/dragonfly:latest
        ports:
          - "6379:6379"
          - "11211:11211"
        env:
          DFLY_memcached_port: 11211
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Restore Rust build cache
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-integration-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-integration-
            ${{ runner.os }}-cargo-

      - name: Setup shared environment variables
        uses: ./.github/actions/setup-env

      - name: Install tools
        uses: ./.github/actions/install-tools
        with:
          tools: "nextest sqlx-cli make"

      # TAS-177: Install protobuf compiler for gRPC proto compilation
      - name: Install protobuf compiler
        run: |
          sudo apt-get update
          sudo apt-get install -y protobuf-compiler
          protoc --version

      - name: Setup database
        run: sqlx migrate run
        env:
          DATABASE_URL: postgresql://tasker:tasker@localhost:5432/tasker_rust_test

      - name: Run unit tests
        run: |
          echo "üß™ Running unit tests..."
          mkdir -p target/nextest/ci
          cargo nextest run \
            --profile ci \
            --lib \
            --package tasker-shared \
            --package tasker-orchestration \
            --package tasker-worker \
            --package pgmq-notify \
            --package tasker-client \
            --no-fail-fast
        env:
          DATABASE_URL: postgresql://tasker:tasker@localhost:5432/tasker_rust_test
          REDIS_URL: redis://localhost:6379

      - name: Run doctests
        run: |
          echo "üìö Running documentation tests..."
          cargo test --doc \
            --package tasker-shared \
            --package tasker-orchestration \
            --package tasker-worker \
            --package pgmq-notify \
            --package tasker-client
        env:
          DATABASE_URL: postgresql://tasker:tasker@localhost:5432/tasker_rust_test
          REDIS_URL: redis://localhost:6379

      - name: Upload unit test results
        uses: actions/upload-artifact@v6
        if: always() && hashFiles('target/nextest/ci/junit.xml') != ''
        with:
          name: unit-test-results
          path: target/nextest/ci/junit.xml

  # ============================================================================
  # Stage 2: Integration Tests (E2E)
  # Run E2E tests with all services running
  # Uses artifacts from build-workers workflow
  # TAS-133: Matrix strategy tests both PGMQ and RabbitMQ messaging backends
  # ============================================================================
  integration-tests:
    name: Integration Tests (${{ matrix.messaging_backend }})
    runs-on: ubuntu-22.04
    timeout-minutes: 25
    needs: unit-tests

    strategy:
      fail-fast: false
      matrix:
        messaging_backend: [pgmq, rabbitmq]

    services:
      postgres:
        image: ${{ inputs.postgres-image }}
        ports:
          - "5432:5432"
        env:
          POSTGRES_USER: tasker
          POSTGRES_PASSWORD: tasker
          POSTGRES_DB: tasker_rust_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      # TAS-133: RabbitMQ service for messaging backend matrix testing
      rabbitmq:
        image: rabbitmq:4-management-alpine
        ports:
          - "5672:5672"
          - "15672:15672"
        env:
          RABBITMQ_DEFAULT_USER: tasker
          RABBITMQ_DEFAULT_PASS: tasker
          RABBITMQ_DEFAULT_VHOST: /
        options: >-
          --health-cmd "rabbitmq-diagnostics -q ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      # TAS-171: Dragonfly (Redis + Memcached compatible) for distributed cache
      # Exposes both Redis (6379) and Memcached (11211) protocols
      dragonfly:
        image: docker.dragonflydb.io/dragonflydb/dragonfly:latest
        ports:
          - "6379:6379"
          - "11211:11211"
        env:
          DFLY_memcached_port: 11211
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Free up disk space
        uses: ./.github/actions/free-disk-space

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.4"
          bundler-cache: true
          working-directory: workers/ruby

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.10"

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          version: "latest"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Restore Rust build cache
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-integration-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-integration-
            ${{ runner.os }}-cargo-

      - name: Setup shared environment variables
        uses: ./.github/actions/setup-env
        env:
          # TAS-133: Pass matrix messaging backend to setup-env action
          TASKER_MESSAGING_BACKEND: ${{ matrix.messaging_backend }}

      - name: Install tools
        uses: ./.github/actions/install-tools
        with:
          tools: "nextest sqlx-cli make"

      # TAS-177: Install protobuf compiler for gRPC proto compilation
      - name: Install protobuf compiler
        run: |
          sudo apt-get update
          sudo apt-get install -y protobuf-compiler
          protoc --version

      # ========================================================================
      # Download artifacts from multi-job build-workers workflow
      # ========================================================================
      - name: Download core artifacts
        uses: actions/download-artifact@v7
        with:
          name: core-artifacts
          path: artifacts/core

      - name: Download Ruby extension artifact
        uses: actions/download-artifact@v7
        with:
          name: ruby-extension
          path: artifacts/ruby
        continue-on-error: true

      - name: Download TypeScript artifacts
        uses: actions/download-artifact@v7
        with:
          name: typescript-artifacts
          path: artifacts/typescript
        continue-on-error: true

      - name: Download Rust worker artifact
        uses: actions/download-artifact@v7
        with:
          name: rust-worker-artifact
          path: artifacts/rust-worker
        continue-on-error: true

      - name: Restore artifacts to correct locations
        run: ARTIFACTS_BASE=artifacts cargo-make/scripts/ci-restore-all-artifacts.sh

      - name: Build Ruby FFI extension (if not from artifacts)
        run: |
          cd workers/ruby
          if ls lib/tasker_core/*.so 2>/dev/null || ls lib/tasker_core/*.bundle 2>/dev/null; then
            echo "‚úÖ Ruby extension already available from artifacts"
            ls -lh lib/tasker_core/
          else
            echo "üî® Building Ruby extension from source..."
            bundle install
            bundle exec rake compile
          fi
        env:
          SQLX_OFFLINE: "true"

      - name: Build Python FFI extension
        run: |
          echo "üî® Building Python FFI extension (uses warm cache)..."
          cd workers/python
          uv sync --dev
          uv run maturin develop
        env:
          SQLX_OFFLINE: "true"

      - name: Build Rust worker (if not from artifacts)
        run: |
          if [ -f target/debug/rust-worker ]; then
            echo "‚úÖ Rust worker already available from artifacts"
          else
            echo "üî® Building Rust worker from source..."
            cargo build --package tasker-worker-rust
          fi
        env:
          SQLX_OFFLINE: "true"

      - name: Setup TypeScript worker
        run: |
          echo "üìú Setting up TypeScript worker..."
          cd workers/typescript
          bun install --frozen-lockfile

          # Build the TypeScript worker (compiles to dist/)
          bun run build

          # The FFI library should be available from the debug build (matches sccache config)
          # For CI, we need to ensure the path is correct
          if [ -f "../../target/debug/libtasker_worker.so" ]; then
            echo "‚úÖ FFI library found at target/debug/libtasker_worker.so"
          else
            echo "‚ö†Ô∏è FFI library not found, building..."
            cargo build -p tasker-worker-ts
          fi
        env:
          DATABASE_URL: postgresql://tasker:tasker@localhost:5432/tasker_rust_test

      - name: Run database migrations
        run: sqlx migrate run
        env:
          DATABASE_URL: postgresql://tasker:tasker@localhost:5432/tasker_rust_test

      - name: Generate test configuration
        run: |
          mkdir -p config/tasker
          echo "üîß Generating orchestration configuration..."
          cargo run --package tasker-client --bin tasker-cli -- config generate \
            --context orchestration \
            --environment test \
            --source-dir config/tasker \
            --output config/tasker/generated/orchestration-test.toml
          echo "üîß Generating worker configuration..."
          cargo run --package tasker-client --bin tasker-cli -- config generate \
            --context worker \
            --environment test \
            --source-dir config/tasker \
            --output config/tasker/generated/worker-test.toml
        env:
          DATABASE_URL: postgresql://tasker:tasker@localhost:5432/tasker_rust_test

      - name: Start native services
        run: |
          mkdir -p .pids
          chmod +x .github/scripts/start-native-services.sh
          echo "üîß Starting services with messaging backend: $TASKER_MESSAGING_BACKEND"
          .github/scripts/start-native-services.sh
        env:
          DATABASE_URL: postgresql://tasker:tasker@localhost:5432/tasker_rust_test
          SKIP_MIGRATIONS: "true"
          # TAS-133: Messaging backend from matrix
          TASKER_MESSAGING_BACKEND: ${{ matrix.messaging_backend }}
          RABBITMQ_URL: amqp://tasker:tasker@localhost:5672/%2F
          # TAS-156: Redis for distributed template cache
          REDIS_URL: redis://localhost:6379

      - name: Run integration tests
        run: |
          echo "üèÅ Running integration tests..."
          mkdir -p target/nextest/ci
          cargo nextest run \
            --profile ci \
            --test '*' \
            --no-fail-fast
        env:
          DATABASE_URL: postgresql://tasker:tasker@localhost:5432/tasker_rust_test
          TASKER_TEST_ORCHESTRATION_URL: http://localhost:8080
          TASKER_TEST_WORKER_URL: http://localhost:8081
          TASKER_TEST_RUBY_WORKER_URL: http://localhost:8082
          TASKER_TEST_PYTHON_WORKER_URL: http://localhost:8083
          TASKER_TEST_TYPESCRIPT_WORKER_URL: http://localhost:8085
          TASKER_FIXTURE_PATH: ${{ github.workspace }}/tests/fixtures
          RUST_LOG: info
          # TAS-156: Redis for distributed template cache
          REDIS_URL: redis://localhost:6379

      - name: Upload integration test results
        uses: actions/upload-artifact@v6
        if: always() && hashFiles('target/nextest/ci/junit.xml') != ''
        with:
          # TAS-133: Unique artifact name per matrix job
          name: integration-test-results-${{ matrix.messaging_backend }}
          path: target/nextest/ci/junit.xml

      - name: Collect service logs on failure
        if: failure()
        run: |
          mkdir -p service-logs
          [ -f orchestration.log ] && cp orchestration.log service-logs/
          [ -f worker.log ] && cp worker.log service-logs/
          [ -f ruby-worker.log ] && cp ruby-worker.log service-logs/
          [ -f python-worker.log ] && cp python-worker.log service-logs/
          [ -f typescript-worker.log ] && cp typescript-worker.log service-logs/

      - name: Upload service logs
        if: failure()
        uses: actions/upload-artifact@v6
        with:
          # TAS-133: Unique artifact name per matrix job
          name: service-logs-${{ matrix.messaging_backend }}
          path: service-logs/

      - name: Stop native services
        if: always()
        run: |
          chmod +x .github/scripts/stop-native-services.sh
          .github/scripts/stop-native-services.sh
