# =============================================================================
# Integration Tests - Multi-Service Docker Compose Testing
# =============================================================================
# Tests the complete multi-service architecture using docker-compose.ci.yml
# with orchestration service, rust worker, and end-to-end workflow execution

name: "Integration Tests"

on:
  push:
    branches: ["main", "jcoletaylor/*"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  DOCKER_BUILDKIT: 1

jobs:
  # =============================================================================
  # Multi-Service Integration Tests
  # =============================================================================
  integration-tests:
    name: Multi-Service Integration Tests
    runs-on: ubuntu-22.04
    timeout-minutes: 30

    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host

      # Enable GitHub Actions cache for Docker layers
      - name: Set up Docker layer caching
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # Enable sccache for Rust compilation caching in CI
      - name: Run sccache-cache
        uses: mozilla-actions/sccache-action@v0.0.4

      - name: Set sccache environment variables
        run: |
          echo "SCCACHE_GHA_ENABLED=true" >> $GITHUB_ENV
          echo "RUSTC_WRAPPER=sccache" >> $GITHUB_ENV
          echo "SCCACHE_CACHE_SIZE=2G" >> $GITHUB_ENV

      # Build and start services using docker-compose.ci.yml
      - name: Start services with docker-compose
        working-directory: ./docker
        run: |
          echo "Building and starting services..."
          docker-compose -f docker-compose.ci.yml up --build -d
          
          # Wait for services to be healthy
          echo "Waiting for services to be ready..."
          timeout 180s bash -c '
            while ! docker-compose -f docker-compose.ci.yml ps --services --filter "status=running" | grep -q orchestration; do
              echo "Waiting for orchestration service..."
              sleep 2
            done
            
            while ! docker-compose -f docker-compose.ci.yml ps --services --filter "status=running" | grep -q worker; do
              echo "Waiting for worker service..."
              sleep 2
            done
          '

      - name: Check service health
        working-directory: ./docker
        run: |
          echo "Checking service status..."
          docker-compose -f docker-compose.ci.yml ps
          
          echo "Checking orchestration health..."
          docker-compose -f docker-compose.ci.yml exec -T orchestration curl -f http://localhost:8080/health || exit 1
          
          echo "Checking worker health..."
          docker-compose -f docker-compose.ci.yml exec -T worker curl -f http://localhost:8081/health || exit 1

      # Run the integration tests using testcontainers
      - name: Run testcontainers integration tests
        env:
          DATABASE_URL: postgresql://tasker:tasker@localhost:5432/tasker_rust_test
          TASKER_ENV: test
          RUST_LOG: info
          RUST_BACKTRACE: 1
        run: |
          # Run the specific integration test that uses testcontainers
          cargo test --test integration_rust_worker_e2e --verbose --all-features -- --nocapture

      # Run integration tests inside the docker environment
      - name: Run integration tests in docker environment
        working-directory: ./docker
        run: |
          echo "Running integration tests within docker services..."
          
          # Test that we can create and execute a task end-to-end
          docker-compose -f docker-compose.ci.yml exec -T orchestration bash -c '
            # Wait a bit more for full service initialization
            sleep 5
            
            # Test database connectivity
            echo "Testing database connectivity..."
            psql $DATABASE_URL -c "SELECT 1;" || exit 1
            
            # Test PGMQ functionality
            echo "Testing PGMQ functionality..."
            psql $DATABASE_URL -c "SELECT pgmq.create_queue(\"test_queue\");" || exit 1
            psql $DATABASE_URL -c "SELECT pgmq.send(\"test_queue\", \"{\\\"message\\\": \\\"test\\\"}\");" || exit 1
            psql $DATABASE_URL -c "SELECT pgmq.read(\"test_queue\", 1, 1);" || exit 1
          '

      - name: Show service logs on failure
        if: failure()
        working-directory: ./docker
        run: |
          echo "=== PostgreSQL Logs ==="
          docker-compose -f docker-compose.ci.yml logs postgres
          
          echo "=== Orchestration Logs ==="
          docker-compose -f docker-compose.ci.yml logs orchestration
          
          echo "=== Worker Logs ==="
          docker-compose -f docker-compose.ci.yml logs worker

      - name: Clean up services
        if: always()
        working-directory: ./docker
        run: |
          docker-compose -f docker-compose.ci.yml down -v
          docker system prune -f

  # =============================================================================
  # Test Individual Service Builds
  # =============================================================================
  test-service-builds:
    name: Test Individual Service Docker Builds
    runs-on: ubuntu-22.04
    timeout-minutes: 20

    strategy:
      matrix:
        service:
          - name: "orchestration"
            context: "."
            dockerfile: "docker/build/orchestration.ci.Dockerfile"
          - name: "worker"
            context: "."
            dockerfile: "docker/build/rust-worker.ci.Dockerfile"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Enable sccache for individual service builds
      - name: Run sccache-cache
        uses: mozilla-actions/sccache-action@v0.0.4

      - name: Build ${{ matrix.service.name }} service
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          dockerfile: ${{ matrix.service.dockerfile }}
          push: false
          tags: tasker-${{ matrix.service.name }}:ci-test
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            SCCACHE_GHA_ENABLED=true
            RUSTC_WRAPPER=sccache
            SCCACHE_CACHE_SIZE=2G

      - name: Test ${{ matrix.service.name }} service
        run: |
          echo "Testing ${{ matrix.service.name }} service build..."
          docker run --rm tasker-${{ matrix.service.name }}:ci-test --version || echo "Service started successfully"