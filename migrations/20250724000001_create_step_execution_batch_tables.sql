-- Create tables for ZeroMQ dual result pattern architecture
-- This supports batch execution with HABTM relationships and audit trail
-- Phase 3.1: Database foundation for production-grade batch orchestration

-- 1. Main batch table - replaces constructed batch_id strategy
CREATE TABLE IF NOT EXISTS public.tasker_step_execution_batches (
    batch_id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    task_id bigint NOT NULL REFERENCES public.tasker_tasks(task_id) ON DELETE CASCADE,
    handler_class character varying NOT NULL,
    batch_uuid character varying NOT NULL UNIQUE, -- For correlation with ZeroMQ messages
    initiated_by character varying, -- Source system or user who initiated the batch
    batch_size integer NOT NULL DEFAULT 0, -- Number of steps in this batch
    timeout_seconds integer DEFAULT 30, -- Batch execution timeout
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp(6) without time zone NOT NULL DEFAULT NOW(),
    updated_at timestamp(6) without time zone NOT NULL DEFAULT NOW()
);

-- 2. HABTM join table between batches and workflow steps
CREATE TABLE IF NOT EXISTS public.tasker_step_execution_batch_steps (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    batch_id bigint NOT NULL REFERENCES public.tasker_step_execution_batches(batch_id) ON DELETE CASCADE,
    workflow_step_id bigint NOT NULL REFERENCES public.tasker_workflow_steps(workflow_step_id) ON DELETE CASCADE,
    sequence_order integer NOT NULL DEFAULT 0, -- Order within batch for processing
    expected_handler_class character varying NOT NULL, -- Expected handler for this step
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp(6) without time zone NOT NULL DEFAULT NOW(),
    updated_at timestamp(6) without time zone NOT NULL DEFAULT NOW(),
    UNIQUE(batch_id, workflow_step_id) -- Ensures each workflow step appears only once per batch
);

-- 3. Append-only audit ledger for all received messages
CREATE TABLE IF NOT EXISTS public.tasker_step_execution_batch_received_results (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    batch_step_id bigint NOT NULL REFERENCES public.tasker_step_execution_batch_steps(id) ON DELETE CASCADE,
    message_type character varying NOT NULL, -- 'partial_result' or 'batch_completion'
    worker_id character varying, -- ID of worker that sent the message
    sequence_number integer, -- Sequence number for partial results
    status character varying, -- 'completed', 'failed', 'in_progress' for partial results
    execution_time_ms bigint, -- Execution time reported by worker
    raw_message_json jsonb NOT NULL, -- Complete message payload for audit/debug
    processed_at timestamp(6) without time zone, -- When this message was processed
    processing_errors jsonb, -- Any errors that occurred processing this message
    created_at timestamp(6) without time zone NOT NULL DEFAULT NOW(),
    updated_at timestamp(6) without time zone NOT NULL DEFAULT NOW()
);

-- 4. State machine transitions for batch lifecycle
CREATE TABLE IF NOT EXISTS public.tasker_step_execution_batch_transitions (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    batch_id bigint NOT NULL REFERENCES public.tasker_step_execution_batches(batch_id) ON DELETE CASCADE,
    to_state character varying NOT NULL,
    from_state character varying,
    event_name character varying, -- Event that triggered this transition
    metadata jsonb DEFAULT '{}'::jsonb,
    sort_key integer NOT NULL,
    most_recent boolean DEFAULT true NOT NULL,
    created_at timestamp(6) without time zone NOT NULL DEFAULT NOW(),
    updated_at timestamp(6) without time zone NOT NULL DEFAULT NOW()
);

-- Performance indexes
-- Batch lookup by task and status
CREATE INDEX IF NOT EXISTS idx_step_execution_batches_task_id ON public.tasker_step_execution_batches(task_id);
CREATE INDEX IF NOT EXISTS idx_step_execution_batches_batch_uuid ON public.tasker_step_execution_batches(batch_uuid);
CREATE INDEX IF NOT EXISTS idx_step_execution_batches_created_at ON public.tasker_step_execution_batches(created_at);

-- Join table lookups - critical for HABTM queries
CREATE INDEX IF NOT EXISTS idx_step_execution_batch_steps_batch_id ON public.tasker_step_execution_batch_steps(batch_id);
CREATE INDEX IF NOT EXISTS idx_step_execution_batch_steps_workflow_step_id ON public.tasker_step_execution_batch_steps(workflow_step_id);
CREATE INDEX IF NOT EXISTS idx_step_execution_batch_steps_sequence_order ON public.tasker_step_execution_batch_steps(batch_id, sequence_order);

-- Audit ledger queries - append-only table needs efficient lookups
CREATE INDEX IF NOT EXISTS idx_step_execution_batch_received_results_batch_step_id ON public.tasker_step_execution_batch_received_results(batch_step_id);
CREATE INDEX IF NOT EXISTS idx_step_execution_batch_received_results_message_type ON public.tasker_step_execution_batch_received_results(message_type);
CREATE INDEX IF NOT EXISTS idx_step_execution_batch_received_results_created_at ON public.tasker_step_execution_batch_received_results(created_at);
CREATE INDEX IF NOT EXISTS idx_step_execution_batch_received_results_worker_sequence ON public.tasker_step_execution_batch_received_results(worker_id, sequence_number);

-- State machine transitions - following established pattern
CREATE INDEX IF NOT EXISTS idx_step_execution_batch_transitions_batch_id ON public.tasker_step_execution_batch_transitions(batch_id);
CREATE INDEX IF NOT EXISTS idx_step_execution_batch_transitions_most_recent ON public.tasker_step_execution_batch_transitions(batch_id, most_recent) WHERE most_recent = true;
CREATE INDEX IF NOT EXISTS idx_step_execution_batch_transitions_sort_key ON public.tasker_step_execution_batch_transitions(batch_id, sort_key);

-- Comments for documentation
COMMENT ON TABLE public.tasker_step_execution_batches IS 'Main batch execution table for ZeroMQ dual result pattern - tracks batch lifecycle';
COMMENT ON COLUMN public.tasker_step_execution_batches.batch_uuid IS 'UUID for correlating ZeroMQ messages with database records';
COMMENT ON COLUMN public.tasker_step_execution_batches.batch_size IS 'Number of steps in batch - derived from join table count';

COMMENT ON TABLE public.tasker_step_execution_batch_steps IS 'HABTM join table linking batches to workflow steps - enables many-to-many relationship';
COMMENT ON CONSTRAINT tasker_step_execution_batch_steps_batch_id_workflow_step_id_key ON public.tasker_step_execution_batch_steps IS 'Ensures each workflow step appears only once per batch';

COMMENT ON TABLE public.tasker_step_execution_batch_received_results IS 'Append-only audit ledger for all ZeroMQ messages - supports reconciliation and debugging';
COMMENT ON COLUMN public.tasker_step_execution_batch_received_results.message_type IS 'Either partial_result (from workers) or batch_completion (from orchestrator)';
COMMENT ON COLUMN public.tasker_step_execution_batch_received_results.raw_message_json IS 'Complete ZeroMQ message payload for forensic analysis';

COMMENT ON TABLE public.tasker_step_execution_batch_transitions IS 'State machine transitions for batch lifecycle - follows established Tasker pattern';
COMMENT ON COLUMN public.tasker_step_execution_batch_transitions.most_recent IS 'Optimization flag for current state queries - only one record per batch should be true';