---
description:
globs:
alwaysApply: false
---
# Tasker Core Rust - Project Intelligence

## Critical Project Context

This is a **step handler foundation** in Rust that provides the base class for workflow orchestration across multiple frameworks (Rails, Python, Node.js). The Rust core IS the step handler that frameworks subclass, not just a coordinator.

**Key Insight**: Rust implements the complete step handler foundation with `handle()` lifecycle management. Frameworks extend this base with `process()` and `process_results()` hooks. Queue decisions are made by Rust but actual queuing is delegated to framework-specific implementations via dependency injection.

## Current Phase: Model Schema Alignment + Foundation Design

**Branch**: `making-models` - Currently in Phase 1 of 5-phase development plan.

**Critical Issue**: Database models have significant schema mismatches with PostgreSQL that must be fixed before proceeding. Additionally, the step handler foundation architecture requires complete design and implementation.

**Schema Reference**: `/Users/petetaylor/projects/tasker/spec/dummy/db/structure.sql` - This is the authoritative source for PostgreSQL schema.

**Step Handler Reference**: `/Users/petetaylor/projects/tasker/lib/tasker/step_handler.rb` - Reference for current Rails step handler pattern.

## Development Patterns

### Step Handler Foundation Requirements
- **Complete Lifecycle**: Rust handles `handle()` method with all lifecycle logic
- **Framework Hooks**: `process()` and `process_results()` methods overridable by frameworks
- **Queue Abstraction**: Dependency injection for Sidekiq, Celery, Bull, etc.
- **Universal Foundation**: Same base class works across Rails, Python, Node.js
- **FFI Subclassing**: Framework classes extend Rust foundation via FFI

### Database Model Requirements
- **Exact Schema Match**: Rust models MUST match PostgreSQL schema field-for-field
- **Type Precision**: Use `NaiveDateTime` for PostgreSQL timestamps, `String` for varchar fields
- **Nullable Fields**: Proper `Option<T>` for nullable database columns
- **No Computed Fields**: Remove fields like `state` that should be derived, not stored

### Testing Strategy
- **Transactional Tests**: Use `#[sqlx::test]` for automatic rollback and test isolation
- **Property-Based Testing**: Use `proptest` for DAG operations and cycle detection
- **Step Handler Testing**: Test subclass pattern with mock framework implementations
- **Multi-Language FFI**: Test step handler subclassing across Ruby, Python, Node.js

### Performance Priorities
- **Step Handler Lifecycle**: Primary target for performance vs Ruby implementation
- **Dependency Resolution**: 10-100x improvement over PostgreSQL functions
- **DAG Traversal**: Core algorithm that needs Rust optimization
- **FFI Overhead**: Keep step handler subclassing under 1ms penalty

## Key File Locations

### Models (Current Priority)
- `src/models/task.rs` - ✅ Complete (381 lines) - matches schema exactly
- `src/models/workflow_step_edge.rs` - ❌ Missing `id` and `name` fields (202 lines)
- `src/models/workflow_step.rs` - ❌ Field naming and missing booleans (485 lines)
- `src/models/named_task.rs` - ❌ Version should be String not i32 (405 lines)
- `src/models/named_step.rs` - ❌ Missing dependent_system_id (273 lines)

### Step Handler Foundation (Not Yet Implemented)
- `src/step_handler/foundation.rs` - ❌ Core step handler base class
- `src/step_handler/lifecycle.rs` - ❌ Complete `handle()` implementation
- `src/step_handler/hooks.rs` - ❌ `process()` and `process_results()` hook system
- `src/queue/injector.rs` - ❌ Queue abstraction trait
- `src/ffi/step_handler.rs` - ❌ Multi-language step handler subclassing

### Reference Documentation
- `docs/SCHEMA_ANALYSIS.md` - Comprehensive field-by-field comparison
- `docs/ORCHESTRATION_ANALYSIS.md` - Delegation pattern analysis (needs update)
- `docs/DEVELOPMENT_PLAN_REVISED.md` - 5-phase implementation plan
- `CLAUDE.md` - High-level project context and architecture

### Rails Integration
- Reference engine at `/Users/petetaylor/projects/tasker/`
- Step handler pattern: `lib/tasker/step_handler.rb`
- Database: `postgresql://tasker:tasker@localhost/tasker_rust_development`
- Shared schema - changes must maintain Rails compatibility

## Common Commands

### Development Workflow
```bash
# Build and test cycle
cargo build && cargo test

# Database operations
sqlx migrate run
sqlx prepare  # Generate query metadata

# Schema validation
cargo test --test model_integration_tests

# Performance benchmarking
cargo bench --features benchmarks
```

### Model Development
- Always start with schema analysis from Rails structure.sql
- Use `#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, FromRow)]`
- Test with both CRUD operations and FFI serialization
- Validate foreign key relationships work correctly

## Architecture Decisions

### Step Handler Foundation Pattern
```rust
// Core pattern - Rust IS the step handler foundation
pub struct StepHandlerFoundation {
    pub step_id: i64,
    pub task_id: i64,
    pub backoff_calculator: Arc<BackoffCalculator>,
    pub retry_analyzer: Arc<RetryAnalyzer>,
    pub output_processor: Arc<OutputProcessor>,
    pub queue_injector: Arc<dyn QueueInjector>,
}

impl StepHandlerFoundation {
    // Complete lifecycle in Rust
    pub async fn handle(&self) -> StepResult {
        let step = self.load_step().await?;
        let context = self.prepare_step_context(&step).await?;

        // Framework hook - user business logic
        let output = self.process(context).await?;

        // Framework hook - post-processing
        let processed = self.process_results(output).await?;

        // Foundation handles finalization
        self.finalize_step(&step, processed).await
    }

    // Framework-overridable methods (FFI hooks)
    async fn process(&self, context: StepContext) -> Result<StepOutput>;
    async fn process_results(&self, output: StepOutput) -> Result<ProcessedOutput>;
}
```

### Queue Abstraction Pattern
```rust
// Dependency injection for different queue backends
#[async_trait]
pub trait QueueInjector: Send + Sync {
    async fn enqueue_task(&self, task_id: i64, delay: Option<Duration>) -> Result<()>;
    async fn enqueue_step(&self, step_id: i64, delay: Option<Duration>) -> Result<()>;
}

// Framework-specific implementations
impl QueueInjector for SidekiqInjector { /* Rails Sidekiq */ }
impl QueueInjector for CeleryInjector { /* Python Celery */ }
impl QueueInjector for BullInjector { /* Node.js Bull */ }
```

### Multi-Language Subclassing
```ruby
# Rails step handler subclasses Rust foundation
class MyStepHandler < Tasker::StepHandler
  def process(context)
    # Business logic in Ruby
  end

  def process_results(output)
    # Post-processing in Ruby
  end
end
```

### Error Handling
- Use `thiserror` for structured error types
- Consistent `Result<T>` type alias throughout
- Cross-language error propagation via FFI
- Framework-specific error context

## Performance Considerations

### Step Handler Optimization
- Pre-compiled queries for step loading
- Cached step handler instances
- Efficient FFI data transfer
- Zero-copy serialization where possible

### Database Optimization
- Connection pooling (20 connections)
- Batch operations for bulk inserts/updates
- Prepared statements via SQLx compile-time verification
- FOR UPDATE SKIP LOCKED for step processing

### Memory Management
- Arc for shared step handler components
- Zero-copy operations in hot paths
- Careful lifetime management across FFI boundaries
- Efficient serialization for cross-language data

## Known Gotchas

1. **Architecture Paradigm Shift**: Changed from delegation coordinator to step handler foundation
2. **Multi-Language FFI**: Subclassing across languages is complex - need careful design
3. **Queue Abstraction**: Dependency injection must work with diverse queue systems
4. **Schema Evolution**: PostgreSQL schema is more complex than initial Rust models
5. **Rails Compatibility**: Must not break existing Rails Tasker engine sharing same DB
6. **Performance Validation**: Need benchmarking infrastructure before claiming improvements

## Success Metrics

**Phase 1 (Current)**: All models match PostgreSQL schema + step handler foundation designed
**Phase 2**: Universal step handler working across Rails, Python, Node.js with queue abstraction
**Phase 3**: Event system with >10k events/sec throughput across all frameworks
**Phase 4**: Production-ready multi-framework support with comprehensive observability
**Phase 5**: Full ecosystem with plugin system and advanced monitoring

## Universal Foundation Benefits

- **Same API**: `process()` and `process_results()` across all frameworks
- **Consistent Performance**: Same orchestration speed regardless of language
- **Framework Choice**: Pick Rails, Python, Node.js based on team expertise
- **Migration Path**: Move between frameworks without losing orchestration
- **Operational Simplicity**: Same monitoring and deployment across all languages
