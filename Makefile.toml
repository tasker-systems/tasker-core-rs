# =============================================================================
# Tasker Core - cargo-make Task Definitions
# =============================================================================
#
# Unified task runner for the tasker-core workspace.
# Provides consistent commands across Rust core and polyglot workers.
#
# Quick Start:
#   cargo make check       # Run all quality checks
#   cargo make test        # Run all tests
#   cargo make fix         # Auto-fix all fixable issues
#   cargo make build       # Build everything
#
# Language-Specific:
#   cargo make check-rust       # Rust core only
#   cargo make check-python     # Python worker only
#   cargo make check-ruby       # Ruby worker only
#   cargo make check-typescript # TypeScript worker only
#
# Infrastructure:
#   cargo make db-setup    # Setup database and run migrations
#   cargo make sqlx-prepare # Prepare SQLX query cache
#
# See: docs/development-patterns.md for full documentation
#
# =============================================================================

# Extend shared configuration files
extend = "./cargo-make/main.toml"

[config]
default_to_workspace = false
skip_core_tasks = true

[env]
# TAS-78: Load .env file for database configuration
# Database URLs come from .env (generated by cargo make setup-env-* tasks)
# To use split-db mode: cargo make setup-env-all-split
# To use single-db mode: cargo make setup-env-all
env_files = [".env"]
# NOTE: DATABASE_URL is NOT set here - it comes from .env file
# This allows split-db mode (test-split.env) to work correctly
# If .env doesn't exist, run: cargo make setup-env-all
TASKER_ENV = { value = "test", condition = { env_not_set = ["TASKER_ENV"] } }
# Use relative path for scripts to avoid path duplication issues
SCRIPTS_DIR = "cargo-make/scripts"

# =============================================================================
# Top-Level Composite Tasks
# =============================================================================

[tasks.default]
description = "Default: show available tasks"
script = '''
echo "Tasker Core - cargo-make Tasks"
echo "==============================="
echo ""
echo "Common Tasks:"
echo "  cargo make check         Run all quality checks"
echo "  cargo make test          Run all tests"
echo "  cargo make fix           Auto-fix all issues"
echo "  cargo make build         Build everything"
echo ""
echo "Language-Specific:"
echo "  cargo make check-rust"
echo "  cargo make check-python"
echo "  cargo make check-ruby"
echo "  cargo make check-typescript"
echo ""
echo "Infrastructure:"
echo "  cargo make db-setup      Setup database"
echo "  cargo make sqlx-prepare  Prepare SQLX cache"
echo ""
echo "Run 'cargo make --list-all-steps' for all tasks"
'''

[tasks.check]
description = "Run all quality checks across workspace"
dependencies = ["check-rust", "check-python", "check-ruby", "check-typescript"]

[tasks.test]
description = "Run all tests across workspace"
dependencies = ["test-rust", "test-python", "test-ruby", "test-typescript"]

[tasks.fix]
description = "Auto-fix all fixable issues"
dependencies = ["fix-rust", "fix-python", "fix-ruby", "fix-typescript"]

[tasks.build]
description = "Build everything"
dependencies = ["build-rust", "build-python", "build-ruby", "build-typescript"]

# =============================================================================
# Rust Core Tasks
# =============================================================================

[tasks.check-rust]
description = "Run all Rust quality checks"
dependencies = ["rust-fmt-check", "rust-clippy", "rust-docs", "rust-doctests", "rust-machete"]

[tasks.test-rust]
description = "Run all Rust tests with nextest (loads .env for E2E tests)"
script = '''
#!/bin/bash
# Load environment from .env for E2E tests
set -a
source .env 2>/dev/null || true
set +a
cargo nextest run --workspace --all-features
'''

[tasks.test-rust-unit]
description = "Run Rust unit tests only across workspace (excludes e2e and integration tests that require services)"
script = '''
cargo nextest run --workspace --all-features -E 'not binary(e2e_tests) & not binary(integration_tests)'
'''

[tasks.test-rust-e2e]
description = "Run Rust e2e and integration tests only (requires services running)"
script = '''
#!/bin/bash
# Load environment from .env for fixture paths and config
set -a
source .env
set +a
echo "üìã Loaded environment: TASKER_FIXTURE_PATH=$TASKER_FIXTURE_PATH"
cargo nextest run --workspace --all-features -E 'binary(e2e_tests) | binary(integration_tests)'
'''

[tasks.test-rust-verbose]
description = "Run Rust tests with output"
script = '''
cargo nextest run --all-features --no-capture
'''

[tasks.fix-rust]
description = "Fix Rust formatting and clippy issues"
dependencies = ["rust-fmt-fix", "rust-clippy-fix"]

[tasks.build-rust]
description = "Build all Rust crates (auto-detects split-db mode)"
script = { file = "${SCRIPTS_DIR}/build-rust.sh" }

[tasks.build-rust-release]
description = "Build all Rust crates (release)"
command = "cargo"
args = ["build", "--all-features", "--release"]

# --- Rust Sub-Tasks ---

[tasks.rust-fmt-check]
description = "Check Rust formatting"
command = "cargo"
args = ["fmt", "--all", "--", "--check"]

[tasks.rust-fmt-fix]
description = "Fix Rust formatting"
command = "cargo"
args = ["fmt", "--all"]

[tasks.rust-clippy]
description = "Run Clippy lints"
command = "cargo"
args = ["clippy", "--all-targets", "--all-features", "--", "-D", "warnings"]

[tasks.rust-clippy-fix]
description = "Fix Clippy issues"
command = "cargo"
args = [
  "clippy",
  "--all-targets",
  "--all-features",
  "--fix",
  "--allow-dirty",
  "--allow-staged"
]

[tasks.rust-docs]
description = "Check documentation builds"
command = "cargo"
args = ["doc", "--no-deps", "--document-private-items"]

[tasks.rust-audit]
description = "Run security audit"
command = "cargo"
args = ["audit"]

[tasks.rust-bench-check]
description = "Check benchmarks compile"
command = "cargo"
args = ["check", "--benches", "--features", "benchmarks"]

[tasks.rust-doctests]
description = "Run documentation tests"
command = "cargo"
args = ["test", "--doc", "--workspace", "--all-features"]

[tasks.rust-machete]
description = "Check for unused Cargo dependencies"
command = "cargo"
args = ["machete", "--with-metadata"]

# =============================================================================
# Python Worker Tasks
# =============================================================================

[tasks.check-python]
description = "Run Python worker quality checks"
cwd = "workers/python"
command = "cargo"
args = ["make", "check"]

[tasks.test-python]
description = "Run Python worker tests"
cwd = "workers/python"
command = "cargo"
args = ["make", "test"]

[tasks.fix-python]
description = "Fix Python worker issues"
cwd = "workers/python"
command = "cargo"
args = ["make", "fix"]

[tasks.build-python]
description = "Build Python worker (auto-detects split-db mode)"
script = '''
#!/bin/bash
set -euo pipefail
# Enable SQLX_OFFLINE in split-database mode
if [ -n "${PGMQ_DATABASE_URL:-}" ] && [ "${PGMQ_DATABASE_URL}" != "${DATABASE_URL:-}" ]; then
    echo "üîÄ Split database mode - using SQLX_OFFLINE=true for Python build"
    export SQLX_OFFLINE=true
fi
cd workers/python && cargo make build
'''

# =============================================================================
# Ruby Worker Tasks
# =============================================================================

[tasks.check-ruby]
description = "Run Ruby worker quality checks"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "check"]

[tasks.test-ruby]
description = "Run Ruby worker tests"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "test"]

[tasks.fix-ruby]
description = "Fix Ruby worker issues"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "fix"]

[tasks.build-ruby]
description = "Build Ruby worker (auto-detects split-db mode)"
script = '''
#!/bin/bash
set -euo pipefail
# Enable SQLX_OFFLINE in split-database mode
if [ -n "${PGMQ_DATABASE_URL:-}" ] && [ "${PGMQ_DATABASE_URL}" != "${DATABASE_URL:-}" ]; then
    echo "üîÄ Split database mode - using SQLX_OFFLINE=true for Ruby build"
    export SQLX_OFFLINE=true
fi
cd workers/ruby && cargo make build
'''

# =============================================================================
# TypeScript Worker Tasks
# =============================================================================

[tasks.check-typescript]
description = "Run TypeScript worker quality checks"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "check"]

[tasks.test-typescript]
description = "Run TypeScript worker tests"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "test"]

[tasks.fix-typescript]
description = "Fix TypeScript worker issues"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "fix"]

[tasks.build-typescript]
description = "Build TypeScript worker (auto-detects split-db mode)"
script = '''
#!/bin/bash
set -euo pipefail
# Enable SQLX_OFFLINE in split-database mode
if [ -n "${PGMQ_DATABASE_URL:-}" ] && [ "${PGMQ_DATABASE_URL}" != "${DATABASE_URL:-}" ]; then
    echo "üîÄ Split database mode - using SQLX_OFFLINE=true for TypeScript build"
    export SQLX_OFFLINE=true
fi
cd workers/typescript && cargo make build
'''

[tasks.test-typescript-ffi]
description = "Run TypeScript FFI integration tests (all runtimes)"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "test-ffi-all"]

# =============================================================================
# Rust Worker Tasks
# =============================================================================

[tasks.check-rust-worker]
description = "Run Rust worker quality checks"
cwd = "workers/rust"
command = "cargo"
args = ["make", "check"]

[tasks.test-rust-worker]
description = "Run Rust worker tests"
cwd = "workers/rust"
command = "cargo"
args = ["make", "test"]

[tasks.build-rust-worker]
description = "Build Rust worker"
cwd = "workers/rust"
command = "cargo"
args = ["make", "build"]

# =============================================================================
# FFI Integration Test Tasks
# =============================================================================

[tasks.test-python-ffi]
description = "Run Python FFI integration tests"
cwd = "workers/python"
command = "cargo"
args = ["make", "test-ffi"]

[tasks.test-ruby-ffi]
description = "Run Ruby FFI integration tests"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "test-ffi"]

# =============================================================================
# Environment Setup Tasks
# =============================================================================

[tasks.setup-env]
description = "Generate .env file for root (standard test mode)"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=root --mode=test
'''

[tasks.setup-env-split]
description = "Generate .env file for root (split database mode)"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=root --mode=test-split
'''

[tasks.setup-env-orchestration]
description = "Generate .env file for orchestration service"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=orchestration --mode=test
'''

[tasks.setup-env-rust-worker]
description = "Generate .env file for Rust worker"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=rust-worker --mode=test
'''

[tasks.setup-env-ruby-worker]
description = "Generate .env file for Ruby worker"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=ruby-worker --mode=test
'''

[tasks.setup-env-python-worker]
description = "Generate .env file for Python worker"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=python-worker --mode=test
'''

[tasks.setup-env-typescript-worker]
description = "Generate .env file for TypeScript worker"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=typescript-worker --mode=test
'''

[tasks.setup-env-all]
description = "Generate .env files for all targets"
dependencies = [
  "setup-env",
  "setup-env-orchestration",
  "setup-env-rust-worker",
  "setup-env-ruby-worker",
  "setup-env-python-worker",
  "setup-env-typescript-worker",
]

[tasks.setup-env-all-split]
description = "Generate .env files for all targets (split database mode)"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=root --mode=test-split
${SCRIPTS_DIR}/setup-env.sh --target=orchestration --mode=test-split
${SCRIPTS_DIR}/setup-env.sh --target=rust-worker --mode=test-split
${SCRIPTS_DIR}/setup-env.sh --target=ruby-worker --mode=test-split
${SCRIPTS_DIR}/setup-env.sh --target=python-worker --mode=test-split
${SCRIPTS_DIR}/setup-env.sh --target=typescript-worker --mode=test-split
'''

# =============================================================================
# Database & Infrastructure Tasks
# =============================================================================

[tasks.db-setup]
description = "Setup database with migrations"
dependencies = ["db-check", "db-migrate"]

[tasks.db-check]
description = "Check database connectivity"
script = { file = "${SCRIPTS_DIR}/check-db.sh" }

[tasks.db-migrate]
description = "Run database migrations"
script = { file = "${SCRIPTS_DIR}/run-migrations.sh" }

[tasks.db-reset]
description = "Reset database (drop and recreate)"
script = { file = "${SCRIPTS_DIR}/reset-db.sh" }

# TAS-78: Split Database Mode Tasks
[tasks.db-migrate-split]
description = "Run migrations in split database mode (requires PGMQ_DATABASE_URL)"
script = '''
#!/bin/bash
set -euo pipefail

if [ -z "${PGMQ_DATABASE_URL:-}" ]; then
    echo "‚ùå PGMQ_DATABASE_URL not set"
    echo ""
    echo "Usage:"
    echo "  PGMQ_DATABASE_URL=postgresql://... cargo make db-migrate-split"
    echo ""
    echo "Or use docker-compose for dual-database testing:"
    echo "  docker compose -f docker/docker-compose.dual-pg.test.yml up -d"
    echo "  source docker/dual-pg.env"
    echo "  cargo make db-migrate-split"
    exit 1
fi

echo "üîÄ Running split database migrations..."
${SCRIPTS_DIR}/run-migrations.sh
'''

[tasks.db-setup-split]
description = "Setup split databases with migrations (requires PGMQ_DATABASE_URL)"
dependencies = ["db-check-split", "db-migrate-split"]

[tasks.db-check-split]
description = "Check connectivity to both Tasker and PGMQ databases"
script = '''
#!/bin/bash
set -euo pipefail

echo "üîç Checking database connectivity..."

# Check Tasker database
echo -n "Tasker DB: "
if pg_isready -d "${DATABASE_URL}" > /dev/null 2>&1; then
    echo "‚úì connected"
else
    echo "‚ùå not reachable"
    exit 1
fi

# Check PGMQ database (if set)
if [ -n "${PGMQ_DATABASE_URL:-}" ]; then
    echo -n "PGMQ DB:   "
    if pg_isready -d "${PGMQ_DATABASE_URL}" > /dev/null 2>&1; then
        echo "‚úì connected"
    else
        echo "‚ùå not reachable"
        exit 1
    fi
fi

echo ""
echo "‚úì All databases reachable"
'''

# =============================================================================
# SQLX Cache Tasks
# =============================================================================

[tasks.sqlx-prepare]
description = "Prepare SQLX query cache for offline compilation"
script = { file = "${SCRIPTS_DIR}/sqlx-prepare.sh" }

[tasks.sqlx-check]
description = "Verify SQLX cache is up to date"
script = '''
echo "üîç Checking SQLX cache..."
SQLX_OFFLINE=true cargo check --all-features
echo "‚úì SQLX cache is valid"
'''

# =============================================================================
# Docker Tasks
# =============================================================================

[tasks.docker-up]
description = "Start Docker services (auto-detects split mode if PGMQ_DATABASE_URL set)"
script = { file = "${SCRIPTS_DIR}/docker-up.sh" }

[tasks.docker-down]
description = "Stop Docker services (auto-detects split mode)"
script = { file = "${SCRIPTS_DIR}/docker-down.sh" }

[tasks.docker-logs]
description = "Show Docker logs (auto-detects split mode)"
script = '''
#!/bin/bash
set -euo pipefail
source "cargo-make/scripts/docker-env.sh"
if [ -n "${PGMQ_DATABASE_URL:-}" ] && [ "${PGMQ_DATABASE_URL}" != "${DATABASE_URL:-}" ]; then
    $COMPOSE_CMD -f docker/docker-compose.dual-pg.test.yml logs -f
else
    $COMPOSE_CMD logs -f
fi
'''

# Split-database specific Docker tasks (TAS-78)
[tasks.docker-up-split]
description = "Start dual-database Docker setup for TAS-78 testing"
script = { file = "${SCRIPTS_DIR}/docker-up-split.sh" }

[tasks.docker-down-split]
description = "Stop dual-database Docker setup"
script = '''
#!/bin/bash
set -euo pipefail
source "cargo-make/scripts/docker-env.sh"
$COMPOSE_CMD -f docker/docker-compose.dual-pg.test.yml down
'''

[tasks.docker-down-split-volumes]
description = "Stop dual-database Docker setup and remove volumes (clean slate)"
script = '''
#!/bin/bash
set -euo pipefail
source "cargo-make/scripts/docker-env.sh"
$COMPOSE_CMD -f docker/docker-compose.dual-pg.test.yml down -v
'''

# =============================================================================
# Clean Tasks
# =============================================================================

[tasks.clean]
description = "Clean all build artifacts"
dependencies = ["clean-rust", "clean-workers"]

[tasks.clean-rust]
description = "Clean Rust build artifacts"
command = "cargo"
args = ["clean"]

[tasks.clean-workers]
description = "Clean all worker build artifacts"
script = { file = "${SCRIPTS_DIR}/clean-workers.sh" }

# =============================================================================
# CI Tasks (for GitHub Actions)
# =============================================================================

[tasks.ci-check]
description = "CI: Run all quality checks"
dependencies = ["rust-fmt-check", "rust-clippy", "rust-docs", "rust-audit"]

[tasks.ci-test]
description = "CI: Run all tests"
script = '''
cargo nextest run --all-features --profile ci
'''

[tasks.ci-prepare]
description = "CI: Prepare for offline builds"
dependencies = ["sqlx-prepare"]

# =============================================================================
# Development Convenience Tasks
# =============================================================================

[tasks.setup]
description = "Full development setup (auto-detects split mode)"
dependencies = ["docker-up", "db-setup", "setup-workers"]

[tasks.setup-split]
description = "Full development setup for split-database mode (TAS-78)"
script = { file = "${SCRIPTS_DIR}/setup-split.sh" }

[tasks.setup-workers]
description = "Setup all workers"
script = { file = "${SCRIPTS_DIR}/setup-workers.sh" }

[tasks.watch]
description = "Watch for changes and run tests"
script = '''
cargo watch -x "nextest run --all-features"
'''

[tasks.watch-check]
description = "Watch for changes and run checks"
script = '''
cargo watch -x "clippy --all-targets --all-features"
'''

# =============================================================================
# Quick Shortcuts
# =============================================================================

[tasks.c]
description = "Alias for check"
alias = "check"

[tasks.t]
description = "Alias for test"
alias = "test"

[tasks.f]
description = "Alias for fix"
alias = "fix"

[tasks.b]
description = "Alias for build"
alias = "build"

[tasks.tu]
description = "Alias for test-rust-unit (unit tests only, no services required)"
alias = "test-rust-unit"

# =============================================================================
# Service Management Tasks
# =============================================================================
# Local service execution for E2E testing without Docker containers.
# Each service runs as a background process with PID tracking in .pids/
#
# Port Mapping:
#   Orchestration: 8080
#   Rust Worker:   8081
#   Ruby Worker:   8082
#   Python Worker: 8083
#   TypeScript Worker: 8085
#
# Usage:
#   cargo make services-start      # Start all services
#   cargo make services-stop       # Stop all services
#   cargo make services-status     # Check all services status
#   cargo make services-logs-clear # Clear all log files
#   cargo make run-orchestration   # Start orchestration service
#   cargo make run-worker-python   # Start Python worker
#
# Prerequisites:
#   - PostgreSQL running (via docker-compose or locally)
#   - Run 'cargo make build' first to build all services

[tasks.services-status]
description = "Check status of all local services"
script = '''
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-status.sh --all
'''

[tasks.services-start]
description = "Start all services (orchestration + all workers)"
script = '''
echo "üöÄ Starting all Tasker services..."
echo ""

# Start orchestration first
echo "=== Starting Orchestration ==="
cargo make run-orchestration
echo ""

# Start workers in parallel by launching them sequentially
# (each returns quickly after backgrounding)
echo "=== Starting Workers ==="
cargo make run-worker-rust
cargo make run-worker-python
cargo make run-worker-ruby
cargo make run-worker-typescript

echo ""
echo "‚è≥ Waiting for services to initialize..."
sleep 5

echo ""
cargo make services-status
'''

[tasks.services-logs-clear]
description = "Clear all service log files"
script = '''
LOG_DIR=".logs"
if [ -d "$LOG_DIR" ]; then
    echo "üßπ Clearing service logs..."
    rm -f "$LOG_DIR"/*.log
    echo "‚úÖ Logs cleared"
else
    echo "No log directory found at $LOG_DIR"
fi
'''

[tasks.services-stop]
description = "Stop all running services"
script = '''
echo "üõë Stopping all services..."
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-stop.sh orchestration || true
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-stop.sh rust-worker || true
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-stop.sh ruby-worker || true
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-stop.sh python-worker || true
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-stop.sh typescript-worker || true
echo "‚úÖ All services stopped"
'''

[tasks.services-health-check]
description = "Check health endpoints of all running services"
script = '''
#!/bin/bash
# Services health check - validates health endpoints for all workers
# Uses port configuration from worker .env files

echo "üè• Checking service health endpoints..."
echo ""

# Service definitions: name|port|.env path
services=(
    "Orchestration|8080|"
    "Rust Worker|8081|workers/rust/.env"
    "Ruby Worker|8082|workers/ruby/.env"
    "Python Worker|8083|workers/python/.env"
    "TypeScript Worker|8085|workers/typescript/.env"
)

all_healthy=true
failed_count=0
success_count=0

for service in "${services[@]}"; do
    IFS='|' read -r name port env_file <<< "$service"

    # Try to get port from .env if specified
    if [ -n "$env_file" ] && [ -f "$env_file" ]; then
        env_port=$(grep "^PORT=" "$env_file" | cut -d'=' -f2 | tr -d '"' | tr -d "'")
        if [ -n "$env_port" ]; then
            port="$env_port"
        fi
    fi

    url="http://localhost:${port}/health"
    printf "%-20s " "$name (${port}):"

    # Check health endpoint with timeout
    response=$(curl -s --connect-timeout 2 --max-time 5 "$url" 2>/dev/null)

    if [ -n "$response" ]; then
        # Parse status using jq if available, otherwise grep
        if command -v jq &> /dev/null; then
            status=$(echo "$response" | jq -r '.status // "unknown"' 2>/dev/null)
        else
            status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)
        fi

        if [ "$status" = "healthy" ]; then
            echo "‚úÖ healthy"
            ((success_count++))
        else
            echo "‚ö†Ô∏è  status: $status"
            all_healthy=false
            ((failed_count++))
        fi
    else
        echo "‚ùå not responding"
        all_healthy=false
        ((failed_count++))
    fi
done

echo ""
echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
echo "Summary: $success_count healthy, $failed_count failed"

if [ "$all_healthy" = true ]; then
    echo "‚úÖ All services healthy"
    exit 0
else
    echo "‚ö†Ô∏è  Some services not healthy"
    exit 1
fi
'''

# --- Orchestration Service ---

[tasks.run-orchestration]
description = "Run orchestration service (port 8080)"
script = '''
# TAS-78: Preserve database URLs if already set (for split-database mode)
_SAVED_DATABASE_URL="${DATABASE_URL:-}"
_SAVED_PGMQ_DATABASE_URL="${PGMQ_DATABASE_URL:-}"

source .env 2>/dev/null || true

# Restore preserved URLs (split-db mode takes precedence)
[ -n "$_SAVED_DATABASE_URL" ] && export DATABASE_URL="$_SAVED_DATABASE_URL"
[ -n "$_SAVED_PGMQ_DATABASE_URL" ] && export PGMQ_DATABASE_URL="$_SAVED_PGMQ_DATABASE_URL"

export TASKER_ENV=${TASKER_ENV:-test}
export PORT=8080
export TASKER_CONFIG_PATH=${TASKER_CONFIG_PATH:-$(pwd)/config/tasker/complete-test.toml}

echo "üéØ Starting orchestration service..."
echo "   Port: ${PORT}"
echo "   Config: ${TASKER_CONFIG_PATH}"
echo "   Database: ${DATABASE_URL}"

PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-start.sh orchestration \
    cargo run -p tasker-orchestration
'''

[tasks.stop-orchestration]
description = "Stop orchestration service"
script = '''
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-stop.sh orchestration
'''

[tasks.status-orchestration]
description = "Check orchestration service status"
script = '''
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-status.sh orchestration
'''

[tasks.logs-orchestration]
description = "Tail orchestration service logs"
script = '''
LOG_FILE=".logs/orchestration.log"
if [ -f "$LOG_FILE" ]; then
    tail -f "$LOG_FILE"
else
    echo "No log file found at $LOG_FILE"
    echo "Start the service first with: cargo make run-orchestration"
fi
'''

# --- Rust Worker ---

[tasks.run-worker-rust]
description = "Run Rust worker service (port 8081)"
cwd = "workers/rust"
command = "cargo"
args = ["make", "run"]

[tasks.stop-worker-rust]
description = "Stop Rust worker service"
cwd = "workers/rust"
command = "cargo"
args = ["make", "stop"]

[tasks.status-worker-rust]
description = "Check Rust worker status"
cwd = "workers/rust"
command = "cargo"
args = ["make", "status"]

# --- Ruby Worker ---

[tasks.run-worker-ruby]
description = "Run Ruby worker service (port 8082)"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "run"]

[tasks.stop-worker-ruby]
description = "Stop Ruby worker service"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "stop"]

[tasks.status-worker-ruby]
description = "Check Ruby worker status"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "status"]

# --- Python Worker ---

[tasks.run-worker-python]
description = "Run Python worker service (port 8083)"
cwd = "workers/python"
command = "cargo"
args = ["make", "run"]

[tasks.stop-worker-python]
description = "Stop Python worker service"
cwd = "workers/python"
command = "cargo"
args = ["make", "stop"]

[tasks.status-worker-python]
description = "Check Python worker status"
cwd = "workers/python"
command = "cargo"
args = ["make", "status"]

# --- TypeScript Worker ---

[tasks.run-worker-typescript]
description = "Run TypeScript worker service (port 8085)"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "run"]

[tasks.stop-worker-typescript]
description = "Stop TypeScript worker service"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "stop"]

[tasks.status-worker-typescript]
description = "Check TypeScript worker status"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "status"]

# =============================================================================
# TAS-73: Multi-Instance Cluster Tasks
# =============================================================================
# Run multiple instances of orchestration/workers for horizontal scaling tests.
#
# Port Allocation (multi-instance mode):
#   Orchestration:  8080-8089 (up to 10 instances)
#   Rust Workers:   8100-8109
#   Ruby Workers:   8200-8209
#   Python Workers: 8300-8309
#   TS Workers:     8400-8409
#
# Usage:
#   cargo make cluster-start              # Start default cluster (2 orch + 2 workers)
#   cargo make cluster-stop               # Stop all cluster instances
#   cargo make cluster-status             # Check all instance health
#   cargo make cluster-start-orchestration # Start orchestration instances only
#   cargo make cluster-start-workers      # Start worker instances only
#
# Environment Variables:
#   TASKER_ORCHESTRATION_INSTANCES - Number of orchestration instances (default: 2)
#   TASKER_WORKER_RUST_INSTANCES   - Number of rust worker instances (default: 2)
#
# See: docs/ticket-specs/TAS-73/multi-instance-deployment.md

[tasks.cluster-start]
description = "Start full multi-instance cluster (orchestration + workers)"
dependencies = ["cluster-start-orchestration", "cluster-start-workers"]
script = '''
echo ""
echo "‚è≥ Waiting for cluster to initialize..."
sleep 5
cargo make cluster-status
'''

[tasks.cluster-start-orchestration]
description = "Start N orchestration instances"
script = '''
COUNT="${TASKER_ORCHESTRATION_INSTANCES:-2}"
echo "üöÄ Starting $COUNT orchestration instance(s)..."
bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" orchestration "$COUNT"
'''

[tasks.cluster-start-workers]
description = "Start N worker instances of each configured type"
script = '''
RUST_COUNT="${TASKER_WORKER_RUST_INSTANCES:-2}"
echo "üöÄ Starting $RUST_COUNT rust worker instance(s)..."
bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" worker-rust "$RUST_COUNT"
'''

[tasks.cluster-stop]
description = "Stop all cluster instances"
script = '''
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh"
'''

[tasks.cluster-stop-orchestration]
description = "Stop orchestration instances only"
script = '''
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh" orchestration
'''

[tasks.cluster-stop-workers]
description = "Stop all worker instances"
script = '''
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh" worker-rust
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh" worker-ruby
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh" worker-python
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh" worker-ts
'''

[tasks.cluster-status]
description = "Check status and health of all cluster instances"
script = '''
bash "${SCRIPTS_DIR}/multi-deploy/cluster-status.sh"
'''

[tasks.cluster-status-quick]
description = "Check status of cluster instances (no health checks)"
script = '''
bash "${SCRIPTS_DIR}/multi-deploy/cluster-status.sh" --no-health
'''

[tasks.cluster-logs]
description = "Tail logs from all cluster instances"
script = '''
if ls .logs/orchestration-*.log .logs/worker-*.log 1>/dev/null 2>&1; then
    tail -f .logs/orchestration-*.log .logs/worker-*.log
else
    echo "No cluster logs found. Start cluster first with: cargo make cluster-start"
fi
'''

[tasks.cluster-logs-orchestration]
description = "Tail logs from orchestration instances only"
script = '''
if ls .logs/orchestration-*.log 1>/dev/null 2>&1; then
    tail -f .logs/orchestration-*.log
else
    echo "No orchestration logs found. Start cluster first with: cargo make cluster-start-orchestration"
fi
'''
