# =============================================================================
# Tasker Core - cargo-make Task Definitions
# =============================================================================
#
# Unified task runner for the tasker-core workspace.
# Provides consistent commands across Rust core and polyglot workers.
#
# Quick Start:
#   cargo make check       # Run all quality checks
#   cargo make test        # Run all tests
#   cargo make fix         # Auto-fix all fixable issues
#   cargo make build       # Build everything
#
# Language-Specific:
#   cargo make check-rust       # Rust core only
#   cargo make check-python     # Python worker only
#   cargo make check-ruby       # Ruby worker only
#   cargo make check-typescript # TypeScript worker only
#
# Infrastructure:
#   cargo make db-setup    # Setup database and run migrations
#   cargo make sqlx-prepare # Prepare SQLX query cache
#
# See: docs/development-patterns.md for full documentation
#
# =============================================================================

# Extend shared configuration files
extend = "./cargo-make/main.toml"

[config]
default_to_workspace = false
skip_core_tasks = true

[env]
# TAS-78: Load .env file for database configuration
# Database URLs come from .env (generated by cargo make setup-env-* tasks)
# To use split-db mode: cargo make setup-env-all-split
# To use single-db mode: cargo make setup-env-all
env_files = [".env"]
# NOTE: DATABASE_URL is NOT set here - it comes from .env file
# This allows split-db mode (test-split.env) to work correctly
# If .env doesn't exist, run: cargo make setup-env-all
TASKER_ENV = { value = "test", condition = { env_not_set = ["TASKER_ENV"] } }
# Use relative path for scripts to avoid path duplication issues
SCRIPTS_DIR = "cargo-make/scripts"

# =============================================================================
# Top-Level Composite Tasks
# =============================================================================

[tasks.default]
description = "Default: show available tasks"
script = '''
echo "Tasker Core - cargo-make Tasks"
echo "==============================="
echo ""
echo "Common Tasks:"
echo "  cargo make check         Run all quality checks"
echo "  cargo make test          Run all tests"
echo "  cargo make fix           Auto-fix all issues"
echo "  cargo make build         Build everything"
echo ""
echo "Language-Specific:"
echo "  cargo make check-rust"
echo "  cargo make check-python"
echo "  cargo make check-ruby"
echo "  cargo make check-typescript"
echo ""
echo "Infrastructure:"
echo "  cargo make db-setup      Setup database"
echo "  cargo make sqlx-prepare  Prepare SQLX cache"
echo ""
echo "Benchmarks (TAS-159):"
echo "  cargo make services-start-release    Start services (release mode)"
echo "  cargo make bench-e2e           (be)   Tier 1: Rust core"
echo "  cargo make bench-e2e-full      (bef)  Tier 1+2: + complexity"
echo "  cargo make bench-e2e-cluster   (bec)  Tier 3: Multi-instance"
echo "  cargo make bench-e2e-languages (bel)  Tier 4: FFI comparison"
echo "  cargo make bench-e2e-batch     (beb)  Tier 5: Batch processing"
echo "  cargo make bench-e2e-all       (bea)  All tiers"
echo "  cargo make bench-report        (br)   Generate percentile report"
echo "  cargo make bench-analysis      (ba)   Generate analysis document"
echo ""
echo "tokio-console (TAS-158):"
echo "  cargo make build-console              Build with tokio-console"
echo "  cargo make run-console-orchestration  Run orchestration with console"
echo "  cargo make run-console-worker-rust    Run Rust worker with console"
echo "  cargo make console                    Open tokio-console"
echo ""
echo "samply Profiling (TAS-161):"
echo "  cargo make build-profiling      (bp)   Build with profiling profile"
echo "  cargo make run-samply-orchestration (rso)  Run orchestration under samply"
echo "  cargo make run-samply-worker-rust (rswr)   Run Rust worker under samply"
echo ""
echo "Run 'cargo make --list-all-steps' for all tasks"
'''

[tasks.check]
description = "Run all quality checks across workspace"
dependencies = ["check-rust", "check-python", "check-ruby", "check-typescript"]

[tasks.test]
description = "Run all tests across workspace"
dependencies = ["test-rust", "test-python", "test-ruby", "test-typescript"]

[tasks.fix]
description = "Auto-fix all fixable issues"
dependencies = ["fix-rust", "fix-python", "fix-ruby", "fix-typescript"]

[tasks.build]
description = "Build everything"
dependencies = ["build-rust", "build-python", "build-ruby", "build-typescript"]

# =============================================================================
# Rust Core Tasks
# =============================================================================

[tasks.check-rust]
description = "Run all Rust quality checks"
dependencies = ["rust-fmt-check", "rust-clippy", "rust-docs", "rust-doctests", "rust-machete"]

# =============================================================================
# TAS-73: Test Infrastructure Levels
# =============================================================================
# Feature flags control which tests compile:
#   test-messaging  â†’ DB + messaging (crate-level + integration tests)
#   test-services   â†’ + running services (E2E tests)
#   test-cluster    â†’ + multi-instance cluster (LOCAL ONLY - not in CI)
#
# See docs/ticket-specs/TAS-73/test-feature-flags-design.md for details.
# =============================================================================

[tasks.test-rust]
description = "Run Rust tests (requires DB + messaging + services)"
script = '''
#!/bin/bash
set -a
source .env 2>/dev/null || true
set +a
cargo nextest run --workspace --features test-services
'''

[tasks.test-rust-unit]
description = "Run unit tests only (requires DB + messaging, no services)"
script = '''
#!/bin/bash
set -a
source .env 2>/dev/null || true
set +a
cargo nextest run --workspace --features test-messaging \
  -E 'not binary(e2e_tests)'
'''

[tasks.test-rust-e2e]
description = "Run E2E tests (requires services running)"
script = '''
#!/bin/bash
set -a
source .env
set +a
echo "ğŸ“‹ Loaded environment: TASKER_FIXTURE_PATH=$TASKER_FIXTURE_PATH"
cargo nextest run --workspace --features test-services \
  -E 'binary(e2e_tests) | binary(integration_tests)'
'''

[tasks.test-rust-cluster]
description = "Run cluster tests (requires: cargo make cluster-start)"
script = '''
#!/bin/bash
set -a
source .env 2>/dev/null || true
set +a
echo "âš ï¸  Cluster tests require: cargo make cluster-start"
echo "âš ï¸  These tests are NOT run in CI due to resource constraints"
cargo nextest run --workspace --features test-cluster \
  -E 'test(multi_instance)'
'''

[tasks.test-rust-all]
description = "Run ALL tests including cluster (local development only)"
script = '''
#!/bin/bash
# Source .env and export all variables for child processes (nextest)
# Using set -a ensures all variables are auto-exported
set -a
[ -f .env ] && source .env
set +a

echo "ğŸš€ Running ALL tests (including cluster tests)"
echo "âš ï¸  Ensure cluster is running: cargo make cluster-start"
echo "   Orchestration URLs: ${TASKER_TEST_ORCHESTRATION_URLS:-default (single instance)}"
echo "   Worker URLs: ${TASKER_TEST_WORKER_URLS:-default (single instance)}"

# Run nextest with explicitly exported environment
exec cargo nextest run --workspace --all-features
'''

[tasks.test-rust-verbose]
description = "Run Rust tests with output"
script = '''
cargo nextest run --features test-services --no-capture
'''

# Test shortcuts
[tasks.t]
alias = "test-rust"
description = "Shortcut for test-rust"

[tasks.tu]
alias = "test-rust-unit"
description = "Shortcut for test-rust-unit"

[tasks.te]
alias = "test-rust-e2e"
description = "Shortcut for test-rust-e2e"

[tasks.tc]
alias = "test-rust-cluster"
description = "Shortcut for test-rust-cluster"

[tasks.fix-rust]
description = "Fix Rust formatting and clippy issues"
dependencies = ["rust-fmt-fix", "rust-clippy-fix"]

[tasks.build-rust]
description = "Build all Rust crates (auto-detects split-db mode)"
script = { file = "${SCRIPTS_DIR}/build-rust.sh" }

[tasks.build-rust-release]
description = "Build all Rust crates (release)"
command = "cargo"
args = ["build", "--all-features", "--release"]

# --- Rust Sub-Tasks ---

[tasks.rust-fmt-check]
description = "Check Rust formatting"
command = "cargo"
args = ["fmt", "--all", "--", "--check"]

[tasks.rust-fmt-fix]
description = "Fix Rust formatting"
command = "cargo"
args = ["fmt", "--all"]

[tasks.rust-clippy]
description = "Run Clippy lints"
command = "cargo"
args = ["clippy", "--all-targets", "--all-features", "--", "-D", "warnings"]

[tasks.rust-clippy-fix]
description = "Fix Clippy issues"
command = "cargo"
args = [
  "clippy",
  "--all-targets",
  "--all-features",
  "--fix",
  "--allow-dirty",
  "--allow-staged"
]

[tasks.rust-docs]
description = "Check documentation builds"
command = "cargo"
args = ["doc", "--no-deps", "--document-private-items"]

[tasks.rust-audit]
description = "Run security audit"
command = "cargo"
args = ["audit"]

[tasks.rust-bench-check]
description = "Check benchmarks compile"
command = "cargo"
args = ["check", "--benches", "--features", "benchmarks"]

[tasks.rust-doctests]
description = "Run documentation tests"
command = "cargo"
args = ["test", "--doc", "--workspace", "--all-features"]

[tasks.rust-machete]
description = "Check for unused Cargo dependencies"
command = "cargo"
args = ["machete", "--with-metadata"]

# =============================================================================
# Python Worker Tasks
# =============================================================================

[tasks.check-python]
description = "Run Python worker quality checks"
cwd = "workers/python"
command = "cargo"
args = ["make", "check"]

[tasks.test-python]
description = "Run Python worker tests"
cwd = "workers/python"
command = "cargo"
args = ["make", "test"]

[tasks.fix-python]
description = "Fix Python worker issues"
cwd = "workers/python"
command = "cargo"
args = ["make", "fix"]

[tasks.build-python]
description = "Build Python worker (auto-detects split-db mode)"
script = '''
#!/bin/bash
set -euo pipefail
source "cargo-make/scripts/split-db-env.sh"
cd workers/python && cargo make build
'''

# =============================================================================
# Ruby Worker Tasks
# =============================================================================

[tasks.check-ruby]
description = "Run Ruby worker quality checks"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "check"]

[tasks.test-ruby]
description = "Run Ruby worker tests"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "test"]

[tasks.fix-ruby]
description = "Fix Ruby worker issues"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "fix"]

[tasks.build-ruby]
description = "Build Ruby worker (auto-detects split-db mode)"
script = '''
#!/bin/bash
set -euo pipefail
source "cargo-make/scripts/split-db-env.sh"
cd workers/ruby && cargo make build
'''

# =============================================================================
# TypeScript Worker Tasks
# =============================================================================

[tasks.check-typescript]
description = "Run TypeScript worker quality checks"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "check"]

[tasks.test-typescript]
description = "Run TypeScript worker tests"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "test"]

[tasks.fix-typescript]
description = "Fix TypeScript worker issues"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "fix"]

[tasks.build-typescript]
description = "Build TypeScript worker (auto-detects split-db mode)"
script = '''
#!/bin/bash
set -euo pipefail
source "cargo-make/scripts/split-db-env.sh"
cd workers/typescript && cargo make build
'''

[tasks.test-typescript-ffi]
description = "Run TypeScript FFI integration tests (all runtimes)"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "test-ffi-all"]

# =============================================================================
# Rust Worker Tasks
# =============================================================================

[tasks.check-rust-worker]
description = "Run Rust worker quality checks"
cwd = "workers/rust"
command = "cargo"
args = ["make", "check"]

[tasks.test-rust-worker]
description = "Run Rust worker tests"
cwd = "workers/rust"
command = "cargo"
args = ["make", "test"]

[tasks.build-rust-worker]
description = "Build Rust worker"
cwd = "workers/rust"
command = "cargo"
args = ["make", "build"]

# =============================================================================
# FFI Integration Test Tasks
# =============================================================================

[tasks.test-python-ffi]
description = "Run Python FFI integration tests"
cwd = "workers/python"
command = "cargo"
args = ["make", "test-ffi"]

[tasks.test-ruby-ffi]
description = "Run Ruby FFI integration tests"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "test-ffi"]

# =============================================================================
# Environment Setup Tasks
# =============================================================================

[tasks.setup-env]
description = "Generate .env file for root (standard test mode)"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=root --mode=test
'''

[tasks.setup-env-split]
description = "Generate .env file for root (split database mode)"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=root --mode=test-split
'''

[tasks.setup-env-orchestration]
description = "Generate .env file for orchestration service"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=orchestration --mode=test
'''

[tasks.setup-env-rust-worker]
description = "Generate .env file for Rust worker"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=rust-worker --mode=test
'''

[tasks.setup-env-ruby-worker]
description = "Generate .env file for Ruby worker"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=ruby-worker --mode=test
'''

[tasks.setup-env-python-worker]
description = "Generate .env file for Python worker"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=python-worker --mode=test
'''

[tasks.setup-env-typescript-worker]
description = "Generate .env file for TypeScript worker"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=typescript-worker --mode=test
'''

[tasks.setup-env-all]
description = "Generate .env files for all targets"
dependencies = [
  "setup-env",
  "setup-env-orchestration",
  "setup-env-rust-worker",
  "setup-env-ruby-worker",
  "setup-env-python-worker",
  "setup-env-typescript-worker",
]

[tasks.setup-env-all-split]
description = "Generate .env files for all targets (split database mode)"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=root --mode=test-split
${SCRIPTS_DIR}/setup-env.sh --target=orchestration --mode=test-split
${SCRIPTS_DIR}/setup-env.sh --target=rust-worker --mode=test-split
${SCRIPTS_DIR}/setup-env.sh --target=ruby-worker --mode=test-split
${SCRIPTS_DIR}/setup-env.sh --target=python-worker --mode=test-split
${SCRIPTS_DIR}/setup-env.sh --target=typescript-worker --mode=test-split
'''

# TAS-73: Cluster Environment Setup
[tasks.setup-env-cluster]
description = "Generate root .env with cluster configuration"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=root --mode=test-cluster
'''

[tasks.setup-env-cluster-split]
description = "Generate root .env with cluster + split database configuration"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=root --mode=test-cluster-split
'''

[tasks.setup-env-all-cluster]
description = "Generate .env files for all targets (cluster mode)"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=root --mode=test-cluster
${SCRIPTS_DIR}/setup-env.sh --target=orchestration --mode=test-cluster
${SCRIPTS_DIR}/setup-env.sh --target=rust-worker --mode=test-cluster
${SCRIPTS_DIR}/setup-env.sh --target=ruby-worker --mode=test-cluster
${SCRIPTS_DIR}/setup-env.sh --target=python-worker --mode=test-cluster
${SCRIPTS_DIR}/setup-env.sh --target=typescript-worker --mode=test-cluster
'''

[tasks.setup-env-all-cluster-split]
description = "Generate .env files for all targets (cluster + split database mode)"
script = '''
${SCRIPTS_DIR}/setup-env.sh --target=root --mode=test-cluster-split
${SCRIPTS_DIR}/setup-env.sh --target=orchestration --mode=test-cluster-split
${SCRIPTS_DIR}/setup-env.sh --target=rust-worker --mode=test-cluster-split
${SCRIPTS_DIR}/setup-env.sh --target=ruby-worker --mode=test-cluster-split
${SCRIPTS_DIR}/setup-env.sh --target=python-worker --mode=test-cluster-split
${SCRIPTS_DIR}/setup-env.sh --target=typescript-worker --mode=test-cluster-split
'''

# =============================================================================
# Database & Infrastructure Tasks
# =============================================================================

[tasks.db-setup]
description = "Setup database with migrations"
dependencies = ["db-check", "db-migrate"]

[tasks.db-check]
description = "Check database connectivity"
script = { file = "${SCRIPTS_DIR}/check-db.sh" }

[tasks.db-migrate]
description = "Run database migrations"
script = { file = "${SCRIPTS_DIR}/run-migrations.sh" }

[tasks.db-reset]
description = "Reset database (drop and recreate)"
script = { file = "${SCRIPTS_DIR}/reset-db.sh" }

# TAS-78: Split Database Mode Tasks
[tasks.db-migrate-split]
description = "Run migrations in split database mode (requires PGMQ_DATABASE_URL)"
script = { file = "${SCRIPTS_DIR}/migrate-db-split.sh" }

[tasks.db-setup-split]
description = "Setup split databases with migrations (requires PGMQ_DATABASE_URL)"
dependencies = ["db-check-split", "db-migrate-split"]

[tasks.db-check-split]
description = "Check connectivity to both Tasker and PGMQ databases"
script = { file = "${SCRIPTS_DIR}/check-db-split.sh" }

# =============================================================================
# SQLX Cache Tasks
# =============================================================================

[tasks.sqlx-prepare]
description = "Prepare SQLX query cache for offline compilation"
script = { file = "${SCRIPTS_DIR}/sqlx-prepare.sh" }

[tasks.sqlx-check]
description = "Verify SQLX cache is up to date"
script = '''
echo "ğŸ” Checking SQLX cache..."
SQLX_OFFLINE=true cargo check --all-features
echo "âœ“ SQLX cache is valid"
'''

# =============================================================================
# Docker Tasks
# =============================================================================

[tasks.docker-up]
description = "Start Docker services (auto-detects split mode if PGMQ_DATABASE_URL set)"
script = { file = "${SCRIPTS_DIR}/docker-up.sh" }

[tasks.docker-down]
description = "Stop Docker services (auto-detects split mode)"
script = { file = "${SCRIPTS_DIR}/docker-down.sh" }

[tasks.docker-logs]
description = "Show Docker logs (auto-detects split mode)"
script = '''
#!/bin/bash
set -euo pipefail
source "cargo-make/scripts/docker-env.sh"
if [ -n "${PGMQ_DATABASE_URL:-}" ] && [ "${PGMQ_DATABASE_URL}" != "${DATABASE_URL:-}" ]; then
    $COMPOSE_CMD -f docker/docker-compose.dual-pg.test.yml logs -f
else
    $COMPOSE_CMD logs -f
fi
'''

# Split-database specific Docker tasks (TAS-78)
[tasks.docker-up-split]
description = "Start dual-database Docker setup for TAS-78 testing"
script = { file = "${SCRIPTS_DIR}/docker-up-split.sh" }

[tasks.docker-down-split]
description = "Stop dual-database Docker setup"
script = '''
#!/bin/bash
set -euo pipefail
source "cargo-make/scripts/docker-env.sh"
$COMPOSE_CMD -f docker/docker-compose.dual-pg.test.yml down
'''

[tasks.docker-down-split-volumes]
description = "Stop dual-database Docker setup and remove volumes (clean slate)"
script = '''
#!/bin/bash
set -euo pipefail
source "cargo-make/scripts/docker-env.sh"
$COMPOSE_CMD -f docker/docker-compose.dual-pg.test.yml down -v
'''

# =============================================================================
# Clean Tasks
# =============================================================================

[tasks.clean]
description = "Clean all build artifacts"
dependencies = ["clean-rust", "clean-workers"]

[tasks.clean-rust]
description = "Clean Rust build artifacts"
command = "cargo"
args = ["clean"]

[tasks.clean-workers]
description = "Clean all worker build artifacts"
script = { file = "${SCRIPTS_DIR}/clean-workers.sh" }

# =============================================================================
# CI Tasks (for GitHub Actions)
# =============================================================================

[tasks.ci-check]
description = "CI: Run all quality checks"
dependencies = ["rust-fmt-check", "rust-clippy", "rust-docs", "rust-audit"]

[tasks.ci-test]
description = "CI: Run all tests"
script = '''
cargo nextest run --all-features --profile ci
'''

[tasks.ci-prepare]
description = "CI: Prepare for offline builds"
dependencies = ["sqlx-prepare"]

# =============================================================================
# Development Convenience Tasks
# =============================================================================

[tasks.setup]
description = "Full development setup (auto-detects split mode)"
dependencies = ["docker-up", "db-setup", "setup-workers"]

[tasks.setup-split]
description = "Full development setup for split-database mode (TAS-78)"
script = { file = "${SCRIPTS_DIR}/setup-split.sh" }

[tasks.setup-workers]
description = "Setup all workers"
script = { file = "${SCRIPTS_DIR}/setup-workers.sh" }

[tasks.watch]
description = "Watch for changes and run tests"
script = '''
cargo watch -x "nextest run --all-features"
'''

[tasks.watch-check]
description = "Watch for changes and run checks"
script = '''
cargo watch -x "clippy --all-targets --all-features"
'''

# =============================================================================
# Quick Shortcuts
# =============================================================================
# Note: t, tu, te, tc shortcuts defined in TAS-73 Test Infrastructure section

[tasks.c]
description = "Alias for check"
alias = "check"

[tasks.f]
description = "Alias for fix"
alias = "fix"

[tasks.b]
description = "Alias for build"
alias = "build"

# =============================================================================
# Service Management Tasks
# =============================================================================
# Local service execution for E2E testing without Docker containers.
# Each service runs as a background process with PID tracking in .pids/
#
# Port Mapping:
#   Orchestration: 8080
#   Rust Worker:   8081
#   Ruby Worker:   8082
#   Python Worker: 8083
#   TypeScript Worker: 8085
#
# Usage:
#   cargo make services-start      # Start all services
#   cargo make services-stop       # Stop all services
#   cargo make services-status     # Check all services status
#   cargo make services-logs-clear # Clear all log files
#   cargo make run-orchestration   # Start orchestration service
#   cargo make run-worker-python   # Start Python worker
#
# Prerequisites:
#   - PostgreSQL running (via docker-compose or locally)
#   - Run 'cargo make build' first to build all services

[tasks.services-status]
description = "Check status of all local services"
script = '''
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-status.sh --all
'''

[tasks.services-start]
description = "Start all services (orchestration + all workers)"
script = { file = "${SCRIPTS_DIR}/services-start-all.sh" }

[tasks.services-start-release]
description = "Start services in release mode (orchestration + Rust worker only)"
script = '''
#!/bin/bash
set -euo pipefail

echo "ğŸš€ Starting Tasker services (RELEASE mode)..."
echo "   This starts orchestration + Rust worker for benchmarking."
echo "   For FFI workers, use run-worker-{ruby,python,typescript} separately."
echo ""

# Build release first (if not already built)
echo "=== Building Release ==="
cargo build --release -p tasker-orchestration -p tasker-worker-rust
echo ""

# Start orchestration
echo "=== Starting Orchestration (Release) ==="
cargo make run-orchestration-release
echo ""

# Start Rust worker
echo "=== Starting Rust Worker (Release) ==="
cargo make run-worker-rust-release

echo ""
echo "Waiting for services to initialize..."
sleep 5

echo ""
cargo make services-status
'''

[tasks.services-stop-release]
description = "Stop release mode services"
alias = "services-stop"

[tasks.services-logs-clear]
description = "Clear all service log files"
script = '''
LOG_DIR=".logs"
if [ -d "$LOG_DIR" ]; then
    echo "ğŸ§¹ Clearing service logs..."
    rm -f "$LOG_DIR"/*.log
    echo "âœ… Logs cleared"
else
    echo "No log directory found at $LOG_DIR"
fi
'''

[tasks.services-stop]
description = "Stop all running services"
script = { file = "${SCRIPTS_DIR}/services-stop-all.sh" }

[tasks.services-health-check]
description = "Check health endpoints of all running services"
script = { file = "${SCRIPTS_DIR}/services-health-check.sh" }

# --- Orchestration Service ---

[tasks.run-orchestration]
description = "Run orchestration service (port 8080)"
script = { file = "${SCRIPTS_DIR}/run-orchestration.sh" }

[tasks.run-orchestration-release]
description = "Run orchestration service in release mode (port 8080)"
script = '''
#!/bin/bash
set -euo pipefail
source .env 2>/dev/null || true

# TAS-78: Enable SQLX_OFFLINE in split-database mode
if [ -n "${PGMQ_DATABASE_URL:-}" ] && [ "${PGMQ_DATABASE_URL}" != "${DATABASE_URL:-}" ]; then
    echo "ğŸ”€ Split database mode - using SQLX_OFFLINE=true"
    export SQLX_OFFLINE=true
fi

export TASKER_ENV="${TASKER_ENV:-test}"
export PORT="${PORT:-8080}"
# For benchmarking, use ALL benchmark templates (override .env if set)
# The parent directory contains rust/, ruby/, python/, typescript/ subdirectories
export TASKER_CONFIG_PATH="$(pwd)/config/tasker/generated/orchestration-test.toml"
export TASKER_TEMPLATE_PATH="$(pwd)/tests/fixtures/task_templates"

echo "ğŸš€ Starting orchestration service (RELEASE mode)..."
echo "   Port: ${PORT}"
echo "   Config: ${TASKER_CONFIG_PATH}"
echo "   Templates: ${TASKER_TEMPLATE_PATH}"

PROJECT_ROOT="$(pwd)" "${SCRIPTS_DIR}/service-start.sh" orchestration \
    cargo run --release -p tasker-orchestration --bin tasker-server
'''

[tasks.stop-orchestration]
description = "Stop orchestration service"
script = '''
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-stop.sh orchestration
'''

[tasks.status-orchestration]
description = "Check orchestration service status"
script = '''
PROJECT_ROOT="$(pwd)" ${SCRIPTS_DIR}/service-status.sh orchestration
'''

[tasks.logs-orchestration]
description = "Tail orchestration service logs"
script = '''
LOG_FILE=".logs/orchestration.log"
if [ -f "$LOG_FILE" ]; then
    tail -f "$LOG_FILE"
else
    echo "No log file found at $LOG_FILE"
    echo "Start the service first with: cargo make run-orchestration"
fi
'''

# --- Rust Worker ---

[tasks.run-worker-rust]
description = "Run Rust worker service (port 8081)"
cwd = "workers/rust"
command = "cargo"
args = ["make", "run"]

[tasks.run-worker-rust-release]
description = "Run Rust worker service in release mode (port 8081)"
script = '''
#!/bin/bash
set -euo pipefail
source .env 2>/dev/null || true

# TAS-78: Enable SQLX_OFFLINE in split-database mode
if [ -n "${PGMQ_DATABASE_URL:-}" ] && [ "${PGMQ_DATABASE_URL}" != "${DATABASE_URL:-}" ]; then
    echo "ğŸ”€ Split database mode - using SQLX_OFFLINE=true"
    export SQLX_OFFLINE=true
fi

export TASKER_ENV="${TASKER_ENV:-test}"
export PORT="${PORT:-8081}"
# TAS-159: Rust worker uses ONLY Rust templates (to avoid subscribing to other language queues)
# Orchestration loads ALL templates for task creation, but workers are language-specific
export TASKER_CONFIG_PATH="$(pwd)/config/tasker/generated/worker-test.toml"
export TASKER_TEMPLATE_PATH="$(pwd)/tests/fixtures/task_templates/rust"
export TASKER_WEB_BIND_ADDRESS="0.0.0.0:${PORT}"

echo "ğŸš€ Starting Rust worker (RELEASE mode)..."
echo "   Port: ${PORT}"
echo "   Config: ${TASKER_CONFIG_PATH}"
echo "   Templates: ${TASKER_TEMPLATE_PATH}"

PROJECT_ROOT="$(pwd)" "${SCRIPTS_DIR}/service-start.sh" rust-worker \
    cargo run --release -p tasker-worker-rust
'''

[tasks.stop-worker-rust]
description = "Stop Rust worker service"
cwd = "workers/rust"
command = "cargo"
args = ["make", "stop"]

[tasks.status-worker-rust]
description = "Check Rust worker status"
cwd = "workers/rust"
command = "cargo"
args = ["make", "status"]

# --- Ruby Worker ---

[tasks.run-worker-ruby]
description = "Run Ruby worker service (port 8082)"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "run"]

[tasks.stop-worker-ruby]
description = "Stop Ruby worker service"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "stop"]

[tasks.status-worker-ruby]
description = "Check Ruby worker status"
cwd = "workers/ruby"
command = "cargo"
args = ["make", "status"]

# --- Python Worker ---

[tasks.run-worker-python]
description = "Run Python worker service (port 8083)"
cwd = "workers/python"
command = "cargo"
args = ["make", "run"]

[tasks.stop-worker-python]
description = "Stop Python worker service"
cwd = "workers/python"
command = "cargo"
args = ["make", "stop"]

[tasks.status-worker-python]
description = "Check Python worker status"
cwd = "workers/python"
command = "cargo"
args = ["make", "status"]

# --- TypeScript Worker ---

[tasks.run-worker-typescript]
description = "Run TypeScript worker service (port 8085)"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "run"]

[tasks.stop-worker-typescript]
description = "Stop TypeScript worker service"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "stop"]

[tasks.status-worker-typescript]
description = "Check TypeScript worker status"
cwd = "workers/typescript"
command = "cargo"
args = ["make", "status"]

# =============================================================================
# TAS-73: Multi-Instance Cluster Tasks
# =============================================================================
# Run multiple instances of orchestration/workers for horizontal scaling tests.
#
# Port Allocation (multi-instance mode):
#   Orchestration:  8080-8089 (up to 10 instances)
#   Rust Workers:   8100-8109
#   Ruby Workers:   8200-8209
#   Python Workers: 8300-8309
#   TS Workers:     8400-8409
#
# Usage:
#   cargo make cluster-start              # Start default cluster (orchestration + rust workers)
#   cargo make cluster-start-all          # Start cluster with all worker types
#   cargo make cluster-stop               # Stop all cluster instances
#   cargo make cluster-status             # Check all instance health
#   cargo make cluster-start-orchestration # Start orchestration instances only
#   cargo make cluster-start-workers      # Start rust worker instances only
#   cargo make cluster-start-workers-all  # Start all configured worker types
#
# Environment Variables (set via cluster.env or exported):
#   TASKER_ORCHESTRATION_INSTANCES   - Number of orchestration instances (default: 2)
#   TASKER_WORKER_RUST_INSTANCES     - Number of rust worker instances (default: 2)
#   TASKER_WORKER_RUBY_INSTANCES     - Number of ruby worker instances (default: 2)
#   TASKER_WORKER_PYTHON_INSTANCES   - Number of python worker instances (default: 2)
#   TASKER_WORKER_TS_INSTANCES       - Number of typescript worker instances (default: 2)
#
# See: docs/ticket-specs/TAS-73/multi-instance-deployment.md

[tasks.cluster-start]
description = "Start full multi-instance cluster (orchestration + workers)"
dependencies = ["cluster-start-orchestration", "cluster-start-workers"]
script = '''
echo ""
echo "â³ Waiting for cluster to initialize..."
sleep 5
cargo make cluster-status
'''

[tasks.cluster-start-orchestration]
description = "Start N orchestration instances"
script = '''
COUNT="${TASKER_ORCHESTRATION_INSTANCES:-2}"
echo "ğŸš€ Starting $COUNT orchestration instance(s)..."
bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" orchestration "$COUNT"
'''

[tasks.cluster-start-workers]
description = "Start N rust worker instances (default cluster workers)"
script = '''
RUST_COUNT="${TASKER_WORKER_RUST_INSTANCES:-2}"
echo "ğŸš€ Starting $RUST_COUNT rust worker instance(s)..."
bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" worker-rust "$RUST_COUNT"
'''

[tasks.cluster-start-workers-all]
description = "Start worker instances of all configured types"
script = '''
# Default to 2 instances for all worker types (matches individual task defaults)
RUST_COUNT="${TASKER_WORKER_RUST_INSTANCES:-2}"
RUBY_COUNT="${TASKER_WORKER_RUBY_INSTANCES:-2}"
PYTHON_COUNT="${TASKER_WORKER_PYTHON_INSTANCES:-2}"
TS_COUNT="${TASKER_WORKER_TS_INSTANCES:-2}"

if [ "$RUST_COUNT" -gt 0 ]; then
    echo "ğŸš€ Starting $RUST_COUNT rust worker instance(s)..."
    bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" worker-rust "$RUST_COUNT"
fi

if [ "$RUBY_COUNT" -gt 0 ]; then
    echo "ğŸ’ Starting $RUBY_COUNT ruby worker instance(s)..."
    bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" worker-ruby "$RUBY_COUNT"
fi

if [ "$PYTHON_COUNT" -gt 0 ]; then
    echo "ğŸ Starting $PYTHON_COUNT python worker instance(s)..."
    bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" worker-python "$PYTHON_COUNT"
fi

if [ "$TS_COUNT" -gt 0 ]; then
    echo "ğŸ“˜ Starting $TS_COUNT typescript worker instance(s)..."
    bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" worker-ts "$TS_COUNT"
fi
'''

[tasks.cluster-start-workers-rust]
description = "Start N rust worker instances"
script = '''
COUNT="${TASKER_WORKER_RUST_INSTANCES:-2}"
echo "ğŸš€ Starting $COUNT rust worker instance(s)..."
bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" worker-rust "$COUNT"
'''

[tasks.cluster-start-workers-ruby]
description = "Start N ruby worker instances"
script = '''
COUNT="${TASKER_WORKER_RUBY_INSTANCES:-2}"
echo "ğŸ’ Starting $COUNT ruby worker instance(s)..."
bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" worker-ruby "$COUNT"
'''

[tasks.cluster-start-workers-python]
description = "Start N python worker instances"
script = '''
COUNT="${TASKER_WORKER_PYTHON_INSTANCES:-2}"
echo "ğŸ Starting $COUNT python worker instance(s)..."
bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" worker-python "$COUNT"
'''

[tasks.cluster-start-workers-ts]
description = "Start N typescript worker instances"
script = '''
COUNT="${TASKER_WORKER_TS_INSTANCES:-2}"
echo "ğŸ“˜ Starting $COUNT typescript worker instance(s)..."
bash "${SCRIPTS_DIR}/multi-deploy/start-cluster.sh" worker-ts "$COUNT"
'''

[tasks.cluster-start-all]
description = "Start full multi-instance cluster with all worker types"
dependencies = ["cluster-start-orchestration", "cluster-start-workers-all"]
script = '''
echo ""
echo "â³ Waiting for cluster to initialize..."
sleep 5
cargo make cluster-status
'''

[tasks.cluster-stop]
description = "Stop all cluster instances"
script = '''
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh"
'''

[tasks.cluster-stop-orchestration]
description = "Stop orchestration instances only"
script = '''
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh" orchestration
'''

[tasks.cluster-stop-workers]
description = "Stop all worker instances"
script = '''
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh" worker-rust
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh" worker-ruby
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh" worker-python
bash "${SCRIPTS_DIR}/multi-deploy/stop-cluster.sh" worker-ts
'''

[tasks.cluster-status]
description = "Check status and health of all cluster instances"
script = '''
bash "${SCRIPTS_DIR}/multi-deploy/cluster-status.sh"
'''

[tasks.cluster-status-quick]
description = "Check status of cluster instances (no health checks)"
script = '''
bash "${SCRIPTS_DIR}/multi-deploy/cluster-status.sh" --no-health
'''

[tasks.cluster-logs]
description = "Tail logs from all cluster instances"
script = '''
if ls .logs/orchestration-*.log .logs/worker-*.log 1>/dev/null 2>&1; then
    tail -f .logs/orchestration-*.log .logs/worker-*.log
else
    echo "No cluster logs found. Start cluster first with: cargo make cluster-start"
fi
'''

[tasks.cluster-logs-orchestration]
description = "Tail logs from orchestration instances only"
script = '''
if ls .logs/orchestration-*.log 1>/dev/null 2>&1; then
    tail -f .logs/orchestration-*.log
else
    echo "No orchestration logs found. Start cluster first with: cargo make cluster-start-orchestration"
fi
'''

# =============================================================================
# TAS-158: tokio-console Profiling Tasks
# =============================================================================
# Runtime introspection with tokio-console for debugging async behavior.
#
# Prerequisites:
#   1. Install tokio-console: cargo install tokio-console
#   2. Build with console support: cargo make build-console
#   3. Run the service (in one terminal): cargo make run-console-orchestration
#   4. Connect tokio-console (in another terminal): tokio-console
#
# Note: These builds use RUSTFLAGS="--cfg tokio_unstable" which requires
# recompilation of tokio and dependencies. Build times will be longer than
# standard builds. This is opt-in rather than default to avoid impacting
# normal development workflows.
#
# See: docs/ticket-specs/TAS-71/tokio-analysis.md

[tasks.build-console]
description = "Build all crates with tokio-console support (TAS-158)"
env = { RUSTFLAGS = "--cfg tokio_unstable" }
script = '''
#!/bin/bash
set -euo pipefail
echo "ğŸ” Building with tokio-console support..."
echo "   RUSTFLAGS=$RUSTFLAGS"
echo "   Features: tokio-console"
echo ""
echo "âš ï¸  This requires recompilation of tokio with unstable features."
echo "   Build will take longer than normal."
echo ""

# Build orchestration and Rust worker with tokio-console feature
# Note: tasker-worker is a library crate (embedded by language workers), not standalone
cargo build --package tasker-orchestration --features tokio-console
cargo build --package tasker-worker-rust --features tokio-console

echo ""
echo "âœ… Build complete. Run services with:"
echo "   cargo make run-console-orchestration   (rco)"
echo "   cargo make run-console-worker-rust     (rcwr)"
echo ""
echo "Then connect tokio-console in another terminal:"
echo "   cargo make console"
'''

[tasks.build-console-release]
description = "Build release with tokio-console support"
env = { RUSTFLAGS = "--cfg tokio_unstable" }
script = '''
#!/bin/bash
set -euo pipefail
cargo build --package tasker-orchestration --features tokio-console --release
cargo build --package tasker-worker --features tokio-console --release
'''

[tasks.run-console-orchestration]
description = "Run orchestration with tokio-console (port 8080)"
env = { RUSTFLAGS = "--cfg tokio_unstable" }
script = '''
#!/bin/bash
set -euo pipefail
source .env 2>/dev/null || true

echo "ğŸ” Starting orchestration with tokio-console support..."
echo "   Connect with: tokio-console (in another terminal)"
echo ""

# Run with tokio-console feature enabled
RUSTFLAGS="--cfg tokio_unstable" cargo run \
    --package tasker-orchestration \
    --features tokio-console \
    --bin tasker-server
'''

[tasks.run-console-worker-rust]
description = "Run Rust worker with tokio-console (port 8081)"
env = { RUSTFLAGS = "--cfg tokio_unstable" }
script = '''
#!/bin/bash
set -euo pipefail
source .env 2>/dev/null || true

echo "ğŸ” Starting Rust worker with tokio-console support..."
echo "   Connect with: tokio-console (in another terminal)"
echo ""

# Build and run the Rust worker with tokio-console feature
cd workers/rust
RUSTFLAGS="--cfg tokio_unstable" cargo run --features tokio-console
'''

[tasks.console]
description = "Open tokio-console (must have service running with console support)"
script = '''
#!/bin/bash
if ! command -v tokio-console &> /dev/null; then
    echo "âŒ tokio-console not found"
    echo ""
    echo "Install with: cargo install tokio-console"
    exit 1
fi

echo "ğŸ” Connecting to tokio-console..."
echo "   Make sure a service is running with: cargo make run-console-orchestration"
echo ""
tokio-console
'''

# Shortcuts for console tasks
[tasks.bc]
alias = "build-console"
description = "Shortcut for build-console"

[tasks.rco]
alias = "run-console-orchestration"
description = "Shortcut for run-console-orchestration"

[tasks.rcw]
alias = "run-console-worker-rust"
description = "Shortcut for run-console-worker-rust"

# =============================================================================
# TAS-161: samply CPU Profiling Tasks
# =============================================================================
# CPU profiling with samply for flamegraph analysis and hot path identification.
#
# Prerequisites:
#   1. Install samply: cargo install samply
#   2. Build with profiling symbols: cargo make build-profiling
#   3. Start worker (normal mode): cargo make run-worker-rust-release
#   4. Run orchestration under samply (foreground): cargo make run-samply-orchestration
#   5. Generate load (in another terminal): cargo make bench-e2e
#   6. Press Ctrl-C to stop samply and open Firefox Profiler
#
# The profiling profile includes:
#   - Release-level optimizations (lto, codegen-units=1)
#   - Debug symbols (debug=true, strip=false)
#   - Stack unwinding (panic=unwind instead of abort)
#
# See: docs/ticket-specs/TAS-71/TAS-161-profiling.md

[tasks.build-profiling]
description = "Build with profiling profile (release + debug symbols)"
script = '''
#!/bin/bash
set -euo pipefail

echo "ğŸ” Building with profiling profile..."
echo "   Profile: profiling (release optimizations + debug symbols)"
echo ""

cargo build --profile profiling -p tasker-orchestration -p tasker-worker-rust

echo ""
echo "âœ… Build complete. Binaries at:"
echo "   target/profiling/tasker-server"
echo "   target/profiling/rust-worker"
echo ""
echo "Run with samply:"
echo "   cargo make run-samply-orchestration   (rso)"
echo "   cargo make run-samply-worker-rust     (rswr)"
'''

[tasks.build-profiling-orchestration]
description = "Build orchestration with profiling profile"
command = "cargo"
args = ["build", "--profile", "profiling", "-p", "tasker-orchestration"]

[tasks.build-profiling-worker-rust]
description = "Build Rust worker with profiling profile"
command = "cargo"
args = ["build", "--profile", "profiling", "-p", "tasker-worker-rust"]

[tasks.run-samply-orchestration]
description = "Run orchestration under samply (foreground, Ctrl-C to profile)"
script = '''
#!/bin/bash
set -euo pipefail

# Check samply is installed
if ! command -v samply &> /dev/null; then
    echo "âŒ samply not found"
    echo ""
    echo "Install with: cargo install samply"
    exit 1
fi

# Source environment
set -a
source .env 2>/dev/null || true
set +a

# TAS-78: Enable SQLX_OFFLINE in split-database mode
if [ -n "${PGMQ_DATABASE_URL:-}" ] && [ "${PGMQ_DATABASE_URL}" != "${DATABASE_URL:-}" ]; then
    echo "ğŸ”€ Split database mode - using SQLX_OFFLINE=true"
    export SQLX_OFFLINE=true
fi

export TASKER_ENV="${TASKER_ENV:-test}"
export PORT="${PORT:-8080}"
export TASKER_CONFIG_PATH="$(pwd)/config/tasker/generated/orchestration-test.toml"
export TASKER_TEMPLATE_PATH="$(pwd)/tests/fixtures/task_templates"

BINARY="$(pwd)/target/profiling/tasker-server"

if [ ! -f "$BINARY" ]; then
    echo "âŒ Profiling binary not found: $BINARY"
    echo "   Run: cargo make build-profiling"
    exit 1
fi

echo "ğŸ”¬ Starting orchestration under samply..."
echo "   Binary: $BINARY"
echo "   Port: ${PORT}"
echo "   Config: ${TASKER_CONFIG_PATH}"
echo "   Templates: ${TASKER_TEMPLATE_PATH}"
echo ""
echo "ğŸ“ Workflow:"
echo "   1. This runs in foreground - keep this terminal open"
echo "   2. In another terminal: cargo make bench-e2e (or generate other load)"
echo "   3. Press Ctrl-C here when done to stop and view profile"
echo ""

samply record -- "$BINARY"
'''

[tasks.run-samply-worker-rust]
description = "Run Rust worker under samply (foreground, Ctrl-C to profile)"
script = '''
#!/bin/bash
set -euo pipefail

# Check samply is installed
if ! command -v samply &> /dev/null; then
    echo "âŒ samply not found"
    echo ""
    echo "Install with: cargo install samply"
    exit 1
fi

# Source environment
set -a
source .env 2>/dev/null || true
set +a

# TAS-78: Enable SQLX_OFFLINE in split-database mode
if [ -n "${PGMQ_DATABASE_URL:-}" ] && [ "${PGMQ_DATABASE_URL}" != "${DATABASE_URL:-}" ]; then
    echo "ğŸ”€ Split database mode - using SQLX_OFFLINE=true"
    export SQLX_OFFLINE=true
fi

export TASKER_ENV="${TASKER_ENV:-test}"
export PORT="${PORT:-8081}"
# TAS-159: Rust worker uses ONLY Rust templates
export TASKER_CONFIG_PATH="$(pwd)/config/tasker/generated/worker-test.toml"
export TASKER_TEMPLATE_PATH="$(pwd)/tests/fixtures/task_templates/rust"
export TASKER_WEB_BIND_ADDRESS="0.0.0.0:${PORT}"

BINARY="$(pwd)/target/profiling/rust-worker"

if [ ! -f "$BINARY" ]; then
    echo "âŒ Profiling binary not found: $BINARY"
    echo "   Run: cargo make build-profiling"
    exit 1
fi

echo "ğŸ”¬ Starting Rust worker under samply..."
echo "   Binary: $BINARY"
echo "   Port: ${PORT}"
echo "   Config: ${TASKER_CONFIG_PATH}"
echo "   Templates: ${TASKER_TEMPLATE_PATH}"
echo ""
echo "ğŸ“ Workflow:"
echo "   1. This runs in foreground - keep this terminal open"
echo "   2. Start orchestration: cargo make run-orchestration-release"
echo "   3. In another terminal: cargo make bench-e2e (or generate other load)"
echo "   4. Press Ctrl-C here when done to stop and view profile"
echo ""

samply record -- "$BINARY"
'''

[tasks.profile-analyze]
description = "Analyze Firefox Profiler JSON files from samply"
script = '''
#!/bin/bash
set -euo pipefail

PROFILE_DIR="docs/ticket-specs/TAS-71/profile-data"

if [ ! -d "$PROFILE_DIR" ]; then
    echo "âŒ No profile data found at $PROFILE_DIR"
    echo "   Run profiling first with: cargo make rso (then Ctrl-C)"
    exit 1
fi

# Find profile files
PROFILES=($(ls -1 "$PROFILE_DIR"/*.json 2>/dev/null || true))

if [ ${#PROFILES[@]} -eq 0 ]; then
    echo "âŒ No .json profile files found in $PROFILE_DIR"
    exit 1
fi

echo "Found ${#PROFILES[@]} profile(s):"
for p in "${PROFILES[@]}"; do
    echo "  - $(basename "$p")"
done
echo ""

for profile in "${PROFILES[@]}"; do
    echo ""
    python3 cargo-make/scripts/profiling/analyze_profile.py "$profile" --top 30 "$@"
done
'''

[tasks.profile-analyze-tasker]
description = "Analyze profiles filtered for tasker-specific code"
script = '''
#!/bin/bash
set -euo pipefail

PROFILE_DIR="docs/ticket-specs/TAS-71/profile-data"

for profile in "$PROFILE_DIR"/*.json; do
    if [ -f "$profile" ]; then
        echo ""
        python3 cargo-make/scripts/profiling/analyze_profile.py "$profile" --top 30 --filter "tasker"
    fi
done
'''

# Shortcuts for samply profiling tasks
[tasks.bp]
alias = "build-profiling"
description = "Shortcut for build-profiling"

[tasks.rso]
alias = "run-samply-orchestration"
description = "Shortcut for run-samply-orchestration"

[tasks.rswr]
alias = "run-samply-worker-rust"
description = "Shortcut for run-samply-worker-rust"

[tasks.pa]
alias = "profile-analyze"
description = "Shortcut for profile-analyze"

[tasks.pat]
alias = "profile-analyze-tasker"
description = "Shortcut for profile-analyze-tasker"

# =============================================================================
# TAS-159: E2E Benchmark Tasks
# =============================================================================
# Comprehensive end-to-end latency benchmarks across multiple tiers.
#
# Tier Overview:
#   Tier 1 (Core):       Rust native linear/diamond workflows
#   Tier 2 (Complexity): Complex DAG, hierarchical tree, conditional routing
#   Tier 3 (Cluster):    Multi-instance coordination (requires cluster running)
#   Tier 4 (Languages):  FFI comparison (Ruby, Python, TypeScript)
#   Tier 5 (Batch):      CSV batch processing with parallel workers
#
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚ BENCHMARK BASELINE WORKFLOW                                                 â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚                                                                             â”‚
# â”‚ 1. TIER 1 + 2 + 5 (Single-instance, Release Mode):                         â”‚
# â”‚    cargo make services-start-release   # Orchestration + Rust worker       â”‚
# â”‚    cargo make bench-e2e-full           # Tier 1 + 2                         â”‚
# â”‚    cargo make bench-e2e-batch          # Tier 5                             â”‚
# â”‚    cargo make services-stop                                                 â”‚
# â”‚                                                                             â”‚
# â”‚ 2. TIER 3 (Cluster, Already Release Mode):                                  â”‚
# â”‚    cargo make cluster-start-all        # 2x orchestration + all workers    â”‚
# â”‚    cargo make bench-e2e-cluster        # Tier 3                             â”‚
# â”‚    cargo make cluster-stop                                                  â”‚
# â”‚                                                                             â”‚
# â”‚ 3. TIER 4 (FFI Languages):                                                  â”‚
# â”‚    cargo make services-start-release   # Orchestration + Rust worker       â”‚
# â”‚    cargo make run-worker-ruby &        # Port 8082                          â”‚
# â”‚    cargo make run-worker-python &      # Port 8083                          â”‚
# â”‚    cargo make run-worker-typescript &  # Port 8085                          â”‚
# â”‚    cargo make bench-e2e-languages      # Tier 4                             â”‚
# â”‚    cargo make services-stop                                                 â”‚
# â”‚                                                                             â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#
# NOTE: All benchmarks are local-only (not in CI) due to resource constraints.
#
# See: tests/benches/e2e_latency.rs for implementation details.

[tasks.bench-e2e]
description = "Run Tier 1 E2E benchmarks (Rust linear/diamond)"
script = '''
#!/bin/bash
set -euo pipefail
source .env 2>/dev/null || true

echo "ğŸ“Š Running Tier 1: Core Performance Benchmarks"
echo "   Requires: cargo make services-start-release"
echo ""

cargo bench --bench e2e_latency -- "tier1_core"
'''

[tasks.bench-e2e-full]
description = "Run Tier 1 + Tier 2 benchmarks (core + complexity)"
script = '''
#!/bin/bash
set -euo pipefail
source .env 2>/dev/null || true

echo "ğŸ“Š Running Tier 1 + Tier 2: Core + Complexity Benchmarks"
echo "   Requires: cargo make services-start-release"
echo ""

cargo bench --bench e2e_latency -- "tier1_core|tier2_complexity"
'''

[tasks.bench-e2e-cluster]
description = "Run Tier 3 cluster benchmarks (multi-instance)"
script = '''
#!/bin/bash
set -euo pipefail
source .env 2>/dev/null || true

echo "ğŸ“Š Running Tier 3: Cluster Performance Benchmarks"
echo "   Requires: cargo make cluster-start-all"
echo ""

cargo bench --bench e2e_latency -- "tier3_cluster"
'''

[tasks.bench-e2e-languages]
description = "Run Tier 4 language comparison benchmarks (Ruby, Python, TS)"
script = '''
#!/bin/bash
set -euo pipefail
source .env 2>/dev/null || true

echo "ğŸ“Š Running Tier 4: FFI Language Comparison Benchmarks"
echo "   Requires: cargo make services-start-release"
echo "   Optional: cargo make run-worker-ruby"
echo "   Optional: cargo make run-worker-python"
echo "   Optional: cargo make run-worker-typescript"
echo ""
echo "   Note: Unavailable workers will be skipped gracefully"
echo ""

cargo bench --bench e2e_latency -- "tier4_languages"
'''

[tasks.bench-e2e-batch]
description = "Run Tier 5 batch processing benchmarks"
script = '''
#!/bin/bash
set -euo pipefail
source .env 2>/dev/null || true

echo "ğŸ“Š Running Tier 5: Batch Processing Benchmarks"
echo "   Requires: cargo make services-start-release"
echo "   Uses: tests/fixtures/products.csv (1000 rows, 5 workers)"
echo ""

cargo bench --bench e2e_latency -- "tier5_batch"
'''

[tasks.bench-e2e-all]
description = "Run ALL E2E benchmarks (all 5 tiers)"
script = '''
#!/bin/bash
set -euo pipefail
source .env 2>/dev/null || true

echo "ğŸ“Š Running ALL E2E Benchmarks (Tiers 1-5)"
echo ""
echo "Prerequisites:"
echo "   - cargo make services-start-release"
echo "   - cargo make cluster-start-all (for Tier 3)"
echo "   - Language workers optional (Tier 4 skips unavailable)"
echo ""

cargo bench --bench e2e_latency
'''

# Benchmark shortcuts
[tasks.be]
alias = "bench-e2e"
description = "Shortcut for bench-e2e (Tier 1)"

[tasks.bef]
alias = "bench-e2e-full"
description = "Shortcut for bench-e2e-full (Tier 1+2)"

[tasks.bec]
alias = "bench-e2e-cluster"
description = "Shortcut for bench-e2e-cluster (Tier 3)"

[tasks.bel]
alias = "bench-e2e-languages"
description = "Shortcut for bench-e2e-languages (Tier 4)"

[tasks.beb]
alias = "bench-e2e-batch"
description = "Shortcut for bench-e2e-batch (Tier 5)"

[tasks.bea]
alias = "bench-e2e-all"
description = "Shortcut for bench-e2e-all (All tiers)"

[tasks.bench-report]
description = "Generate percentile report from benchmark results"
script = '''
#!/bin/bash
set -euo pipefail

echo "ğŸ“Š Generating Benchmark Percentile Report"
echo ""

if [ ! -d "target/criterion" ]; then
    echo "âŒ No benchmark results found in target/criterion"
    echo "   Run benchmarks first: cargo make bench-e2e-all"
    exit 1
fi

python3 cargo-make/scripts/bench-percentiles.py target/criterion
'''

[tasks.br]
alias = "bench-report"
description = "Shortcut for bench-report"

[tasks.bench-analysis]
description = "Generate benchmark analysis document in ticket-specs"
script = '''
#!/bin/bash
set -euo pipefail

echo "ğŸ“Š Generating Benchmark Analysis Document"
echo ""

if [ ! -f "target/criterion/percentile_report.json" ]; then
    echo "âŒ No percentile report found"
    echo "   Run: cargo make bench-report first"
    exit 1
fi

bash cargo-make/scripts/bench-analysis.sh
'''

[tasks.ba]
alias = "bench-analysis"
description = "Shortcut for bench-analysis"

# =============================================================================
# TAS-150: Auth E2E Testing
# =============================================================================

[tasks.test-auth-e2e]
description = "Run auth-enabled E2E tests (requires DB running)"
script = '''
#!/bin/bash
set -euo pipefail
set -a
source .env 2>/dev/null || true
set +a
export TASKER_CONFIG_PATH="$(pwd)/config/tasker/generated/auth-test.toml"
export TASKER_JWT_PUBLIC_KEY_PATH="$(pwd)/tests/fixtures/auth/jwt-public-key-test.pem"
echo "ğŸ” Running auth enforcement E2E tests"
echo "   Config: $TASKER_CONFIG_PATH"
echo "   Public key: $TASKER_JWT_PUBLIC_KEY_PATH"
cargo nextest run --features test-services \
  -E 'test(auth::)' \
  --package tasker-orchestration
'''

[tasks.tae]
alias = "test-auth-e2e"
description = "Shortcut for test-auth-e2e"

[tasks.auth-generate-test-keys]
description = "Regenerate test RSA key fixtures (optional, keys are committed)"
script = '''
#!/bin/bash
set -euo pipefail
mkdir -p tests/fixtures/auth
openssl genpkey -algorithm RSA -out tests/fixtures/auth/jwt-private-key-test.pem -pkeyopt rsa_keygen_bits:2048 2>/dev/null
openssl rsa -in tests/fixtures/auth/jwt-private-key-test.pem -pubout -out tests/fixtures/auth/jwt-public-key-test.pem 2>/dev/null
echo "Test keys regenerated at tests/fixtures/auth/"
'''

# =============================================================================
# Schema Generation
# =============================================================================

[tasks.generate-schemas]
description = "Generate OpenAPI specs from utoipa annotations"
script = '''
#!/bin/bash
set -euo pipefail
mkdir -p schemas/generated

echo "Generating orchestration OpenAPI spec..."
cargo run --package tasker-orchestration --bin generate-orchestration-openapi --features web-api \
  > schemas/generated/orchestration-openapi.json

echo "Generating worker OpenAPI spec..."
cargo run --package tasker-worker --bin generate-worker-openapi --features web-api \
  > schemas/generated/worker-openapi.json

echo "Schemas generated:"
ls -la schemas/generated/
'''

[tasks.gs]
alias = "generate-schemas"
description = "Shortcut for generate-schemas"

[tasks.check-schemas]
description = "Verify generated schemas are up-to-date (for CI)"
script = '''
#!/bin/bash
set -euo pipefail
TMPDIR=$(mktemp -d)
trap "rm -rf $TMPDIR" EXIT

echo "Generating fresh schemas..."
cargo run --package tasker-orchestration --bin generate-orchestration-openapi --features web-api \
  > "$TMPDIR/orchestration-openapi.json" 2>/dev/null
cargo run --package tasker-worker --bin generate-worker-openapi --features web-api \
  > "$TMPDIR/worker-openapi.json" 2>/dev/null

DIRTY=0
for f in orchestration-openapi.json worker-openapi.json; do
  if ! diff -q "schemas/generated/$f" "$TMPDIR/$f" > /dev/null 2>&1; then
    echo "ERROR: schemas/generated/$f is out of date. Run: cargo make generate-schemas"
    DIRTY=1
  fi
done

if [ $DIRTY -eq 1 ]; then
  exit 1
fi
echo "All generated schemas are up-to-date."
'''
