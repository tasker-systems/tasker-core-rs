# =============================================================================
# Docker Compose for Tasker Production Deployment
# =============================================================================
# This orchestrates a complete production environment with:
# 1. PostgreSQL database with PGMQ extension (production optimized)
# 2. Tasker orchestration service (production build with optimizations)
# 3. Comprehensive Rust worker (production build with optimizations)
#
# Built for production deployment with maximum performance and security
# Usage: cd docker && docker-compose -f docker-compose.deploy.yml up --build -d

# version: '3.8' # Removed - obsolete in newer Docker Compose

services:
  # ==========================================================================
  # Builder Base - Common Rust dependencies with cargo-chef optimization
  # ==========================================================================
  builder-base:
    build:
      context: ..
      dockerfile: docker/build/Dockerfile
      target: builder
    image: rust:1.89-bullseye
    container_name: tasker-builder-base-prod
    profiles:
      - build

  # ==========================================================================
  # Database Service - PostgreSQL with PGMQ extension (production)
  # ==========================================================================
  postgres:
    build:
      context: .
      dockerfile: db/Dockerfile
    container_name: tasker-postgres-prod
    restart: always
    environment:
      POSTGRES_DB: tasker_production
      POSTGRES_USER: tasker
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-tasker} # Use env var in production
      POSTGRES_INITDB_ARGS: "--auth-host=md5"
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      # Custom initialization script for PGMQ and schema
      - ./scripts/postgres-init-production.sql:/docker-entrypoint-initdb.d/01-init.sql:ro
      # Persistent data volume for production
      - postgres_prod_data:/var/lib/postgresql/data
      # Production configuration (optimized for performance)
      - ./scripts/postgres-prod.conf:/etc/postgresql/postgresql.conf:ro
    command: postgres -c config_file=/etc/postgresql/postgresql.conf
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U tasker -d tasker_production"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - tasker-prod-network
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: "1.0"
        reservations:
          memory: 1G
          cpus: "0.5"

  # ==========================================================================
  # Orchestration Service - Production build with optimizations
  # ==========================================================================
  orchestration:
    build:
      context: ..
      dockerfile: docker/deploy/orchestration/Dockerfile
      target: runtime
    container_name: tasker-orchestration-prod
    restart: always
    depends_on:
      postgres:
        condition: service_healthy
      builder-base:
        condition: service_completed_successfully
    environment:
      # Core configuration
      DATABASE_URL: postgresql://tasker:${POSTGRES_PASSWORD:-tasker}@postgres:5432/tasker_production
      TASKER_ENV: production
      WORKSPACE_PATH: /app
      TASKER_CONFIG_ROOT: /app/config
    ports:
      - "${ORCHESTRATION_PORT:-8080}:8080"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 30s
    networks:
      - tasker-prod-network
    volumes:
      # Production logs (consider external log aggregation)
      - ../logs/orchestration-prod:/app/logs
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: "0.5"
        reservations:
          memory: 512M
          cpus: "0.25"
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  # ==========================================================================
  # Worker Service - Production build with optimizations
  # ==========================================================================
  worker:
    build:
      context: ..
      dockerfile: docker/deploy/workers/rust/Dockerfile
      target: runtime
    container_name: tasker-worker-rust-prod
    restart: always
    depends_on:
      postgres:
        condition: service_healthy
      orchestration:
        condition: service_healthy
      builder-base:
        condition: service_completed_successfully
    environment:
      # Core configuration
      DATABASE_URL: postgresql://tasker:${POSTGRES_PASSWORD:-tasker}@postgres:5432/tasker_production
      TASKER_ENV: production
      WORKSPACE_PATH: /app
      TASKER_CONFIG_ROOT: /app/config
    ports:
      - "${WORKER_PORT:-8081}:8081"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/health"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 45s
    networks:
      - tasker-prod-network
    volumes:
      # Production logs (consider external log aggregation)
      - ../logs/worker-prod:/app/logs
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: "1.0"
        reservations:
          memory: 1G
          cpus: "0.5"
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  # ==========================================================================
  # Optional Multi-Language Workers (scale as needed)
  # ==========================================================================

  # Ruby Worker - Production
  # ruby-worker:
  #   build:
  #     context: .
  #     dockerfile: docker/deploy/workers/ruby/Dockerfile
  #   container_name: tasker-ruby-worker-prod
  #   restart: always
  #   depends_on:
  #     postgres:
  #       condition: service_healthy
  #     orchestration:
  #       condition: service_healthy
  #   environment:
  #     DATABASE_URL: postgresql://tasker:${POSTGRES_PASSWORD:-tasker}@postgres:5432/tasker_production
  #     TASKER_ENV: production
  #     WORKSPACE_PATH: /app
  #     TASKER_CONFIG_ROOT: /app/config
  #   ports:
  #     - "${RUBY_WORKER_PORT:-8082}:8082"
  #   networks:
  #     - tasker-prod-network
  #   deploy:
  #     resources:
  #       limits:
  #         memory: 1G
  #         cpus: '0.5'
  #     restart_policy:
  #       condition: on-failure

  # Python Worker - Production
  # python-worker:
  #   build:
  #     context: .
  #     dockerfile: docker/deploy/workers/python/Dockerfile
  #   container_name: tasker-python-worker-prod
  #   restart: always
  #   depends_on:
  #     postgres:
  #       condition: service_healthy
  #     orchestration:
  #       condition: service_healthy
  #   environment:
  #     DATABASE_URL: postgresql://tasker:${POSTGRES_PASSWORD:-tasker}@postgres:5432/tasker_production
  #     TASKER_ENV: production
  #     WORKSPACE_PATH: /app
  #     TASKER_CONFIG_ROOT: /app/config
  #   ports:
  #     - "${PYTHON_WORKER_PORT:-8083}:8083"
  #   networks:
  #     - tasker-prod-network
  #   deploy:
  #     resources:
  #       limits:
  #         memory: 1G
  #         cpus: '0.5'
  #     restart_policy:
  #       condition: on-failure

  # WASM Worker - Production
  # wasm-worker:
  #   build:
  #     context: .
  #     dockerfile: docker/deploy/workers/wasm/Dockerfile
  #   container_name: tasker-wasm-worker-prod
  #   restart: always
  #   depends_on:
  #     postgres:
  #       condition: service_healthy
  #     orchestration:
  #       condition: service_healthy
  #   environment:
  #     DATABASE_URL: postgresql://tasker:${POSTGRES_PASSWORD:-tasker}@postgres:5432/tasker_production
  #     TASKER_ENV: production
  #     WORKSPACE_PATH: /app
  #     TASKER_CONFIG_ROOT: /app/config
  #   networks:
  #     - tasker-prod-network
  #   deploy:
  #     resources:
  #       limits:
  #         memory: 512M
  #         cpus: '0.25'
  #     restart_policy:
  #       condition: on-failure

# =============================================================================
# Network Configuration
# =============================================================================
networks:
  tasker-prod-network:
    name: tasker-production-network
    driver: bridge
    ipam:
      config:
        - subnet: 172.22.0.0/16

# =============================================================================
# Volume Configuration
# =============================================================================
volumes:
  postgres_prod_data:
    name: tasker-prod-postgres-data
    driver: local
# =============================================================================
# Production Configuration
# =============================================================================
# Environment variables to set for production:
# - POSTGRES_PASSWORD: Strong password for PostgreSQL
# - POSTGRES_PORT: PostgreSQL port (default: 5432)
# - ORCHESTRATION_PORT: Orchestration service port (default: 8080)
# - WORKER_PORT: Worker service port (default: 8081)
# - RUBY_WORKER_PORT: Ruby worker port (default: 8082)
# - PYTHON_WORKER_PORT: Python worker port (default: 8083)
#
# Usage examples:
# docker-compose -f docker-compose.deploy.yml --profile build up --build -d
# docker-compose -f docker-compose.deploy.yml up --scale worker=3 -d
# docker-compose -f docker-compose.deploy.yml logs -f orchestration
