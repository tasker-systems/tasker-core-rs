# =============================================================================
# Test Compose Configuration - Local Integration Testing
# =============================================================================
# Optimized for local development and testing:
# - Fast debug builds with Dockerfile.test
# - Always builds from local source (no cached images)
# - Minimal resource usage
# - Quick startup times
#
# Usage: docker-compose -f docker/compose/docker-compose.test.yml up --build

services:
  # ==========================================================================
  # PostgreSQL Database with PGMQ Extension
  # ==========================================================================
  postgres:
    build:
      context: ..
      dockerfile: docker/db/Dockerfile
    command:
      - "postgres"
      - "-c"
      - "max_connections=300"
      - "-c"
      - "shared_buffers=256MB"
      - "-c"
      - "effective_cache_size=1GB"
    environment:
      POSTGRES_DB: tasker_rust_test
      POSTGRES_USER: tasker
      POSTGRES_PASSWORD: tasker
      POSTGRES_HOST_AUTH_METHOD: trust
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U tasker -d tasker_rust_test"]
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - tasker-test

  # ==========================================================================
  # Orchestration Service - Test Build with Centralized Dockerfile
  # ==========================================================================
  orchestration:
    build:
      context: ..
      dockerfile: docker/build/orchestration.test.Dockerfile
    environment:
      DATABASE_URL: postgresql://tasker:tasker@postgres:5432/tasker_rust_test
      TASKER_ENV: test
      RUST_LOG: info
      RUST_BACKTRACE: 1
      PORT: 8080
      WORKSPACE_PATH: /app
      # TAS-61 V2: Single-file configuration from v2 directory
      TASKER_CONFIG_PATH: /app/config/v2/orchestration-test.toml
      # Migration settings
      RUN_MIGRATIONS: "true"
      DEPLOYMENT_MODE: standard
      SKIP_MIGRATION_PROMPT: "true"
      DB_MIGRATION_RETRIES: "3"
      DB_MIGRATION_RETRY_DELAY: "5"
      DB_MIGRATION_TIMEOUT: "120"
    ports:
      - "8080:8080"
    volumes:
      - ../config/v2:/app/config/v2:ro
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 15s
    networks:
      - tasker-test

  # ==========================================================================
  # Rust Worker Service - Test Build with Centralized Dockerfile
  # ==========================================================================
  worker:
    build:
      context: ..
      dockerfile: docker/build/rust-worker.test.Dockerfile
    environment:
      DATABASE_URL: postgresql://tasker:tasker@postgres:5432/tasker_rust_test
      TASKER_ENV: test
      RUST_LOG: debug
      RUST_BACKTRACE: 1
      WORKER_ID: test-worker-001
      WORKSPACE_PATH: /app
      # TAS-61 V2: Single-file configuration from v2 directory
      TASKER_CONFIG_PATH: /app/config/v2/worker-test.toml
      # Point to centralized E2E test templates for Rust handlers
      TASKER_TEMPLATE_PATH: /app/tests/fixtures/task_templates/rust
      PORT: 8081
    ports:
      - "8081:8081"
    volumes:
      - ../config/v2:/app/config/v2:ro
      # Mount centralized test templates
      - ../tests/fixtures/task_templates/rust:/app/tests/fixtures/task_templates/rust:ro
    depends_on:
      postgres:
        condition: service_healthy
      orchestration:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 20s
    networks:
      - tasker-test

  # ==========================================================================
  # Ruby Worker Service - Test Build with Ruby FFI Support
  # ==========================================================================
  ruby-worker:
    build:
      context: ..
      dockerfile: docker/build/ruby-worker.test.Dockerfile
    environment:
      DATABASE_URL: postgresql://tasker:tasker@postgres:5432/tasker_rust_test
      TASKER_ENV: test
      RUST_LOG: info
      RUST_BACKTRACE: 1
      WORKER_ID: test-ruby-worker-001
      WORKSPACE_PATH: /app
      # TAS-61 V2: Single-file configuration from v2 directory
      TASKER_CONFIG_PATH: /app/config/v2/worker-test.toml
      # Point to centralized E2E test templates for Ruby handlers
      TASKER_TEMPLATE_PATH: /app/tests/fixtures/task_templates/ruby
      # Ruby environment
      RUBY_WORKER_ENABLED: "true"
      BUNDLE_GEMFILE: /app/ruby_worker/Gemfile
      # Service configuration
      PORT: 8082
    ports:
      - "8082:8081" # Map to 8082 externally, 8081 internally (same as Rust worker)
    volumes:
      - ../config/v2:/app/config/v2:ro
      # Mount centralized test templates
      - ../tests/fixtures/task_templates/ruby:/app/tests/fixtures/task_templates/ruby:ro
      # Mount handler source code for discovery
      - ../workers/ruby/spec/handlers:/app/handlers:ro
    depends_on:
      postgres:
        condition: service_healthy
      orchestration:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/health"]
      interval: 10s
      timeout: 5s
      retries: 5  # More retries for CI environment
      start_period: 60s # Ruby FFI bootstrap + Rust worker + web API binding can take time in CI
    networks:
      - tasker-test

volumes:
  postgres_data:

networks:
  tasker-test:
    driver: bridge
