# Tasker Core Configuration
# This configuration file provides defaults and environment-specific overrides

# =============================================================================
# DATABASE POOL ARCHITECTURE NOTE
# =============================================================================
# This config uses STRUCTURED pool format: { max_connections, min_connections, etc }
#
# Ruby workers automatically convert this to simple integer format for ActiveRecord:
#   pool: { max_connections: 25 }  -->  pool: 25
#
# This allows:
#   - Rust orchestration: Full connection lifecycle control for performance
#   - Ruby workers: Simple ActiveRecord integration
#   - Single config file: Both systems use same configuration source
# =============================================================================

# Default configuration (applies to all environments unless overridden)
auth:
  authentication_enabled: false
  strategy: "none"
  current_user_method: "current_user"
  authenticate_user_method: "authenticate_user!"
  authorization_enabled: false
  authorization_coordinator_class: "Tasker::Authorization::BaseCoordinator"

database:
  enable_secondary_database: false
  url: "${DATABASE_URL}"
  # Default database configuration
  adapter: postgresql
  encoding: unicode
  host: localhost
  username: tasker
  password: tasker
  pool:
    max_connections: 25
    min_connections: 5
    acquire_timeout_seconds: 30
    idle_timeout_seconds: 300
    max_lifetime_seconds: 3600
  variables:
    statement_timeout: 5000
  checkout_timeout: 10
  reaping_frequency: 10

telemetry:
  enabled: false
  service_name: "tasker-core-rs"
  sample_rate: 1.0

engine:
  task_handler_directory: "tasks"
  task_config_directory: "tasker/tasks"
  identity_strategy: "default"
  custom_events_directories:
    - "config/tasker/events"

# TaskTemplate discovery configuration (default/fallback)
task_templates:
  # Paths to search for TaskTemplate YAML files
  # Default configuration - safe production paths only
  search_paths:
    - "config/task_templates/*.{yml,yaml}"
    - "config/tasks/*.{yml,yaml}"

health:
  enabled: true
  check_interval_seconds: 60
  alert_thresholds:
    error_rate: 0.05
    queue_depth: 1000.0

dependency_graph:
  max_depth: 50 # Replaces Rust constants::system::MAX_DEPENDENCY_DEPTH
  cycle_detection_enabled: true
  optimization_enabled: true

system:
  default_dependent_system: "default"
  default_queue_name: "default"
  version: "0.1.0" # Updated to match Rust TASKER_CORE_VERSION constant
  # New constants unification fields
  max_recursion_depth: 50 # Replaces potential hardcoded recursion limits

backoff:
  default_backoff_seconds: [1, 2, 4, 8, 16, 32]
  max_backoff_seconds: 300
  backoff_multiplier: 2.0
  jitter_enabled: true
  jitter_max_percentage: 0.1
  reenqueue_delays:
    has_ready_steps: 0
    waiting_for_dependencies: 45
    processing: 10
  default_reenqueue_delay: 30
  buffer_seconds: 5

execution:
  processing_mode: "pgmq" # Use pgmq for orchestration
  max_concurrent_tasks: 100
  max_concurrent_steps: 1000
  default_timeout_seconds: 3600
  step_execution_timeout_seconds: 300
  environment: "production"
  max_discovery_attempts: 3
  step_batch_size: 10
  # New constants unification fields
  max_retries: 3 # Replaces Ruby FALLBACK_MAX_RETRIES and DEFAULT_* constants
  max_workflow_steps: 1000 # Replaces Rust constants::system::MAX_WORKFLOW_STEPS
  connection_timeout_seconds: 10 # Replaces Ruby hardcoded API timeouts

reenqueue:
  has_ready_steps: 1
  waiting_for_dependencies: 5
  processing: 2

events:
  batch_size: 100
  enabled: true
  batch_timeout_ms: 1000

cache:
  enabled: true
  ttl_seconds: 3600
  max_size: 10000

# Query caching configuration for database optimization
query_cache:
  enabled: true
  # Worker query caching (production settings)
  active_workers:
    ttl_seconds: 30 # Cache active workers for 30 seconds
    max_entries: 1000 # Up to 1000 task-specific worker lists
  worker_health:
    ttl_seconds: 10 # Cache worker health for 10 seconds
    max_entries: 500 # Up to 500 worker health snapshots
  task_metadata:
    ttl_seconds: 300 # Cache task metadata for 5 minutes
    max_entries: 2000 # Up to 2000 task metadata entries
  handler_metadata:
    ttl_seconds: 600 # Cache handler metadata for 10 minutes
    max_entries: 100 # Up to 100 handler definitions
  # Global cache settings
  cleanup_interval_seconds: 300 # Clean expired entries every 5 minutes
  memory_pressure_threshold: 0.8 # Clear cache at 80% memory usage

# pgmq configuration for PostgreSQL message queue orchestration
pgmq:
  poll_interval_ms: 250 # Standard polling interval for production
  visibility_timeout_seconds: 30 # Keep longer for business logic execution time
  batch_size: 5 # Standard batch size for production (matching Ruby defaults)
  max_retries: 3 # Standard retry limit
  # New constants unification fields
  max_batch_size: 100 # Replaces Ruby MAX_MESSAGE_COUNT constant
  shutdown_timeout_seconds: 5 # Reduced default - tests override to 2, production can override to 30
  default_namespaces:
    - default
    - fulfillment
    - inventory
    - notifications
  queue_naming_pattern: "{namespace}_queue"

# orchestration mode configuration
orchestration:
  mode: "distributed" # Use distributed mode for production
  task_requests_queue_name: "task_requests_queue"
  tasks_per_cycle: 5 # Production throughput
  cycle_interval_ms: 250 # Production cycles
  task_request_polling_interval_ms: 250 # Production polling
  task_request_visibility_timeout_seconds: 300 # Production timeout for business logic
  task_request_batch_size: 10 # Production batch size
  active_namespaces:
    ["fulfillment", "inventory", "notifications", "payments", "analytics"]
  max_concurrent_orchestrators: 3 # Production parallelism
  enable_performance_logging: false # Disable for performance
  default_claim_timeout_seconds: 300 # Production claim timeout

  # Queue configuration for orchestration core
  queues:
    # Task request queue - handles incoming task requests from external systems
    task_requests: "task_requests_queue"

    # Task processing queue - holds tasks ready for orchestration processing
    task_processing: "task_processing_queue"

    # Batch results queue - collects completed batch execution results
    batch_results: "batch_results_queue"

    # Step results queue - collects individual step execution results from workers
    step_results: "orchestration_step_results"

    # Namespaced worker queues - workers poll these for step batches
    worker_queues:
      default: "default_queue"
      fulfillment: "fulfillment_queue"
      inventory: "inventory_queue"
      notifications: "notifications_queue"

    # Queue configuration parameters
    settings:
      visibility_timeout_seconds: 30
      message_retention_seconds: 604800 # 7 days
      dead_letter_queue_enabled: true
      max_receive_count: 3

  embedded_orchestrator:
    auto_start: false # Don't auto-start in distributed mode
    namespaces: ["default", "fulfillment", "inventory", "notifications"]
    shutdown_timeout_seconds: 30 # Production graceful shutdown timeout

  # Heartbeat configuration for orchestrator health monitoring
  enable_heartbeat: true
  heartbeat_interval_ms: 5000 # Production heartbeat intervals

# Circuit breaker configuration for fault tolerance
# Circuit breakers prevent cascade failures by temporarily stopping calls to failing services
circuit_breakers:
  enabled: true
  # Global circuit breaker settings
  global_settings:
    max_circuit_breakers: 50 # Maximum number of circuit breakers that can be created
    metrics_collection_interval_seconds: 30 # How often to collect and report circuit breaker metrics
    auto_create_enabled: true # Automatically create circuit breakers for new components
    min_state_transition_interval_seconds: 1 # Minimum time between state changes to prevent oscillation
  # Default configuration for new circuit breakers
  default_config:
    failure_threshold: 5 # Number of consecutive failures before opening the circuit
    timeout_seconds: 30 # How long to wait in open state before attempting recovery
    success_threshold: 2 # Number of successful calls needed in half-open state to close circuit
  # Component-specific configurations
  component_configs:
    pgmq:
      failure_threshold: 3 # Queue operations should fail fast to prevent message buildup
      timeout_seconds: 15 # Queue recovery should be quick (usually infrastructure issues)
      success_threshold: 2 # Need fewer successful queue operations to restore confidence

# Orchestration Executor Configuration (TAS-34)
# Configures the advanced executor pool system that replaces naive tokio polling loops
executor_pools:
  # Coordinator configuration
  coordinator:
    auto_scaling_enabled: true
    target_utilization: 0.75 # Scale up when pools exceed 75% utilization
    scaling_interval_seconds: 30 # Check scaling every 30 seconds
    health_check_interval_seconds: 10 # Check executor health every 10 seconds
    scaling_cooldown_seconds: 60 # Wait 60 seconds between scaling operations
    max_db_pool_usage: 0.85 # Apply backpressure when DB pool exceeds 85%

  # Per-executor type configuration
  task_request_processor:
    min_executors: 1
    max_executors: 5
    polling_interval_ms: 100
    batch_size: 10
    processing_timeout_ms: 30000
    max_retries: 3
    circuit_breaker_enabled: true
    circuit_breaker_threshold: 5

  task_claimer:
    min_executors: 2
    max_executors: 10
    polling_interval_ms: 50
    batch_size: 20
    processing_timeout_ms: 30000
    max_retries: 3
    circuit_breaker_enabled: true
    circuit_breaker_threshold: 3

  step_enqueuer:
    min_executors: 2
    max_executors: 8
    polling_interval_ms: 50
    batch_size: 50
    processing_timeout_ms: 30000
    max_retries: 3
    circuit_breaker_enabled: true
    circuit_breaker_threshold: 5

  step_result_processor:
    min_executors: 2
    max_executors: 10
    polling_interval_ms: 100
    batch_size: 20
    processing_timeout_ms: 30000
    max_retries: 3
    circuit_breaker_enabled: true
    circuit_breaker_threshold: 3

  task_finalizer:
    min_executors: 1
    max_executors: 4
    polling_interval_ms: 200
    batch_size: 10
    processing_timeout_ms: 30000
    max_retries: 3
    circuit_breaker_enabled: true
    circuit_breaker_threshold: 5

# Environment-specific overrides
development:
  execution:
    environment: "development"

  database:
    database: "tasker_rust_development"
    host: "${DATABASE_HOST:-localhost}"
    username: "${POSTGRES_USER:-tasker}"
    password: "${POSTGRES_PASSWORD:-tasker}"

  task_templates:
    search_paths:
      - "config/task_templates/*.{yml,yaml}"
      - "config/tasks/*.{yml,yaml}"

test:
  execution:
    environment: "test"
    # Test environment overrides - smaller limits and timeouts for faster tests
    max_workflow_steps: 100 # Smaller for test safety
    max_retries: 2 # Fewer retries for faster test feedback
    default_timeout_seconds: 30 # Much shorter timeout for tests (vs 3600 default)
    step_execution_timeout_seconds: 10 # Very short step timeout for tests (vs 300 default)
    connection_timeout_seconds: 3 # Fast connection timeout for tests (vs 10 default)

  # Test environment executor pools - optimized for fast test execution
  executor_pools:
    coordinator:
      auto_scaling_enabled: false # Disable scaling for predictable test behavior
      target_utilization: 0.8 # Higher utilization threshold for tests
      scaling_interval_seconds: 5 # Fast scaling checks for tests
      health_check_interval_seconds: 2 # Frequent health checks for fast feedback
      scaling_cooldown_seconds: 10 # Short cooldown for tests
      max_db_pool_usage: 0.9 # Higher threshold for tests

    # Smaller executor pools for tests - single executor per type for simplicity
    task_request_processor:
      min_executors: 1
      max_executors: 2
      polling_interval_ms: 50 # Faster polling for test responsiveness
      batch_size: 5 # Smaller batches for tests
      processing_timeout_ms: 5000 # 5 second timeout for tests
      max_retries: 2
      circuit_breaker_enabled: true
      circuit_breaker_threshold: 3

    task_claimer:
      min_executors: 1
      max_executors: 2
      polling_interval_ms: 25 # Very fast polling for tests
      batch_size: 10
      processing_timeout_ms: 5000
      max_retries: 2
      circuit_breaker_enabled: true
      circuit_breaker_threshold: 2

    step_enqueuer:
      min_executors: 1
      max_executors: 2
      polling_interval_ms: 25
      batch_size: 20
      processing_timeout_ms: 5000
      max_retries: 2
      circuit_breaker_enabled: true
      circuit_breaker_threshold: 3

    step_result_processor:
      min_executors: 1
      max_executors: 2
      polling_interval_ms: 50
      batch_size: 10
      processing_timeout_ms: 5000
      max_retries: 2
      circuit_breaker_enabled: true
      circuit_breaker_threshold: 2

    task_finalizer:
      min_executors: 1
      max_executors: 2
      polling_interval_ms: 100
      batch_size: 5
      processing_timeout_ms: 5000
      max_retries: 2
      circuit_breaker_enabled: true
      circuit_breaker_threshold: 3

  database:
    database: "tasker_rust_test"
    host: "${DATABASE_HOST:-localhost}"
    username: "${POSTGRES_USER:-tasker}"
    password: "${POSTGRES_PASSWORD:-tasker}"
    variables:
      statement_timeout: 2000 # 2 second statement timeout for tests (vs 5000 default)
    checkout_timeout: 3 # Fast checkout for tests (vs 10 default)
    reaping_frequency: 5 # Faster reaping for tests (vs 10 default)

  # Test environment constants optimization
  dependency_graph:
    max_depth: 10 # Smaller for faster tests

  system:
    max_recursion_depth: 25 # Smaller for test safety

  # Test backoff configuration - faster retry cycles
  backoff:
    default_backoff_seconds: [1, 2, 4] # Much shorter backoff sequence
    max_backoff_seconds: 30 # 30s max vs 300s default
    reenqueue_delays:
      has_ready_steps: 0 # Immediate reenqueue for tests
      waiting_for_dependencies: 5 # 5s vs 45s default
      processing: 2 # 2s vs 10s default
    default_reenqueue_delay: 5 # 5s vs 30s default
    buffer_seconds: 1 # 1s vs 5s default

  # Test events configuration - faster processing
  events:
    batch_size: 10 # Smaller batches for tests
    batch_timeout_ms: 100 # Much faster timeout (vs 1000ms)

  # Test cache configuration - shorter TTL
  cache:
    ttl_seconds: 30 # 30s vs 3600s default
    max_size: 1000 # Smaller cache for tests

  # Test query cache - very short TTL
  query_cache:
    active_workers:
      ttl_seconds: 5 # 5s vs 30s default
      max_entries: 100 # Smaller for tests
    worker_health:
      ttl_seconds: 2 # 2s vs 10s default
      max_entries: 50 # Smaller for tests
    task_metadata:
      ttl_seconds: 10 # 10s vs 300s default
      max_entries: 200 # Smaller for tests
    handler_metadata:
      ttl_seconds: 30 # 30s vs 600s default
      max_entries: 20 # Much smaller for tests
    cleanup_interval_seconds: 10 # 10s vs 300s default

  task_templates:
    # Test environment includes example handlers for integration testing
    search_paths:
      - "bindings/ruby/spec/handlers/examples/**/config/*.{yml,yaml}"

  # Fast test execution settings
  pgmq:
    poll_interval_ms: 100 # 100ms polling for fast test execution (10x/sec)
    visibility_timeout_seconds: 5 # very short in test
    shutdown_timeout_seconds: 2 # very short in test - should match embedded_orchestrator

  orchestration:
    mode: "embedded"
    tasks_per_cycle: 2 # Lower throughput for tests
    cycle_interval_ms: 100 # Very fast cycles for test responsiveness (10x/sec)
    task_request_polling_interval_ms: 100 # Very fast polling for tests (10x/sec)
    task_request_visibility_timeout_seconds: 10 # Much shorter timeout for tests (vs 300 default)
    task_request_batch_size: 5 # Smaller batches for tests
    active_namespaces:
      [
        "fulfillment",
        "inventory",
        "notifications",
        "payments",
        "analytics",
        "default",
      ]
    max_concurrent_orchestrators: 1 # Single orchestrator for tests
    default_claim_timeout_seconds: 10 # Much shorter claim timeout for tests (vs 300 default)
    heartbeat_interval_ms: 1000 # Fast heartbeats for tests (1 second intervals vs 5000ms)
    embedded_orchestrator:
      auto_start: true # auto-start in test mode
      namespaces: ["default", "fulfillment", "inventory", "notifications"]
      shutdown_timeout_seconds: 2 # Graceful shutdown timeout
    queues:
      settings:
        visibility_timeout_seconds: 5 # Very short for tests (vs 30 default)
        message_retention_seconds: 3600 # 1 hour vs 7 days default
        max_receive_count: 2 # Fewer retries for tests (vs 3 default)

  # Circuit breaker disabled for test environment
  # Circuit breakers are a production resilience pattern that conflicts with test lifecycle:
  # - Tests intentionally cause "failures" during setup/teardown
  # - Database connections are frequently created/destroyed in tests
  # - Fast feedback is more important than fault tolerance in tests
  # - Test database lifecycle is managed by test framework, not circuit breakers
  circuit_breakers:
    enabled: true
    # Global circuit breaker settings
    global_settings:
      max_circuit_breakers: 10 # Maximum number of circuit breakers that can be created
      metrics_collection_interval_seconds: 30 # How often to collect and report circuit breaker metrics
      auto_create_enabled: true # Automatically create circuit breakers for new components
      min_state_transition_interval_seconds: 1 # Minimum time between state changes to prevent oscillation
    # Default configuration for new circuit breakers
    default_config:
      failure_threshold: 5 # Number of consecutive failures before opening the circuit
      timeout_seconds: 5 # How long to wait in open state before attempting recovery
      success_threshold: 1 # Number of successful calls needed in half-open state to close circuit
    # Component-specific configurations
    component_configs:
      pgmq:
        failure_threshold: 3 # Queue operations should fail fast to prevent message buildup
        timeout_seconds: 5 # Queue recovery should be quick (usually infrastructure issues)
        success_threshold: 2 # Need fewer successful queue operations to restore confidence

production:
  execution:
    environment: "production"
    # Production environment overrides - higher limits for complex workflows
    max_workflow_steps: 5000 # Higher for complex production workflows
    max_retries: 5 # More retries for production reliability

  # Production environment executor pools - optimized for high throughput and reliability
  executor_pools:
    coordinator:
      auto_scaling_enabled: true # Full auto-scaling in production
      target_utilization: 0.70 # Lower utilization threshold for headroom
      scaling_interval_seconds: 60 # Slower scaling for stability
      health_check_interval_seconds: 15 # Moderate health check frequency
      scaling_cooldown_seconds: 120 # Longer cooldown for production stability
      max_db_pool_usage: 0.80 # Conservative DB pool usage

    # Larger executor pools for production - higher concurrency
    task_request_processor:
      min_executors: 2
      max_executors: 10
      polling_interval_ms: 100
      batch_size: 15
      processing_timeout_ms: 60000 # 60 second timeout for production
      max_retries: 5
      circuit_breaker_enabled: true
      circuit_breaker_threshold: 10

    task_claimer:
      min_executors: 3
      max_executors: 20
      polling_interval_ms: 50
      batch_size: 30
      processing_timeout_ms: 60000
      max_retries: 5
      circuit_breaker_enabled: true
      circuit_breaker_threshold: 8

    step_enqueuer:
      min_executors: 3
      max_executors: 15
      polling_interval_ms: 50
      batch_size: 75
      processing_timeout_ms: 60000
      max_retries: 5
      circuit_breaker_enabled: true
      circuit_breaker_threshold: 10

    step_result_processor:
      min_executors: 3
      max_executors: 20
      polling_interval_ms: 100
      batch_size: 30
      processing_timeout_ms: 60000
      max_retries: 5
      circuit_breaker_enabled: true
      circuit_breaker_threshold: 8

    task_finalizer:
      min_executors: 2
      max_executors: 8
      polling_interval_ms: 200
      batch_size: 15
      processing_timeout_ms: 60000
      max_retries: 5
      circuit_breaker_enabled: true
      circuit_breaker_threshold: 10

  database:
    database: "${POSTGRES_DB:-tasker_production}"
    host: "${DATABASE_HOST:-localhost}"
    username: "${POSTGRES_USER:-tasker}"
    password: "${POSTGRES_PASSWORD:-tasker}"
    pool:
      max_connections: 50 # Higher for production
      min_connections: 10
      acquire_timeout_seconds: 30
      idle_timeout_seconds: 300
      max_lifetime_seconds: 3600

  # Production-specific pgmq settings
  pgmq:
    shutdown_timeout_seconds: 30 # Longer graceful shutdown for production

  # Production environment constants optimization
  dependency_graph:
    max_depth: 100 # Higher for complex production workflows

  system:
    max_recursion_depth: 100 # Higher for complex production scenarios

  telemetry:
    enabled: true
    sample_rate: 0.1

  orchestration:
    enable_performance_logging: true

  # Circuit breaker configuration for fault tolerance
  circuit_breakers:
    enabled: true
    # Global circuit breaker settings
    global_settings:
      max_circuit_breakers: 100 # Higher limit for production to handle more services
      metrics_collection_interval_seconds: 10 # More frequent metrics in production for monitoring
      auto_create_enabled: true
      min_state_transition_interval_seconds: 1 # Standard transition interval
    # Default configuration for new circuit breakers
    default_config:
      failure_threshold: 5 # Standard production failure tolerance
      timeout_seconds: 30 # Standard production recovery time
      success_threshold: 2 # Standard production recovery validation
    # Component-specific configurations
    component_configs:
      database:
        failure_threshold: 3 # Be more aggressive about DB failures in production
        timeout_seconds: 45 # Allow more time for DB recovery in production
        success_threshold: 2 # Standard recovery validation
      pgmq:
        failure_threshold: 5 # Allow more queue failures in production (higher load)
        timeout_seconds: 20 # Standard queue recovery time
        success_threshold: 2 # Standard recovery validation
