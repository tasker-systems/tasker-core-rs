# TAS-50 Phase 2: Orchestration Configuration
#
# This file contains orchestration-specific configuration:
# - Retry and backoff logic for task/step retries
# - Orchestration system settings (web API, operational state)
# - Orchestration event systems (real-time coordination)
# - Task readiness event systems (task discovery)
# - Orchestration MPSC channels (command processor, event listeners)
#
# Used by: Orchestration and Combined deployment contexts
#
# Environment Overrides: config/tasker/environments/{env}/orchestration.toml

# Current environment - cached from common config
environment = "development"

# ============================================================================
# BACKOFF AND RETRY CONFIGURATION
# ============================================================================

[backoff]
default_backoff_seconds = [1, 2, 4, 8, 16, 32]
max_backoff_seconds = 300
backoff_multiplier = 2.0
jitter_enabled = true
jitter_max_percentage = 0.1
default_reenqueue_delay = 30
buffer_seconds = 5

[backoff.reenqueue_delays]
# TAS-41: New state machine states
initializing = 5
enqueuing_steps = 0
steps_in_process = 10
evaluating_results = 5
waiting_for_dependencies = 45
waiting_for_retry = 30
blocked_by_failures = 60

# ============================================================================
# ORCHESTRATION SYSTEM CONFIGURATION
# ============================================================================

[orchestration_system]
mode = "standalone"
max_concurrent_orchestrators = 3
enable_performance_logging = false
use_unified_state_machine = true

# Note: Queue configuration has been moved to common.toml
# The orchestration system now references the centralized queue configuration

[orchestration_system.operational_state]
enable_shutdown_aware_monitoring = true
suppress_alerts_during_shutdown = true
startup_health_threshold_multiplier = 0.5
shutdown_health_threshold_multiplier = 0.0
graceful_shutdown_timeout_seconds = 30
emergency_shutdown_timeout_seconds = 5
enable_transition_logging = true
transition_log_level = "INFO"

[orchestration_system.web]
enabled = true
bind_address = "0.0.0.0:8080"
request_timeout_ms = 30000
max_request_size_mb = 16

[orchestration_system.web.tls]
enabled = false
cert_path = ""
key_path = ""
# For production, set these via environment variables:
# WEB_TLS_ENABLED=true
# WEB_TLS_CERT_PATH=/path/to/cert.pem
# WEB_TLS_KEY_PATH=/path/to/key.pem

[orchestration_system.web.database_pools]
# Web API dedicated pool configuration
# These pools are separate from orchestration pools to prevent resource contention
web_api_pool_size = 10
web_api_max_connections = 15
web_api_connection_timeout_seconds = 30
web_api_idle_timeout_seconds = 600
max_total_connections_hint = 45         # Should align with database server limits

[orchestration_system.web.cors]
enabled = true
allowed_origins = ["*"]
allowed_methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"]
allowed_headers = ["*"]
max_age_seconds = 86400

[orchestration_system.web.auth]
enabled = false
jwt_issuer = "tasker-core"
jwt_audience = "tasker-api"
jwt_token_expiry_hours = 24
# JWT keys should be provided via environment variables for security:
# JWT_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----..."
# JWT_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----..."
jwt_private_key = ""
jwt_public_key = ""
# API key for testing (use env var API_KEY in production)
api_key = ""
api_key_header = "X-API-Key"

# Route-specific authentication configuration
# Configure which routes require authentication and what type
[orchestration_system.web.auth.protected_routes]
# Mutation endpoints that should require JWT auth by default
"DELETE /v1/tasks/{task_uuid}" = { auth_type = "bearer", required = true }
"PATCH /v1/tasks/{task_uuid}/workflow_steps/{step_uuid}" = { auth_type = "bearer", required = true }

# Additional routes that can be configured to require auth
"POST /v1/tasks" = { auth_type = "bearer", required = false }
"GET /v1/analytics/performance" = { auth_type = "bearer", required = false }
"GET /v1/analytics/bottlenecks" = { auth_type = "bearer", required = false }

[orchestration_system.web.rate_limiting]
enabled = false
requests_per_minute = 1000
burst_size = 100
per_client_limit = true

[orchestration_system.web.resilience]
circuit_breaker_enabled = true
request_timeout_seconds = 30
max_concurrent_requests = 100

[orchestration_system.web.resource_monitoring]
# Integration with health monitoring system
report_pool_usage_to_health_monitor = true
pool_usage_warning_threshold = 0.75
pool_usage_critical_threshold = 0.90

# ============================================================================
# ORCHESTRATION EVENT SYSTEM
# ============================================================================

[orchestration_events]
system_id = "orchestration-event-system"
deployment_mode = "Hybrid"

# Timing configuration
[orchestration_events.timing]
health_check_interval_seconds = 30
fallback_polling_interval_seconds = 5
visibility_timeout_seconds = 30
processing_timeout_seconds = 30
claim_timeout_seconds = 300

# Processing and concurrency configuration
[orchestration_events.processing]
max_concurrent_operations = 10
batch_size = 10
max_retries = 3

[orchestration_events.processing.backoff]
initial_delay_ms = 100
max_delay_ms = 5000
multiplier = 2.0
jitter_percent = 0.1

# Health monitoring configuration
[orchestration_events.health]
enabled = true
performance_monitoring_enabled = true
max_consecutive_errors = 10
error_rate_threshold_per_minute = 5

# Orchestration-specific metadata
[orchestration_events.metadata]
# Note: queues configuration populated at runtime from common.toml
queues_populated_at_runtime = true

# ============================================================================
# TASK READINESS EVENT SYSTEM
# ============================================================================

[task_readiness_events]
system_id = "task-readiness-event-system"
deployment_mode = "Hybrid"

# Timing configuration
[task_readiness_events.timing]
health_check_interval_seconds = 30
fallback_polling_interval_seconds = 5
visibility_timeout_seconds = 30
processing_timeout_seconds = 30
claim_timeout_seconds = 300

# Processing and concurrency configuration
[task_readiness_events.processing]
max_concurrent_operations = 100
batch_size = 50
max_retries = 3

[task_readiness_events.processing.backoff]
initial_delay_ms = 100
max_delay_ms = 5000
multiplier = 2.0
jitter_percent = 0.1

# Health monitoring configuration
[task_readiness_events.health]
enabled = true
performance_monitoring_enabled = true
max_consecutive_errors = 10
error_rate_threshold_per_minute = 5

# Task readiness-specific metadata
[task_readiness_events.metadata.enhanced_settings]
startup_timeout_seconds = 30
shutdown_timeout_seconds = 10
metrics_enabled = true
rollback_threshold_percent = 5.0

# PostgreSQL LISTEN/NOTIFY configuration
[task_readiness_events.metadata.notification]
global_channels = ["task_ready", "task_state_change", "namespace_created"]
max_payload_size_bytes = 8000
parse_timeout_ms = 100

[task_readiness_events.metadata.notification.namespace_patterns]
task_ready = "task_ready.{namespace}"
task_state_change = "task_state_change.{namespace}"

[task_readiness_events.metadata.notification.connection]
max_connection_retries = 3
connection_retry_delay_seconds = 2
auto_reconnect = true

# Event channel configuration
# NOTE: buffer_size and send_timeout_ms are in mpsc_channels.toml (TAS-51)
[task_readiness_events.metadata.event_channel]
max_retries = 3

[task_readiness_events.metadata.event_channel.backoff]
initial_delay_ms = 100
max_delay_ms = 5000
multiplier = 2.0
jitter_percent = 0.1

# Task readiness coordinator configuration
[task_readiness_events.metadata.coordinator]
instance_id_prefix = "task_readiness"
operation_timeout_ms = 5000
stats_interval_seconds = 60

# ============================================================================
# ORCHESTRATION MPSC CHANNELS
# ============================================================================

[mpsc_channels.command_processor]
# Orchestration command processor channel (TAS-40 pattern)
# Handles: InitializeTask, ProcessStepResult, FinalizeTask commands
command_buffer_size = 1000

[mpsc_channels.event_systems]
# Orchestration event system notification channels
# Handles: PGMQ message ready events, internal coordination events
event_channel_buffer_size = 1000

[mpsc_channels.event_listeners]
# PGMQ notification listener for orchestration queue
# Handles: PostgreSQL LISTEN/NOTIFY events for orchestration_* queues
pgmq_event_buffer_size = 10000  # Large buffer for notification bursts

