# Tasker V2 Orchestration Configuration (Base)
# Orchestration-specific settings

[orchestration]
mode = "standalone"
enable_performance_logging = true

[orchestration._docs.mode]
description = "Orchestration deployment mode"
type = "String"
valid_range = "standalone"
system_impact = "Reserved for future multi-node orchestration; standalone is the only supported mode"

[orchestration._docs.enable_performance_logging]
description = "Enable detailed performance logging for orchestration actors"
type = "bool"
valid_range = "true/false"
system_impact = "Emits timing metrics for task processing, step enqueueing, and result evaluation; disable in production if log volume is a concern"

[orchestration.event_systems.orchestration]
system_id = "orchestration-event-system"
deployment_mode = "Hybrid"

[orchestration.event_systems.orchestration._docs.system_id]
description = "Unique identifier for the orchestration event system instance"
type = "String"
valid_range = "non-empty string"
system_impact = "Used in logging and metrics to distinguish this event system from others"

[orchestration.event_systems.orchestration._docs.deployment_mode]
description = "Event delivery mode: 'Hybrid' (LISTEN/NOTIFY + polling fallback), 'EventDrivenOnly', or 'PollingOnly'"
type = "DeploymentMode"
valid_range = "Hybrid | EventDrivenOnly | PollingOnly"
system_impact = "Hybrid is recommended; EventDrivenOnly has lowest latency but no fallback; PollingOnly has highest latency but no LISTEN/NOTIFY dependency"

[orchestration.event_systems.orchestration.timing]
health_check_interval_seconds = 30
fallback_polling_interval_seconds = 5
visibility_timeout_seconds = 30
processing_timeout_seconds = 60
claim_timeout_seconds = 300

[orchestration.event_systems.orchestration.processing]
max_concurrent_operations = 50
batch_size = 20
max_retries = 3

[orchestration.event_systems.orchestration.processing.backoff]
initial_delay_ms = 100
max_delay_ms = 10000
multiplier = 2.0
jitter_percent = 0.1

[orchestration.event_systems.orchestration.health]
enabled = true
performance_monitoring_enabled = true
max_consecutive_errors = 10
error_rate_threshold_per_minute = 20

[orchestration.event_systems.task_readiness]
system_id = "task-readiness-event-system"
deployment_mode = "Hybrid"

[orchestration.event_systems.task_readiness.timing]
health_check_interval_seconds = 30
fallback_polling_interval_seconds = 5
visibility_timeout_seconds = 30
processing_timeout_seconds = 60
claim_timeout_seconds = 300

[orchestration.event_systems.task_readiness.processing]
max_concurrent_operations = 100
batch_size = 50
max_retries = 3

[orchestration.event_systems.task_readiness.processing.backoff]
initial_delay_ms = 100
max_delay_ms = 10000
multiplier = 2.0
jitter_percent = 0.1

[orchestration.event_systems.task_readiness.health]
enabled = true
performance_monitoring_enabled = true
max_consecutive_errors = 10
error_rate_threshold_per_minute = 20

[orchestration.decision_points]
enabled = true
max_steps_per_decision = 100
max_decision_depth = 20
warn_threshold_steps = 50
warn_threshold_depth = 10
enable_detailed_logging = false
enable_metrics = true

# TAS-49: DLQ (Dead Letter Queue) Configuration
[orchestration.dlq]
enabled = true
auto_dlq_on_staleness = true
include_full_task_snapshot = true
max_pending_age_hours = 168  # 1 week

[orchestration.dlq._docs.enabled]
description = "Enable the Dead Letter Queue subsystem for handling unrecoverable tasks"
type = "bool"
valid_range = "true/false"
system_impact = "When false, stale or failed tasks remain in their error state without DLQ routing"

[orchestration.dlq._docs.auto_dlq_on_staleness]
description = "Automatically move stale tasks to the DLQ when staleness detection identifies them"
type = "bool"
valid_range = "true/false"
system_impact = "When true, the staleness detector can autonomously DLQ tasks without manual intervention"

[orchestration.dlq._docs.max_pending_age_hours]
description = "Maximum age in hours a task can remain in a pending-like state before being considered stale"
type = "u32"
valid_range = "1-720"
system_impact = "Safety net for tasks that fall through other staleness thresholds; 168 = 1 week"

[orchestration.dlq.reasons]
staleness_timeout = true
max_retries_exceeded = true
worker_unavailable = true
dependency_cycle_detected = true
manual_dlq = true

[orchestration.dlq.staleness_detection]
enabled = true
detection_interval_seconds = 300  # 5 minutes
batch_size = 100
dry_run = false

[orchestration.dlq.staleness_detection._docs.enabled]
description = "Enable periodic scanning for stale tasks"
type = "bool"
valid_range = "true/false"
system_impact = "When false, no automatic staleness detection runs; tasks must be manually DLQ'd"

[orchestration.dlq.staleness_detection._docs.detection_interval_seconds]
description = "Interval in seconds between staleness detection sweeps"
type = "u32"
valid_range = "30-3600"
system_impact = "Lower values detect stale tasks faster but increase database query frequency"

[orchestration.dlq.staleness_detection._docs.dry_run]
description = "Run staleness detection in observation-only mode without taking action"
type = "bool"
valid_range = "true/false"
system_impact = "Logs what would be DLQ'd without actually transitioning tasks; useful for tuning thresholds"

[orchestration.dlq.staleness_detection.thresholds]
waiting_for_dependencies_minutes = 60  # TAS-48 consolidation
waiting_for_retry_minutes = 30         # TAS-48 consolidation
steps_in_process_minutes = 30
task_max_lifetime_hours = 24

[orchestration.dlq.staleness_detection.thresholds._docs.task_max_lifetime_hours]
description = "Absolute maximum lifetime for any task regardless of state"
type = "u32"
valid_range = "1-168"
system_impact = "Hard cap; tasks exceeding this age are considered stale even if actively processing"

[orchestration.dlq.staleness_detection.actions]
auto_transition_to_error = true
auto_move_to_dlq = true
emit_events = true
event_channel = "task_staleness_detected"

[orchestration.dlq.staleness_detection.actions._docs.event_channel]
description = "PGMQ channel name for staleness detection events"
type = "String"
valid_range = "1-255 characters"
system_impact = "Consumers can subscribe to this channel for alerting or custom staleness handling"

# TAS-59: Batch Processing Configuration
# TAS-125: Removed checkpoint_interval_default - handlers decide when to checkpoint
[orchestration.batch_processing]
enabled = true
max_parallel_batches = 50
default_batch_size = 1000
checkpoint_stall_minutes = 15

[orchestration.mpsc_channels.command_processor]
command_buffer_size = 5000

[orchestration.mpsc_channels.event_systems]
event_channel_buffer_size = 10000

[orchestration.mpsc_channels.event_listeners]
pgmq_event_buffer_size = 50000

[orchestration.web]
enabled = true
bind_address = "${TASKER_WEB_BIND_ADDRESS:-0.0.0.0:8080}"
request_timeout_ms = 30000

[orchestration.web._docs.enabled]
description = "Enable the REST API server for the orchestration service"
type = "bool"
valid_range = "true/false"
system_impact = "When false, no HTTP endpoints are available; the service operates via messaging only"

[orchestration.web._docs.bind_address]
description = "Socket address for the REST API server"
type = "String"
valid_range = "host:port"
system_impact = "Determines where the orchestration REST API listens; use 0.0.0.0 for container deployments"

[orchestration.web._docs.bind_address.recommendations]
test = { value = "0.0.0.0:8080", rationale = "Default port for test fixtures" }
production = { value = "0.0.0.0:8080", rationale = "Standard port; use TASKER_WEB_BIND_ADDRESS env var to override in CI" }

[orchestration.web._docs.request_timeout_ms]
description = "Maximum time in milliseconds for an HTTP request to complete before timeout"
type = "u32"
valid_range = "100-300000"
system_impact = "Requests exceeding this timeout return HTTP 408; protects against slow client connections"

[orchestration.web.database_pools]
web_api_pool_size = 20
web_api_max_connections = 30
web_api_connection_timeout_seconds = 30
web_api_idle_timeout_seconds = 600
max_total_connections_hint = 50

# TAS-61: Removed [orchestration.web.cors] - CORS uses hardcoded tower_http::cors::Any in middleware
# See: tasker-orchestration/src/web/middleware/mod.rs:create_cors_layer()

[orchestration.web.auth]
enabled = false
jwt_issuer = "tasker-core"
jwt_audience = "tasker-api"
jwt_token_expiry_hours = 24
jwt_private_key = ""
jwt_public_key = "${TASKER_JWT_PUBLIC_KEY:-}"
jwt_public_key_path = "${TASKER_JWT_PUBLIC_KEY_PATH:-}"
api_key = ""
api_key_header = "X-API-Key"

[orchestration.web.auth._docs.enabled]
description = "Enable authentication for the REST API"
type = "bool"
valid_range = "true/false"
system_impact = "When false, all API endpoints are unauthenticated; enable in production with JWT or API key auth"

[orchestration.web.auth._docs.jwt_issuer]
description = "Expected 'iss' claim in JWT tokens"
type = "String"
valid_range = "non-empty string"
system_impact = "Tokens with a different issuer are rejected during validation"

[orchestration.web.auth._docs.api_key_header]
description = "HTTP header name for API key authentication"
type = "String"
valid_range = "valid HTTP header name"
system_impact = "Clients send their API key in this header; default is X-API-Key"

# TAS-177: Removed protected_routes - superseded by SecurityContext permissions
# Route protection is now handled via SecurityContext and permission checks in handlers.
# TAS-61: Removed [orchestration.web.rate_limiting] - no rate limiting middleware implemented

[orchestration.web.resilience]
circuit_breaker_enabled = true
# TAS-61: Removed request_timeout_seconds - timeout hardcoded in middleware (30s)
# TAS-61: Removed max_concurrent_requests - no concurrency limiting implemented

# TAS-177: gRPC API Configuration
# Configuration for the gRPC server that runs alongside the REST API
[orchestration.grpc]
enabled = true
# Note: Default changed from 9090 to 9190 to avoid conflict with Prometheus in docker-compose
bind_address = "${TASKER_ORCHESTRATION_GRPC_BIND_ADDRESS:-0.0.0.0:9190}"
tls_enabled = false
# tls_cert_path = "/path/to/cert.pem"   # Required if tls_enabled = true
# tls_key_path = "/path/to/key.pem"     # Required if tls_enabled = true
keepalive_interval_seconds = 30
keepalive_timeout_seconds = 20
max_concurrent_streams = 200
max_frame_size = 16384
enable_reflection = true
enable_health_service = true

[orchestration.grpc._docs.enabled]
description = "Enable the gRPC API server alongside the REST API"
type = "bool"
valid_range = "true/false"
system_impact = "When false, no gRPC endpoints are available; clients must use REST"

[orchestration.grpc._docs.bind_address]
description = "Socket address for the gRPC server"
type = "String"
valid_range = "host:port"
system_impact = "Must not conflict with the REST API bind_address; default 9190 avoids Prometheus port conflict"

[orchestration.grpc._docs.tls_enabled]
description = "Enable TLS encryption for gRPC connections"
type = "bool"
valid_range = "true/false"
system_impact = "When true, tls_cert_path and tls_key_path must be provided; required for production gRPC deployments"

[orchestration.grpc._docs.enable_reflection]
description = "Enable gRPC server reflection for service discovery"
type = "bool"
valid_range = "true/false"
system_impact = "Allows tools like grpcurl to list and inspect services; safe to enable in development, consider disabling in production"

[orchestration.grpc._docs.enable_health_service]
description = "Enable the gRPC health checking service (grpc.health.v1)"
type = "bool"
valid_range = "true/false"
system_impact = "Required for gRPC-native health checks used by load balancers and container orchestrators"
