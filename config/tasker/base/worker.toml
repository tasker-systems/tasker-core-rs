# TAS-50 Phase 2: Worker Configuration
#
# This file contains language-agnostic worker configuration used by all worker languages:
# - Worker system settings (web API, health monitoring, step processing)
# - Worker event systems (real-time coordination)
# - Worker MPSC channels (command processor, event listeners)
# - Template path with ENV override support (TASKER_TEMPLATE_PATH)
#
# Used by: Rust workers, Ruby workers (via FFI), Python workers (via FFI), WASM workers (future)
# Used in: Worker and Combined deployment contexts
#
# Environment Overrides: config/tasker/environments/{env}/worker.toml

# Current environment - cached from common config
environment = "development"

# Template path for task handler discovery (optional)
# Can be overridden by TASKER_TEMPLATE_PATH environment variable
# Priority: TASKER_TEMPLATE_PATH env var > template_path TOML value
# template_path = "/path/to/templates"  # Uncomment to set via TOML

# ============================================================================
# WORKER SYSTEM CONFIGURATION
# ============================================================================

[worker_system]
# Worker system identification
worker_id = "worker-001"
worker_type = "general"

# TAS-43 Event-Driven Processing Configuration
[worker_system.event_driven]
# Enable event-driven processing (vs polling-only mode)
enabled = true
# Deployment mode: "PollingOnly", "EventDrivenOnly", or "Hybrid" (recommended)
deployment_mode = "Hybrid"
# Health monitoring for event system
health_monitoring_enabled = true
health_check_interval_seconds = 30

# Step processing configuration (command pattern)
[worker_system.step_processing]
claim_timeout_seconds = 300
max_retries = 3
retry_backoff_multiplier = 2.0
heartbeat_interval_seconds = 30
max_concurrent_steps = 100

# TAS-43 Event-Driven Listener Configuration (PostgreSQL LISTEN/NOTIFY)
[worker_system.listener]
# Retry configuration for listener connection failures
retry_interval_seconds = 5
max_retry_attempts = 3
event_timeout_seconds = 30
health_check_interval_seconds = 60
batch_processing = true
connection_timeout_seconds = 10

# TAS-43 Fallback Poller Configuration (TAS-41 updated for event-driven architecture)
[worker_system.fallback_poller]
enabled = true
# Polling interval increased from 500ms to 45000ms (45s) due to event-driven notifications
polling_interval_ms = 45000
batch_size = 5
age_threshold_seconds = 10
max_age_hours = 12
visibility_timeout_seconds = 30
# TAS-41: Task states that can be picked up for processing
processable_states = ["pending", "waiting_for_dependencies", "waiting_for_retry"]

# Worker health monitoring
[worker_system.health_monitoring]
health_check_interval_seconds = 10
metrics_collection_enabled = true
performance_monitoring_enabled = true
step_processing_rate_threshold = 10.0
error_rate_threshold = 0.05
memory_usage_threshold_mb = 1024

# Worker resource limits
[worker_system.resource_limits]
max_memory_mb = 2048
max_cpu_percent = 80
max_database_connections = 50
max_queue_connections = 20

# Queue configuration for message consumption
[worker_system.queue_config]
visibility_timeout_seconds = 30
batch_size = 10
polling_interval_ms = 100

# Worker Web API Configuration
# Separate from orchestration web API (different port)
[worker_system.web]
enabled = true
bind_address = "0.0.0.0:8081" # Worker uses port 8081 (orchestration uses 8080)
request_timeout_ms = 30000
max_request_size_mb = 16

[worker_system.web.tls]
enabled = false
cert_path = ""
key_path = ""
# For production, set these via environment variables:
# WORKER_WEB_TLS_ENABLED=true
# WORKER_WEB_TLS_CERT_PATH=/path/to/cert.pem
# WORKER_WEB_TLS_KEY_PATH=/path/to/key.pem

[worker_system.web.database_pools]
# Worker Web API dedicated pool configuration
# Separate from main worker database pool to prevent resource contention
web_api_pool_size = 5
web_api_max_connections = 10
web_api_connection_timeout_seconds = 15
web_api_idle_timeout_seconds = 300
max_total_connections_hint = 25

[worker_system.web.cors]
enabled = true
allowed_origins = ["*"]
allowed_methods = ["GET", "POST", "DELETE", "OPTIONS"]
allowed_headers = ["*"]
max_age_seconds = 86400

[worker_system.web.auth]
enabled = false
jwt_issuer = "tasker-worker"
jwt_audience = "worker-api"
jwt_token_expiry_hours = 24
# JWT keys should be provided via environment variables for security
jwt_private_key = ""
jwt_public_key = ""
api_key = ""
api_key_header = "X-API-Key"

# Route-specific authentication configuration for worker endpoints
[worker_system.web.auth.protected_routes]
# Template management endpoints that should require auth by default
"DELETE /templates/cache" = { auth_type = "bearer", required = true }
"POST /templates/cache/maintain" = { auth_type = "bearer", required = true }
"POST /templates/{namespace}/{name}/{version}/refresh" = { auth_type = "bearer", required = true }

# Status endpoints that can be configured to require auth
"GET /status/detailed" = { auth_type = "bearer", required = false }
"GET /handlers" = { auth_type = "bearer", required = false }

[worker_system.web.rate_limiting]
enabled = false
requests_per_minute = 500 # Lower than main API since worker has fewer endpoints
burst_size = 50
per_client_limit = true

[worker_system.web.resilience]
circuit_breaker_enabled = true
request_timeout_seconds = 30
max_concurrent_requests = 50   # Lower than main API for worker-specific load

[worker_system.web.resource_monitoring]
# Integration with worker health monitoring system
report_pool_usage_to_health_monitor = true
pool_usage_warning_threshold = 0.80
pool_usage_critical_threshold = 0.95

# Worker-specific endpoint configuration
[worker_system.web.endpoints]
# Health endpoints (Kubernetes-compatible)
health_enabled = true
health_path = "/health"
readiness_path = "/health/ready"
liveness_path = "/health/live"

# Metrics endpoints (Prometheus-compatible)
metrics_enabled = true
prometheus_path = "/metrics"
worker_metrics_path = "/metrics/worker"

# Worker status endpoints
status_enabled = true
basic_status_path = "/status"
detailed_status_path = "/status/detailed"
namespace_health_path = "/status/namespaces"
registered_handlers_path = "/handlers"

# Template management endpoints
templates_enabled = true
templates_base_path = "/templates"
template_cache_enabled = true

# ============================================================================
# WORKER EVENT SYSTEM
# ============================================================================

[worker_events]
system_id = "worker-event-system"
deployment_mode = "Hybrid"

# Timing configuration
[worker_events.timing]
health_check_interval_seconds = 30
fallback_polling_interval_seconds = 1  # Workers need faster polling
visibility_timeout_seconds = 30
processing_timeout_seconds = 30
claim_timeout_seconds = 300

# Processing and concurrency configuration
[worker_events.processing]
max_concurrent_operations = 100  # Workers handle more concurrent operations
batch_size = 10
max_retries = 3

[worker_events.processing.backoff]
initial_delay_ms = 100
max_delay_ms = 5000
multiplier = 2.0
jitter_percent = 0.1

# Health monitoring configuration
[worker_events.health]
enabled = true
performance_monitoring_enabled = true
max_consecutive_errors = 10
error_rate_threshold_per_minute = 5

# Worker-specific metadata
# In-process event system (no TCP endpoints - uses broadcast channels for FFI)
[worker_events.metadata.in_process_events]
# NOTE: broadcast_buffer_size is in mpsc_channels.toml (TAS-51)
ffi_integration_enabled = true
deduplication_cache_size = 1000

# PostgreSQL LISTEN/NOTIFY listener configuration
[worker_events.metadata.listener]
retry_interval_seconds = 5
max_retry_attempts = 3
event_timeout_seconds = 30
batch_processing = true
connection_timeout_seconds = 10

# Fallback poller configuration for reliability
[worker_events.metadata.fallback_poller]
enabled = true
polling_interval_ms = 500
batch_size = 10
age_threshold_seconds = 2
max_age_hours = 12
visibility_timeout_seconds = 30

# Resource limits for workers
[worker_events.metadata.resource_limits]
max_memory_mb = 2048
max_cpu_percent = 80.0
max_database_connections = 50
max_queue_connections = 20

# ============================================================================
# WORKER MPSC CHANNELS
# ============================================================================

[mpsc_channels.command_processor]
# Worker command processor channel
# Handles: ExecuteStep, SendStepResult, ProcessStepCompletion commands
command_buffer_size = 1000

[mpsc_channels.event_systems]
# Worker event system notification channels
# Handles: PGMQ message ready events for namespace queues
event_channel_buffer_size = 1000

[mpsc_channels.event_subscribers]
# Step completion and result channels
# Handles: Step execution completion notifications and result processing
completion_buffer_size = 1000
result_buffer_size = 1000

[mpsc_channels.in_process_events]
# In-process event broadcast channel (for FFI integration)
# Handles: Rust â†’ Ruby event broadcasts across FFI boundary
broadcast_buffer_size = 1000

[mpsc_channels.event_listeners]
# PGMQ notification listener for worker namespace queues
# Handles: PostgreSQL LISTEN/NOTIFY events for {namespace}_queue
pgmq_event_buffer_size = 1000

