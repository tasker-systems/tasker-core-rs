# TAS-136: Refactor Legacy Data Schema Elements

## Summary

Remove vestigial schema elements inherited from the original Rails Engine prototype that no longer serve the distributed Rust-based architecture. This includes dropping unused tables (annotations, dependent systems), removing deprecated columns (bypass_steps, skippable), and documenting JSONB column semantics for clarity.

## Relationship to Other Tickets

| Ticket | Relationship | Status |
|--------|-------------|--------|
| **TAS-128** | Schema flattening and pg18 migration - coordinates timing | In Progress |
| **TAS-78** | Established migrations/tasker/ structure | Complete |
| **TAS-112** | Defined batch processing JSONB shapes | Complete |
| **TAS-125** | Added checkpoint column for batch resumption | Complete |

**Coordination Note**: TAS-136 should be implemented as a distinct PR but coordinated with TAS-128's schema flattening. When TAS-128 creates the flattened migration baseline, TAS-136's removals can be incorporated into that baseline rather than as separate DROP statements. This keeps the final schema clean while maintaining clear ticket-level accountability.

## Problem Statement

The current schema contains elements from an earlier Rails Engine prototype that predate the distributed Rust orchestration architecture:

1. **Dependent Systems Tables**: `tasker_dependent_systems` and `tasker_dependent_system_object_maps` were designed for a tightly-coupled environment. The "dependent system" concept conflates typology/categorization with relational hierarchy—it's really just a label on steps, not a meaningful entity relationship.

2. **Task Annotations Tables**: `tasker_annotation_types` and `tasker_task_annotations` implement an EAV-lite pattern that overlaps with the existing `tasks.tags` (JSONB with GIN indexes) and `tasks.context` (workflow input payload) columns.

3. **Deprecated Workflow Concepts**: `bypass_steps` and `skippable` columns represent a superseded approach to conditional execution. Conditional workflows (decision points, deferred steps) provide a far more powerful and explicit mechanism.

4. **Foreign Key Dependency**: `tasker_named_steps.dependent_system_uuid` creates a mandatory FK relationship to a vestigial table.

## Analysis Summary

### Tables to Drop

| Table | Original Intent | Why Remove |
|-------|-----------------|------------|
| `tasker_annotation_types` | Registry of annotation categories | Overlaps with `tags` JSONB; EAV-lite pattern adds complexity without benefit |
| `tasker_task_annotations` | Task-level annotations | Same as above; `tags` and `context` serve all annotation use cases |
| `tasker_dependent_systems` | External system registry | Vestigial; serves only as a label on named_steps, not a meaningful relationship |
| `tasker_dependent_system_object_maps` | Cross-system ID correlation | Observability concern, not workflow orchestration; better served by distributed tracing |

### Columns to Drop

| Table.Column | Original Intent | Why Remove |
|--------------|-----------------|------------|
| `tasker_tasks.bypass_steps` | List of steps to skip | Superseded by conditional workflows (decision points) |
| `tasker_workflow_steps.skippable` | Mark step as skippable | Superseded by conditional workflows |
| `tasker_named_tasks_named_steps.skippable` | Template-level skippable default | Superseded by conditional workflows |
| `tasker_named_steps.dependent_system_uuid` | FK to dependent_systems | Table being dropped; column serves no purpose without it |

### Indexes to Drop

| Index | Reason |
|-------|--------|
| `idx_tasker_dependent_systems_name` | Table being dropped |
| `idx_tasker_task_annotations_task_uuid` | Table being dropped |
| `idx_tasker_task_annotations_type_id` | Table being dropped |
| `idx_tasker_named_steps_system_uuid` | Column being dropped |

### Foreign Keys to Drop

| Constraint | Reason |
|------------|--------|
| `tasker_named_steps_dependent_system_uuid_fkey` | Target table being dropped |
| `tasker_task_annotations_task_uuid_fkey` | Table being dropped |
| `tasker_task_annotations_annotation_type_id_fkey` | Table being dropped |
| `tasker_dependent_system_object_maps_dependent_system_one_uuid_fkey` | Table being dropped |
| `tasker_dependent_system_object_maps_dependent_system_two_uuid_fkey` | Table being dropped |

### Elements to Keep (with rationale)

#### Legacy State Columns (Keep)

| Column | Rationale |
|--------|-----------|
| `tasker_workflow_steps.in_process` | Enables efficient partial indexes for active step queries |
| `tasker_workflow_steps.processed` | Same; `WHERE processed = false` is a hot path |
| `tasker_workflow_steps.processed_at` | Useful for analytics without joining to transitions |
| `tasker_tasks.complete` | Enables efficient `WHERE complete = false` filtering |
| `tasker_tasks.completed_at` | Useful for analytics without joining to transitions |

These columns are "denormalized for performance" - the state machine is the source of truth, but these columns enable covering indexes that significantly improve query performance for active workflow queries. The Rust state machine callbacks ensure consistency.

#### JSONB Columns (Keep, Document)

| Column | Semantic Role | Shape Contract |
|--------|---------------|----------------|
| `tasks.context` | **Workflow Input** - Ground state payload for all steps | Application-defined; passed to all handlers |
| `tasks.tags` | **Filtering/Classification** - Queryable operational metadata | Application-defined; GIN-indexed |
| `workflow_steps.inputs` | **Step Input** - Polymorphic by step type | Determined by handler type (batch cursor, decision params, etc.) |
| `workflow_steps.results` | **Step Output** - Standardized execution result | `StepExecutionResult` struct |
| `workflow_steps.checkpoint` | **Resumption State** - Handler-driven batch progress | `CheckpointData` struct |
| `named_tasks.configuration` | **Template Settings** - Lifecycle thresholds, defaults | Lifecycle config with GIN index on `lifecycle` path |

**JSONB Design Decision**: Structural validation belongs at the application layer (Rust structs, Pydantic models, etc.), not database constraints. This provides flexibility during rapid iteration while maintaining type safety where it matters (in code).

#### Named Steps Structure (Keep)

The current `named_steps` table with only name/description is intentionally minimal. Step configuration belongs on `named_tasks_named_steps` (the join table) because step behavior is context-dependent—the same step type may have different retry policies in different task templates.

## Implementation Plan

### Phase 1: Schema Changes

Since this is a greenfield pre-alpha project with no production deployments, these changes are implemented by modifying the migration baseline rather than adding DROP migrations.

**When coordinating with TAS-128**: The flattened `001_schema_and_tables.sql` should simply not include the dropped tables/columns. This results in a clean schema without migration noise.

**If implemented standalone**: Create a migration that explicitly drops the elements with clear documentation.

```sql
-- TAS-136: Remove legacy schema elements from Rails Engine prototype
-- See docs/ticket-specs/TAS-136.md for full rationale

-- Drop annotation system (superseded by tasks.tags JSONB)
DROP TABLE IF EXISTS tasker_task_annotations CASCADE;
DROP TABLE IF EXISTS tasker_annotation_types CASCADE;

-- Drop dependent systems (vestigial categorization, not meaningful relationship)
DROP TABLE IF EXISTS tasker_dependent_system_object_maps CASCADE;
ALTER TABLE tasker_named_steps DROP COLUMN IF EXISTS dependent_system_uuid;
DROP TABLE IF EXISTS tasker_dependent_systems CASCADE;

-- Drop deprecated workflow control columns (superseded by conditional workflows)
ALTER TABLE tasker_tasks DROP COLUMN IF EXISTS bypass_steps;
ALTER TABLE tasker_workflow_steps DROP COLUMN IF EXISTS skippable;
ALTER TABLE tasker_named_tasks_named_steps DROP COLUMN IF EXISTS skippable;
```

### Phase 2: Rust Code Cleanup

Remove all references to dropped schema elements from Rust codebase.

#### Models to Remove/Modify

| File | Change |
|------|--------|
| `tasker-shared/src/models/core/annotation_type.rs` | Delete file |
| `tasker-shared/src/models/core/task_annotation.rs` | Delete file |
| `tasker-shared/src/models/core/dependent_system.rs` | Delete file |
| `tasker-shared/src/models/core/dependent_system_object_map.rs` | Delete file |
| `tasker-shared/src/models/core/named_step.rs` | Remove `dependent_system_uuid` field |
| `tasker-shared/src/models/core/task.rs` | Remove `bypass_steps` field |
| `tasker-shared/src/models/core/workflow_step.rs` | Remove `skippable` field |
| `tasker-shared/src/models/core/mod.rs` | Remove module exports |

#### Scopes to Update

| File | Change |
|------|--------|
| `db/query-scopes/tasker_named_step_scopes.sql` | Remove dependent_system joins/columns |

### Phase 3: Worker SDK Cleanup

Remove references from polyglot worker implementations.

#### Ruby (`workers/ruby/`)
- Remove any `DependentSystem` model references
- Remove `skippable` from step context types
- Remove `bypass_steps` from task types

#### Python (`workers/python/`)
- Remove any `DependentSystem` Pydantic models
- Remove `skippable` from step types
- Remove `bypass_steps` from task types

#### TypeScript (`workers/typescript/`)
- Remove any `DependentSystem` interfaces
- Remove `skippable` from step types
- Remove `bypass_steps` from task types

### Phase 4: Documentation Updates

#### Architecture Documentation

Create or update `docs/architecture/schema-design.md` with:

1. **JSONB Column Semantics**: Document the role and shape contracts for each JSONB column
2. **Inputs Polymorphism**: Explain that `workflow_steps.inputs` shape is determined by handler type
3. **Denormalized State Columns**: Document that `complete`, `processed`, `in_process` are performance optimizations maintained by state machine callbacks
4. **Design Decisions**: Capture the rationale for keeping certain elements

#### Migration Comments

Add comprehensive comments to the flattened migration explaining:
- Why certain JSONB columns exist and their contracts
- Why legacy state columns are kept (performance)
- Reference to architecture documentation

### Phase 5: Test Updates

- Remove any tests that reference dropped tables/columns
- Verify all SQLx queries compile after changes
- Run full test suite

## Code Search Patterns

Use these patterns to find all references that need updating:

```bash
# Find dependent_system references
rg -l "dependent_system" --type rust --type sql --type ruby --type python --type ts

# Find annotation references
rg -l "annotation_type|task_annotation" --type rust --type sql --type ruby --type python --type ts

# Find bypass_steps references
rg -l "bypass_steps" --type rust --type sql --type ruby --type python --type ts

# Find skippable references (careful: may have legitimate uses in other contexts)
rg -l "skippable" --type rust --type sql --type ruby --type python --type ts
```

## Alternative Approaches Considered

### Dependent Systems → String Category

**Considered**: Replace `dependent_system_uuid` FK with `system_category varchar(64)` to preserve categorization capability.

**Rejected**: The categorization adds no value to the current architecture. If categorization is needed in the future, it can be added to handler metadata or step tags. Removing the concept entirely is cleaner.

### Keep Object Maps for Observability

**Considered**: Migrate `dependent_system_object_maps` to a separate observability schema.

**Rejected**: Cross-system ID correlation is better handled by distributed tracing (correlation_id, OpenTelemetry). Adding a separate schema for a vestigial pattern adds complexity. Future observability needs should be addressed with purpose-built solutions.

### Database-Level JSON Schema Validation

**Considered**: Add CHECK constraints with JSON Schema validation for JSONB columns.

**Rejected**: Maintenance overhead and migration burden outweigh benefits at this stage. Application-layer validation with Rust structs, Pydantic models, etc. provides equivalent safety with more flexibility. Can be revisited when schema stabilizes.

## Validation Checklist

### Schema Validation
- [ ] Tables dropped: `annotation_types`, `task_annotations`, `dependent_systems`, `dependent_system_object_maps`
- [ ] Columns dropped: `bypass_steps`, `skippable` (on steps), `skippable` (on ntns), `dependent_system_uuid`
- [ ] Indexes dropped: All indexes on dropped tables/columns
- [ ] Foreign keys dropped: All FKs to dropped tables

### Code Validation
- [ ] `cargo sqlx prepare --workspace` succeeds
- [ ] `cargo build --workspace` succeeds
- [ ] `cargo test --workspace` passes
- [ ] No compiler warnings about missing fields

### Documentation Validation
- [ ] `docs/architecture/schema-design.md` exists with JSONB documentation
- [ ] Migration comments explain design decisions
- [ ] Any architecture docs referencing dropped elements are updated

### Cross-Language Validation
- [ ] Ruby worker compiles without dependent_system/skippable/bypass_steps references
- [ ] Python worker passes type checks without dropped types
- [ ] TypeScript worker compiles without dropped interfaces

## Success Criteria

1. ✅ No tables exist for annotations or dependent systems
2. ✅ No `bypass_steps` or `skippable` columns exist in schema
3. ✅ `named_steps` table has no FK to dependent_systems
4. ✅ All Rust code compiles without references to dropped elements
5. ✅ All worker SDKs compile/pass type checks
6. ✅ Full test suite passes
7. ✅ JSONB column semantics documented in architecture docs
8. ✅ Migration comments explain schema design decisions

## Appendix: Full List of Dropped Elements

### Tables (4)
```
tasker_annotation_types
tasker_task_annotations
tasker_dependent_systems
tasker_dependent_system_object_maps
```

### Columns (4)
```
tasker_tasks.bypass_steps
tasker_workflow_steps.skippable
tasker_named_tasks_named_steps.skippable
tasker_named_steps.dependent_system_uuid
```

### Indexes (4)
```
idx_tasker_dependent_systems_name
idx_tasker_task_annotations_task_uuid
idx_tasker_task_annotations_type_id
idx_tasker_named_steps_system_uuid
```

### Foreign Keys (5)
```
tasker_named_steps_dependent_system_uuid_fkey
tasker_task_annotations_task_uuid_fkey
tasker_task_annotations_annotation_type_id_fkey
tasker_dependent_system_object_maps_dependent_system_one_uuid_fkey
tasker_dependent_system_object_maps_dependent_system_two_uuid_fkey
```

### Sequences (2)
```
tasker_annotation_types_annotation_type_id_seq
tasker_task_annotations_task_annotation_id_seq
```

### Unique Constraints (3)
```
tasker_annotation_types_name_key
tasker_annotation_types_name_unique
tasker_dependent_systems_name_key
tasker_dependent_systems_name_unique
```
