# TAS-149: Shared PGMQ Listener Architecture

## Summary

Refactor `PgmqMessagingService` to use a single shared `PgmqNotifyListener` instead of creating new listeners on each `subscribe_many()` call.

## Current State

**Location**: `tasker-shared/src/messaging/service/providers/pgmq.rs`

Currently, each call to `subscribe_many()` creates a new `PgmqNotifyListener`:

```rust
fn subscribe_many(&self, queue_names: &[&str]) -> Result<Vec<(String, NotificationStream)>, MessagingError> {
    // ...
    tokio::spawn(async move {
        // Creates NEW listener per call
        let mut listener = PgmqNotifyListener::new(pool, config, buffer_size).await?;
        listener.connect().await?;
        // ...
    });
}
```

This works correctly but is suboptimal if `subscribe_many()` is called multiple times.

## Problem It Solves

1. **Resource Efficiency**: One PostgreSQL connection for ALL subscriptions across the service lifetime
2. **Consistent Configuration**: Listener uses same pool config as the `PgmqClient`
3. **Dynamic Subscriptions**: Future support for adding/removing subscriptions at runtime

## Proposed Architecture

Add a `SharedListenerManager` to `PgmqMessagingService`:

```rust
pub struct PgmqMessagingService {
    client: PgmqClient,
    shared_listener: SharedListenerManager,
}

struct SharedListenerManager {
    pool: PgPool,
    config: PgmqNotifyConfig,
    command_tx: mpsc::Sender<ListenerCommand>,
    subscribers: Arc<RwLock<HashMap<String, mpsc::Sender<MessageNotification>>>>,
    started: AtomicBool,
}

enum ListenerCommand {
    AddChannel(String),
    AddSubscriber { queue: String, tx: mpsc::Sender<MessageNotification> },
    RemoveSubscriber(String),
}
```

The listener task uses `tokio::select!` to handle:
- Control commands (add/remove channels and subscribers)
- PostgreSQL notifications (dispatch to appropriate subscribers)

## Current Mitigation (TAS-133)

The `subscribe_many()` implementation already solves the critical issue:
- **Before**: N queues = N connections (pool exhaustion with 20+ namespaces)
- **After**: N queues = 1 connection per `subscribe_many()` call

Since `subscribe_many()` is called once at startup per service, the current implementation is adequate. This ticket tracks the architectural improvement for future needs.

## Implementation Notes

- `PgmqNotifyListener` methods take `&mut self`, requiring interior mutability for sharing
- `listen_with_handler()` is a blocking loop - need custom event loop with `select!`
- Consider lazy initialization via `OnceCell` or similar

## Priority

Low - Current implementation works correctly for startup-time subscriptions. This becomes important if we need runtime subscription management.
