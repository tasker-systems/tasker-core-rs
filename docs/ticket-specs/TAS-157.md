# TAS-157: Database Pattern Optimizations

**Date:** 2026-01-20
**Status:** Ready for Implementation
**Priority:** Low (Performance Optimization)
**Branch:** `jcoletaylor/tas-157-db-pattern-optimizations`
**Parent:** TAS-73 (Resiliency and Redundancy)

---

## Overview

During the TAS-73 codebase audit for connection pool deadlock patterns, we identified several areas where database access patterns could be optimized. These are **not correctness issues** - all code paths are safe and produce correct results. However, under extreme load, these patterns result in more database round-trips than necessary.

This ticket addresses performance optimizations that reduce database connection pressure by:
1. Caching loaded entities within request scope
2. Eliminating redundant lookups
3. Batching sequential queries where possible

---

## Findings

### Finding 1: Message Handler Sequential Database Operations

**File:** `tasker-orchestration/src/orchestration/lifecycle/result_processing/message_handler.rs`
**Risk Level:** Medium (performance under high concurrency)

#### Current Pattern

The `handle_step_result_message()` method performs multiple sequential database calls:

```
handle_step_result_message()
├── metadata_processor.process_metadata()
│   └── backoff_calculator.calculate_and_apply_backoff() [DB]
├── state_transition_handler.process_state_transition() [DB]
├── process_decision_point_if_needed()
│   ├── WorkflowStep::find_by_id() [DB]
│   ├── Task::find_by_id() [DB]
│   ├── task.for_orchestration() [DB] ← Nested query
│   ├── NamedStep::find_by_uuid() [DB]
│   └── task_handler_registry.get_task_template_from_registry() [DB]
└── process_batch_outcome_if_needed()
    ├── WorkflowStep::find_by_id() [DB]
    ├── Task::find_by_id() [DB]
    ├── task.for_orchestration() [DB] ← Nested query (duplicate)
    ├── NamedStep::find_by_uuid() [DB]
    └── task_handler_registry.get_task_template_from_registry() [DB]
```

#### Issues Identified

1. **Lines 500-506**: `task.for_orchestration(self.context.database_pool())` acquires a connection while task is already loaded
2. **Lines 730-737**: Same pattern repeated in `is_batchable_step()`
3. **Lines 808-818**: `get_correlation_id_for_step()` makes TWO sequential queries

#### Recommended Fix

Create a `ResultProcessingContext` struct that caches loaded entities:

```rust
struct ResultProcessingContext {
    workflow_step: Option<WorkflowStep>,
    task: Option<Task>,
    task_for_orchestration: Option<TaskForOrchestration>,
    named_step: Option<NamedStep>,
    task_template: Option<Arc<TaskTemplate>>,
}

impl ResultProcessingContext {
    async fn get_task(&mut self, pool: &PgPool, task_uuid: Uuid) -> Result<&Task> {
        if self.task.is_none() {
            self.task = Some(Task::find_by_id(pool, task_uuid).await?);
        }
        Ok(self.task.as_ref().unwrap())
    }

    // Similar methods for other entities...
}
```

**Estimated Improvement:** 4-6 fewer DB round-trips per step result under decision point/batch scenarios.

---

### Finding 2: Task Coordinator State Machine Call Chain

**File:** `tasker-orchestration/src/orchestration/lifecycle/result_processing/task_coordinator.rs`
**Risk Level:** Medium-High (blocking chains at finalization)

#### Current Pattern

```
coordinate_task_finalization()
├── WorkflowStep::find_by_id() [DB]
└── check_and_finalize_task()
    ├── TaskStateMachine::for_task() [DB - creates state machine]
    │   └── Internal DB query for current state
    ├── task_state_machine.current_state() [DB query]
    ├── task_state_machine.transition() [DB transaction]
    └── finalize_task()
        └── task_finalizer.finalize_task()
            ├── Task::find_by_id() [DB] ← Redundant
            ├── ExecutionContextProvider.get_task_execution_context()
            │   └── TaskExecutionContext::get_for_task() [DB - SQL function]
            └── Multiple state handler calls [More DB operations]
```

#### Issues Identified

1. **Lines 59-94**: Chain of state machine operations each acquiring connections
2. **Lines 382-395**: Task is looked up multiple times through the chain
3. State machine creation and state queries could be combined

#### Recommended Fix

Pass task context through the finalization chain:

```rust
struct TaskFinalizationContext {
    task: Task,
    task_for_orchestration: TaskForOrchestration,
    execution_context: TaskExecutionContext,
}

impl TaskCoordinator {
    async fn check_and_finalize_task(
        &self,
        task_uuid: Uuid,
        ctx: &mut TaskFinalizationContext,  // Pass context through
    ) -> Result<()> {
        // Use ctx.task instead of re-fetching
    }
}
```

**Estimated Improvement:** 2-3 fewer DB round-trips per task finalization.

---

### Finding 3: State Handlers Redundant Task Lookups

**File:** `tasker-orchestration/src/orchestration/lifecycle/task_finalization/state_handlers.rs`
**Risk Level:** Medium-High (double-loading task context)

#### Current Pattern

```
handle_ready_steps_state()
├── get_state_machine_for_task()
│   └── completion_handler.get_state_machine_for_task() [DB]
├── state_machine.current_state() [DB query]
├── state_machine.transition() [DB transaction]
├── sql_executor.get_task_ready_info() [DB]
└── step_enqueuer_service.process_single_task_from_ready_info()
    ├── ViableStepDiscovery operations [DB queries]
    ├── Multiple WorkflowStep operations
    └── pgmq enqueue operations [DB]
```

#### Issues Identified

1. **Lines 197-200**: `blocked_by_errors()` called after already acquiring state machine
2. `ExecutionContextProvider.blocked_by_errors()` performs its own `Task::find_by_id()` even though the task was already loaded by the caller

#### Recommended Fix

**Option A:** Accept task_uuid only in `blocked_by_errors()` since caller already has the task:

```rust
// Current (redundant lookup)
pub async fn blocked_by_errors(&self, task_uuid: Uuid) -> Result<bool> {
    let task = Task::find_by_id(self.pool, task_uuid).await?;  // Redundant!
    let ctx = self.get_task_execution_context(task_uuid).await?;
    // ...
}

// Improved (accept pre-loaded task)
pub async fn blocked_by_errors(&self, task: &Task) -> Result<bool> {
    let ctx = self.get_task_execution_context(task.task_uuid).await?;
    // ...
}
```

**Option B:** Cache execution context at handler level.

**Estimated Improvement:** 1-2 fewer DB round-trips per state handler invocation.

---

### Finding 4: Correlation ID Double Query

**File:** `tasker-orchestration/src/orchestration/lifecycle/result_processing/message_handler.rs`
**Lines:** 808-818

#### Current Pattern

```rust
async fn get_correlation_id_for_step(&self, step_uuid: Uuid) -> Result<Option<String>> {
    let step = WorkflowStep::find_by_id(self.pool, step_uuid).await?;  // Query 1
    let task = Task::find_by_id(self.pool, step.task_uuid).await?;     // Query 2
    Ok(task.correlation_id)
}
```

#### Recommended Fix

Single query with JOIN:

```rust
async fn get_correlation_id_for_step(&self, step_uuid: Uuid) -> Result<Option<String>> {
    sqlx::query_scalar!(
        r#"
        SELECT t.correlation_id
        FROM workflow_steps ws
        JOIN tasks t ON t.task_uuid = ws.task_uuid
        WHERE ws.workflow_step_uuid = $1
        "#,
        step_uuid
    )
    .fetch_optional(self.pool)
    .await
}
```

**Estimated Improvement:** 1 fewer DB round-trip per correlation ID lookup.

---

## Implementation Plan

### Phase 1: Low-Hanging Fruit (Quick Wins)

1. **Correlation ID JOIN** - Single query optimization
   - File: `message_handler.rs:808-818`
   - Effort: Small
   - Impact: 1 round-trip saved per lookup

2. **blocked_by_errors signature change** - Accept `&Task` instead of `Uuid`
   - File: `execution_context_provider.rs`
   - Effort: Small (signature change + caller updates)
   - Impact: 1-2 round-trips saved per call

### Phase 2: Context Caching

3. **ResultProcessingContext** - Cache entities within step result processing
   - File: `message_handler.rs`
   - Effort: Medium
   - Impact: 4-6 round-trips saved per decision point/batch step

4. **TaskFinalizationContext** - Pass context through finalization chain
   - Files: `task_coordinator.rs`, `state_handlers.rs`, `completion_handler.rs`
   - Effort: Medium-Large
   - Impact: 2-3 round-trips saved per finalization

### Phase 3: Batching (Future)

5. **Batch step lookups** - When processing multiple steps, batch queries
   - Effort: Large
   - Impact: Significant under high throughput

---

## Success Criteria

1. All existing tests continue to pass
2. No new database connections required per operation
3. Measurable reduction in DB round-trips (observable via query logging)
4. No regression in cluster test performance

---

## Testing Approach

1. **Unit tests** - Verify cached entities return same values as fresh lookups
2. **Integration tests** - Ensure no behavioral changes
3. **Performance validation** - Run cluster tests before/after, compare timing
4. **Query count validation** - Enable query logging, count queries per operation

---

## Non-Goals

- This ticket does NOT address connection pool sizing (already optimized in TAS-73)
- This ticket does NOT implement Redis/memcached caching (separate ticket)
- This ticket does NOT change transaction boundaries (correctness preserved)

---

## Related Documentation

- [Connection Pool Deadlock Pattern](./TAS-73/connection-pool-deadlock-pattern.md)
- [TAS-73 Research Findings](./TAS-73/research-findings.md)
- [Actors Architecture](../architecture/actors.md)

---

## Appendix: Query Count Estimates

| Scenario | Current Queries | After Optimization | Savings |
|----------|-----------------|-------------------|---------|
| Simple step result | 3-4 | 3-4 | 0 |
| Decision point step | 10-12 | 5-6 | ~50% |
| Batch outcome step | 10-12 | 5-6 | ~50% |
| Task finalization | 8-10 | 5-6 | ~40% |
| Correlation ID lookup | 2 | 1 | 50% |

These optimizations will have the most impact under high concurrency where connection pool pressure matters most.
