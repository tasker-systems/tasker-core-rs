# TAS-128: PostgreSQL 18 Migration, Schema Flattening, and Namespace Refactoring

## Summary

Upgrade to PostgreSQL 18 with native UUIDv7 support, flatten accumulated migrations into a clean three-file structure, migrate from `public` schema to a dedicated `tasker` schema, and simplify table naming by removing redundant `tasker_` prefixes. Maintain matrix compatibility with PostgreSQL 17 for production flexibility.

## Relationship to Other Tickets

| Ticket | Relationship | Status |
|--------|-------------|--------|
| **TAS-78** | Created `migrations/tasker/` and `migrations/pgmq/` split structure | Complete |
| **TAS-133** | Message service abstraction (RabbitMQ support) | Upcoming |

This ticket builds on TAS-78's migration directory restructuring and should be completed before TAS-133 to ensure a clean schema foundation.

## Problem Statement

The current database infrastructure has several areas for improvement:

1. **PostgreSQL Version**: Using pg17-pgmq base image with a custom-built `pg_uuidv7` extension. PostgreSQL 18 includes native UUIDv7 support via the `uuidv7()` function, eliminating the need for extension compilation.

2. **Migration Accumulation**: 12+ migration files have accumulated in `migrations/tasker/`, making it difficult to understand the current schema state and increasing migration runtime.

3. **Schema Namespace**: All tables reside in the `public` schema. A dedicated `tasker` schema would provide better isolation and clearer ownership when Tasker is installed alongside other applications.

4. **Table Naming Redundancy**: Tables use `tasker_` prefix (e.g., `tasker_tasks`, `tasker_workflow_steps`) which becomes redundant when using a `tasker` schema.

5. **UUID Function Inconsistency**: Code uses `uuid_generate_v7()` (from pg_uuidv7 extension) but pg18 native function is `uuidv7()`.

6. **Legacy Migration Cleanup**: Root `migrations/` directory still contains original migration files that should be archived (TAS-78 created the split structure but didn't clean up originals).

## Current State Analysis

### Docker/Database Configuration

**Current Dockerfile** (`docker/db/Dockerfile`):
- Base image: `ghcr.io/pgmq/pg17-pgmq:v1.5.1`
- Compiles and installs `pg_uuidv7` extension from source
- Extension provides `uuid_generate_v7()` function

**Target pg18 Image**:
- `ghcr.io/pgmq/pg18-pgmq:v1.8.1` (PGMQ v1.8.0+ required for pg18 support)
- PostgreSQL 18 has native `uuidv7()` function
- No extension compilation needed

### Rust Dependencies

| Crate | Current | Target | Notes |
|-------|---------|--------|-------|
| `pgmq` | 0.31.1 | 0.31.2 | Minor update, no breaking changes |
| `pgmq-notify` | internal | N/A | Uses standard pgmq API, compatible |

### Migration Directory Structure (Post-TAS-78)

```
migrations/
├── tasker/                              # Tasker-specific migrations (12 files)
│   ├── 20250810140000_uuid_v7_initial_schema.sql
│   ├── 20250912000000_tas41_richer_task_states.sql
│   ├── ... (10 more)
│   └── 20260102000000_add_checkpoint_column.sql
├── pgmq/                                # PGMQ-specific migrations (2 files)
│   ├── 20250810140001_pgmq_extensions_and_headers.sql
│   └── 20250826180921_add_pgmq_notifications.sql
├── backup/                              # Historical backups
│   └── ...
└── *.sql                                # Legacy root files (need cleanup)
```

### Current Schema Structure

**Tables** (14 tables in `public` schema with `tasker_` prefix):
- `tasker_tasks` - Main workflow instances
- `tasker_workflow_steps` - Individual workflow steps
- `tasker_task_transitions` - Task state change history
- `tasker_workflow_step_transitions` - Step state change history
- `tasker_task_namespaces` - Workflow namespace definitions
- `tasker_named_tasks` - Task type definitions
- `tasker_named_steps` - Step type definitions
- `tasker_dependent_systems` - External system integrations
- `tasker_annotation_types` - Annotation type registry
- `tasker_task_annotations` - Task annotations
- `tasker_named_tasks_named_steps` - Task-step join table
- `tasker_dependent_system_object_maps` - System object mappings
- `tasker_workflow_step_edges` - Step dependency edges
- `tasker_workflow_step_result_audit` - Step result audit (TAS-62)

**Views**:
- `tasker_step_dag_relationships` - DAG relationship view

**Functions** (10+ in `public` schema):
- `calculate_dependency_levels(uuid)`
- `get_analytics_metrics(...)`
- `get_slowest_steps(...)`
- `get_slowest_tasks(...)`
- `get_step_readiness_status(uuid, uuid[])`
- `get_step_readiness_status_batch(uuid[])`
- `get_system_health_counts()`
- `get_task_execution_context(uuid)`
- `get_task_execution_contexts_batch(uuid[])`
- `get_step_transitive_dependencies(uuid)`
- `create_step_result_audit()` (trigger function)

### Codebase Impact Analysis

**SQL references requiring updates:**
- **293 occurrences** across **39 Rust files**
- **9 query scope SQL files** in `db/query-scopes/`

Key files affected:
- `tasker-shared/src/scopes/*.rs` - Query scope implementations
- `tasker-shared/src/models/core/*.rs` - Model definitions
- `tasker-orchestration/src/orchestration/*.rs` - Orchestration services
- `tasker-worker/src/worker/*.rs` - Worker services

## Solution Design

### Phase 1: PostgreSQL 18 Docker Setup

Create separate Dockerfiles maintaining matrix compatibility.

#### `docker/db/Dockerfile.pg17` (existing, renamed)
```dockerfile
# PostgreSQL 17 with pg_uuidv7 extension
FROM ghcr.io/pgmq/pg17-pgmq:v1.5.1 AS base-with-pgmq

# ... existing build process for pg_uuidv7 extension ...

# Extension provides uuid_generate_v7() function
```

#### `docker/db/Dockerfile.pg18` (new)
```dockerfile
# PostgreSQL 18 with native UUIDv7 support
FROM ghcr.io/pgmq/pg18-pgmq:v1.8.1 AS base-with-pgmq

# No pg_uuidv7 extension needed - pg18 has native uuidv7()

# Create postgres role for pg_partman background worker compatibility
RUN echo "CREATE ROLE postgres WITH SUPERUSER LOGIN;" > /docker-entrypoint-initdb.d/01-create-postgres-role.sql

# Create compatibility alias for uuid_generate_v7()
# This allows existing migrations and code to work unchanged
RUN echo "CREATE OR REPLACE FUNCTION uuid_generate_v7() RETURNS uuid AS \$\$ SELECT uuidv7(); \$\$ LANGUAGE SQL IMMUTABLE PARALLEL SAFE;" > /docker-entrypoint-initdb.d/02-uuid_v7_alias.sql

# Test script to verify extensions work
RUN echo "SELECT uuid_generate_v7() as test_uuid_v7, 'PGMQ and UUID v7 ready!' as status;" > /docker-entrypoint-initdb.d/99-test-extensions.sql

USER postgres

LABEL description="PostgreSQL 18 with PGMQ and native UUID v7 support"
LABEL maintainer="tasker-systems"
LABEL base-image="ghcr.io/pgmq/pg18-pgmq:v1.8.1"
LABEL extensions="pgmq"

ENV POSTGRES_DB=tasker_test
ENV POSTGRES_USER=tasker
ENV POSTGRES_PASSWORD=tasker
```

#### `docker/db/Dockerfile` (symlink)
Symlink to `Dockerfile.pg18` for development (primary target). CI can choose which to build.

### Phase 2: Migration Flattening (Three-File Structure)

Consolidate 12+ migrations into three logical files using SQLx datetime naming:

```
migrations/tasker/
├── YYYYMMDDHHMMSS_schema_and_tables.sql      # Schema + table definitions
├── YYYYMMDDHHMMSS_constraints_and_indexes.sql # PKs, FKs, unique constraints, indexes
├── YYYYMMDDHHMMSS_sql_functions.sql          # All SQL functions and views
└── archived/                                  # Historical migrations (reference only)
    ├── 20250810140000_uuid_v7_initial_schema.sql
    └── ... (all existing migrations)
```

**Rationale for three-file split:**
1. **Tables first** - Can verify table structure independently
2. **Constraints/indexes separate** - FK ordering is explicit, indexes can be tuned without touching tables
3. **Functions isolated** - Functions evolve frequently; easier to update independently
4. **Verification gates** - Each file can be validated before proceeding

### Phase 3: Schema Migration (public → tasker)

Use `search_path` strategy for minimal code changes:

```sql
-- Create tasker schema
CREATE SCHEMA IF NOT EXISTS tasker;

-- Set default search path for connections
-- This allows unqualified table names in queries
ALTER DATABASE tasker SET search_path TO tasker, public;
```

**Strategy Choice**: Using `search_path = tasker, public` allows queries to use unqualified table names (e.g., `tasks` instead of `tasker.tasks`), minimizing code changes while achieving schema isolation.

### Phase 4: Table Renaming (Remove tasker_ prefix)

With the `tasker` schema providing namespacing, simplify table names:

| Current Name | New Name |
|--------------|----------|
| `tasker_tasks` | `tasks` |
| `tasker_workflow_steps` | `workflow_steps` |
| `tasker_task_transitions` | `task_transitions` |
| `tasker_workflow_step_transitions` | `workflow_step_transitions` |
| `tasker_task_namespaces` | `task_namespaces` |
| `tasker_named_tasks` | `named_tasks` |
| `tasker_named_steps` | `named_steps` |
| `tasker_dependent_systems` | `dependent_systems` |
| `tasker_annotation_types` | `annotation_types` |
| `tasker_task_annotations` | `task_annotations` |
| `tasker_named_tasks_named_steps` | `named_tasks_named_steps` |
| `tasker_dependent_system_object_maps` | `dependent_system_object_maps` |
| `tasker_workflow_step_edges` | `workflow_step_edges` |
| `tasker_workflow_step_result_audit` | `workflow_step_result_audit` |

### Phase 5: Codebase Updates

Update all SQL references throughout the codebase:

#### Query Scope Files (`db/query-scopes/`)
All 9 scope files need table name updates:
- `tasker_named_task_scopes.sql`
- `tasker_named_tasks_named_step_scopes.sql`
- `tasker_step_dag_relationship_scopes.sql`
- `tasker_task_namespace_scopes.sql`
- `tasker_task_scopes.sql`
- `tasker_task_transition_scopes.sql`
- `tasker_workflow_step_edge_scopes.sql`
- `tasker_workflow_step_scopes.sql`
- `tasker_workflow_step_transition_scopes.sql`

#### Rust SQLx Queries
With `search_path` set, table references change from `tasker_tasks` to `tasks`.

#### Documentation Updates
- Architecture docs referencing table names
- SQL examples in code comments
- README and guides

### Phase 6: CI/CD Updates

#### GitHub Actions Matrix

Update workflows to support both PostgreSQL versions:

```yaml
strategy:
  matrix:
    postgres-version: [17, 18]

steps:
  - name: Build PostgreSQL image
    uses: docker/build-push-action@v5
    with:
      file: ./docker/db/Dockerfile.pg${{ matrix.postgres-version }}
      tags: |
        ghcr.io/${{ github.repository_owner }}/tasker-pgmq:pg${{ matrix.postgres-version }}-${{ github.sha }}
```

#### Container Image References
- pg17: `ghcr.io/pgmq/pg17-pgmq:v1.5.1` (with pg_uuidv7 extension)
- pg18: `ghcr.io/pgmq/pg18-pgmq:v1.8.1` (native uuidv7)

## Implementation Plan

### Phase 1: Docker/pg18 Setup (Verification: Images build, uuid_generate_v7() works)
1. Rename `docker/db/Dockerfile` → `docker/db/Dockerfile.pg17`
2. Create `docker/db/Dockerfile.pg18` with native UUIDv7 and alias function
3. Create symlink `docker/db/Dockerfile` → `Dockerfile.pg18`
4. Update `pgmq` crate to 0.31.2 in `Cargo.toml`
5. Test both images locally with `docker build` / `podman build`
6. Verify `uuid_generate_v7()` works on both versions

### Phase 2: Legacy Migration Cleanup (Verification: Clean directory structure)
1. Move root `migrations/*.sql` files to `migrations/backup/`
2. Verify `migrations/tasker/` and `migrations/pgmq/` are the only active directories
3. Update any scripts that reference old migration paths

### Phase 3: Migration Flattening (Verification: Fresh DB applies cleanly)
1. Run local database with current migrations to capture current state
2. Export schema: `pg_dump --schema-only`
3. Generate new migrations using `cargo sqlx migrate add`:
   - `cargo sqlx migrate add schema_and_tables`
   - `cargo sqlx migrate add constraints_and_indexes`
   - `cargo sqlx migrate add sql_functions`
4. Populate migrations with transformed schema:
   - Add `tasker` schema creation
   - Rename tables (remove `tasker_` prefix)
   - Update all FK/index references
5. Move existing migrations to `migrations/tasker/archived/`
6. Test fresh database creation with new migrations

### Phase 4: Codebase Updates (Verification: cargo sqlx prepare --check passes)
1. Update 9 query scope SQL files in `db/query-scopes/`
2. Update 39 Rust files with table name changes (293 occurrences)
3. Update SQLx connection to set search_path
4. Run `cargo sqlx prepare --workspace` to regenerate query cache
5. Update documentation and code comments

### Phase 5: CI/CD Updates (Verification: CI passes on both pg17 and pg18)
1. Update GitHub Actions workflows for matrix builds
2. Update docker-compose files to reference correct Dockerfile
3. Test full CI pipeline locally

### Phase 6: Testing and Validation (Verification: All tests pass)
1. Run full test suite against pg17
2. Run full test suite against pg18
3. Verify all migrations apply cleanly on both versions
4. Verify all SQLx queries compile
5. Run E2E tests

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| SQLx query cache invalidation | High | Run `cargo sqlx prepare` after all changes, verify in CI |
| Foreign key constraint ordering | Medium | Careful ordering in constraints migration, test thoroughly |
| Missed table references in codebase | Medium | Comprehensive grep/search, CI validation |
| CI pipeline breakage | Medium | Maintain pg17 compatibility throughout, test both versions |
| PGMQ extension version mismatch | Low | Verify v1.8.1 image availability before starting |
| Performance regression | Low | Benchmark key queries before/after (optional) |

## Success Criteria

1. ✅ Both pg17 and pg18 Dockerfiles build successfully
2. ✅ `uuid_generate_v7()` works identically on both PostgreSQL versions
3. ✅ Three flattened migrations create complete schema
4. ✅ All tables exist in `tasker` schema (not `public`)
5. ✅ No `tasker_` prefix on table names within `tasker` schema
6. ✅ All SQLx queries compile and pass tests
7. ✅ CI matrix tests pass for both pg17 and pg18
8. ✅ E2E tests pass on both database versions
9. ✅ Documentation updated to reflect new schema structure
10. ✅ Legacy migrations archived, no files in root `migrations/`
11. ✅ pgmq crate updated to 0.31.2

## Migration Compatibility Note

Since this is a greenfield pre-alpha project, no backward compatibility or data migration is required. The flattened migrations create the schema from scratch. Existing development databases can be dropped and recreated.

## Future Considerations

1. **Production pg17 → pg18 Migration**: If pg17 is deployed to production before pg18 migration, a separate migration path would be needed. This spec assumes greenfield deployment.

2. **Schema Versioning**: Consider using a version prefix (e.g., `tasker_v1`) if major schema changes are anticipated.

3. **Podman Compatibility**: Podman is a drop-in replacement for Docker CLI. All Dockerfile and compose configurations work unchanged.

## Dependencies

- PostgreSQL 18 availability in pgmq base image (`ghcr.io/pgmq/pg18-pgmq:v1.8.1`)
- SQLx CLI for migration generation and query cache regeneration
- CI runner access to build and push container images

## Notes

- The UUID alias function `uuid_generate_v7()` → `uuidv7()` ensures zero code changes for UUID generation
- The `tasker` schema with `search_path` configuration allows unqualified table names in queries
- Three-file migration structure provides clear separation: tables, constraints, functions
- Matrix testing ensures both pg17 and pg18 remain supported for deployment flexibility
- PGMQ v1.8.0 added PostgreSQL 18 support; v1.8.1 includes bug fixes
