# TAS-128: PostgreSQL 18 Migration, Schema Flattening, and Namespace Refactoring

## Summary

Upgrade to PostgreSQL 18 with native UUIDv7 support, flatten accumulated migrations into a single canonical schema, migrate from `public` schema to a dedicated `tasker` schema, and simplify table naming by removing redundant `tasker_` prefixes. Maintain matrix compatibility with PostgreSQL 17 for production flexibility.

## Problem Statement

The current database infrastructure has several areas for improvement:

1. **PostgreSQL Version**: Using pg17-pgmq base image with a custom-built `pg_uuidv7` extension. PostgreSQL 18 includes native UUIDv7 support via the `uuidv7()` function, eliminating the need for extension compilation.

2. **Migration Accumulation**: 13+ migration files have accumulated since the initial schema, making it difficult to understand the current schema state and increasing migration runtime.

3. **Schema Namespace**: All tables reside in the `public` schema. A dedicated `tasker` schema would provide better isolation and clearer ownership.

4. **Table Naming Redundancy**: Tables use `tasker_` prefix (e.g., `tasker_tasks`, `tasker_workflow_steps`) which becomes redundant when using a `tasker` schema.

5. **UUID Function Inconsistency**: Code uses `uuid_generate_v7()` (from pg_uuidv7 extension) but pg18 native function is `uuidv7()`.

## Current State Analysis

### Docker/Database Configuration

**Current Dockerfile** (`docker/db/Dockerfile`):
- Base image: `ghcr.io/pgmq/pg17-pgmq:v1.5.1`
- Compiles and installs `pg_uuidv7` extension from source
- Extension provides `uuid_generate_v7()` function

**Available pg18 Image** (commented in Dockerfile):
- `ghcr.io/pgmq/pg18-pgmq:v1.7.0`
- PostgreSQL 18 has native `uuidv7()` function
- No extension compilation needed

### Migration Files (13 active + backups)

| Migration | Purpose |
|-----------|---------|
| `20250810140000_uuid_v7_initial_schema.sql` | Initial schema with UUID v7 primary keys |
| `20250826180921_add_pgmq_notifications.sql` | PGMQ notification support |
| `20250912000000_tas41_richer_task_states.sql` | Enhanced task states |
| `20250927000000_add_waiting_for_retry_state.sql` | Retry state support |
| `20251001000000_fix_permanently_blocked_detection.sql` | Blocked detection fix |
| `20251006000000_fix_retry_eligibility_logic.sql` | Retry logic fixes |
| `20251007000000_add_correlation_ids.sql` | Distributed tracing support |
| `20251010000000_add_stale_task_discovery_fixes.sql` | Stale task handling |
| `20251115000000_comprehensive_dlq_system.sql` | Dead letter queue system |
| `20251118000000_add_unique_edge_constraint.sql` | Edge uniqueness constraint |
| `20251203000000_add_step_result_audit.sql` | Step result audit trail |
| `20251207000000_fix_execution_status_priority.sql` | Execution priority fix |
| `20260102000000_add_checkpoint_column.sql` | Checkpoint support |

### Current Schema Structure

**Tables** (all in `public` schema with `tasker_` prefix):
- `tasker_tasks` - Main workflow instances
- `tasker_workflow_steps` - Individual workflow steps
- `tasker_task_transitions` - Task state change history
- `tasker_workflow_step_transitions` - Step state change history
- `tasker_task_namespaces` - Workflow namespace definitions
- `tasker_named_tasks` - Task type definitions
- `tasker_named_steps` - Step type definitions
- `tasker_dependent_systems` - External system integrations
- `tasker_annotation_types` - Annotation type registry
- `tasker_task_annotations` - Task annotations
- `tasker_named_tasks_named_steps` - Task-step join table
- `tasker_dependent_system_object_maps` - System object mappings
- `tasker_workflow_step_edges` - Step dependency edges
- `tasker_workflow_step_result_audit` - Step result audit (TAS-62)

**Views**:
- `tasker_step_dag_relationships` - DAG relationship view

**Functions** (8 in `public` schema):
- `calculate_dependency_levels(bigint)`
- `get_analytics_metrics_v01(...)`
- `get_slowest_steps_v01(...)`
- `get_slowest_tasks_v01(...)`
- `get_step_readiness_status(bigint, bigint[])`
- `get_step_readiness_status_batch(bigint[])`
- `get_system_health_counts_v01()`
- `get_task_execution_context(bigint)`
- `get_task_execution_contexts_batch(bigint[])`
- `create_step_result_audit()` (trigger function)

### UUID Function Usage

Current `uuid_generate_v7()` calls appear in:
- `migrations/20250810140000_uuid_v7_initial_schema.sql` (DEFAULT for primary keys)
- `migrations/20251007000000_add_correlation_ids.sql` (backfill existing tasks)
- `migrations/20251115000000_comprehensive_dlq_system.sql` (DLQ tables)
- `migrations/20251203000000_add_step_result_audit.sql` (audit table)
- Rust code documentation (SQL examples in comments)

## Solution Design

### Phase 1: Dual Dockerfile Support (pg17 + pg18)

Create separate Dockerfiles maintaining matrix compatibility:

#### `docker/db/Dockerfile.pg17` (existing, renamed)
```dockerfile
# PostgreSQL 17 with pg_uuidv7 extension
FROM ghcr.io/pgmq/pg17-pgmq:v1.5.1 AS base-with-pgmq

# ... existing build process for pg_uuidv7 extension ...

# Create uuid_generate_v7 function (extension provides this)
RUN echo "CREATE EXTENSION IF NOT EXISTS pg_uuidv7 CASCADE;" > /docker-entrypoint-initdb.d/02-pg_uuidv7.sql
```

#### `docker/db/Dockerfile.pg18` (new)
```dockerfile
# PostgreSQL 18 with native UUIDv7 support
FROM ghcr.io/pgmq/pg18-pgmq:v1.7.0 AS base-with-pgmq

# No pg_uuidv7 extension needed - pg18 has native uuidv7()

# Create postgres role for pg_partman background worker compatibility
RUN echo "CREATE ROLE postgres WITH SUPERUSER LOGIN;" > /docker-entrypoint-initdb.d/01-create-postgres-role.sql

# Create compatibility alias for uuid_generate_v7()
# This allows existing migrations and code to work unchanged
RUN echo "CREATE OR REPLACE FUNCTION uuid_generate_v7() RETURNS uuid AS \$\$ SELECT uuidv7(); \$\$ LANGUAGE SQL IMMUTABLE PARALLEL SAFE;" > /docker-entrypoint-initdb.d/02-uuid_v7_alias.sql

# Test script to verify extensions work
RUN echo "SELECT uuid_generate_v7() as test_uuid_v7, 'PGMQ and UUID v7 ready!' as status;" > /docker-entrypoint-initdb.d/99-test-extensions.sql

USER postgres

LABEL description="PostgreSQL 18 with PGMQ and native UUID v7 support"
LABEL maintainer="tasker-systems"
LABEL base-image="ghcr.io/pgmq/pg18-pgmq:v1.7.0"
LABEL extensions="pgmq"

ENV POSTGRES_DB=tasker_test
ENV POSTGRES_USER=tasker
ENV POSTGRES_PASSWORD=tasker
```

#### `docker/db/Dockerfile` (symlink or default)
Symlink to `Dockerfile.pg18` for development (primary target), CI can choose which to build.

### Phase 2: Schema Migration (public → tasker)

Create the `tasker` schema and migrate all objects:

```sql
-- Create tasker schema
CREATE SCHEMA IF NOT EXISTS tasker;

-- Set default search path for connections
ALTER DATABASE current_database() SET search_path TO tasker, public;

-- Migration approach: All new tables created in tasker schema
-- All function references updated to use tasker.function_name()
```

### Phase 3: Table Renaming (Remove tasker_ prefix)

With the `tasker` schema providing namespacing, simplify table names:

| Current Name | New Name |
|--------------|----------|
| `tasker_tasks` | `tasks` |
| `tasker_workflow_steps` | `workflow_steps` |
| `tasker_task_transitions` | `task_transitions` |
| `tasker_workflow_step_transitions` | `workflow_step_transitions` |
| `tasker_task_namespaces` | `task_namespaces` |
| `tasker_named_tasks` | `named_tasks` |
| `tasker_named_steps` | `named_steps` |
| `tasker_dependent_systems` | `dependent_systems` |
| `tasker_annotation_types` | `annotation_types` |
| `tasker_task_annotations` | `task_annotations` |
| `tasker_named_tasks_named_steps` | `named_tasks_named_steps` |
| `tasker_dependent_system_object_maps` | `dependent_system_object_maps` |
| `tasker_workflow_step_edges` | `workflow_step_edges` |
| `tasker_workflow_step_result_audit` | `workflow_step_result_audit` |

### Phase 4: Migration Flattening

Export current schema state and create a single canonical migration:

#### Process
1. Export current schema: `pg_dump --schema-only`
2. Clean up and reorganize:
   - Move all objects to `tasker` schema
   - Rename tables (remove `tasker_` prefix)
   - Update all function references
   - Consolidate index definitions
   - Update foreign key references
3. Create new migration: `migrations/V1__initial_schema.sql`
4. Archive old migrations to `migrations/archived/`

#### New Migration Structure
```
migrations/
├── V1__initial_schema.sql          # Complete flattened schema
├── archived/                       # Historical migrations (reference only)
│   ├── 20250810140000_uuid_v7_initial_schema.sql
│   ├── 20250826180921_add_pgmq_notifications.sql
│   └── ... (all existing migrations)
```

### Phase 5: Codebase Updates

Update all SQL references throughout the codebase:

#### Rust SQLx Queries
Search and replace patterns:
- `tasker_tasks` → `tasker.tasks` (or just `tasks` with search_path)
- `tasker_workflow_steps` → `tasker.workflow_steps`
- `public.function_name` → `tasker.function_name`

#### Query Scope Files (`db/query-scopes/`)
All 8 scope files need table name updates:
- `tasker_named_task_scopes.sql`
- `tasker_named_tasks_named_step_scopes.sql`
- `tasker_step_dag_relationship_scopes.sql`
- `tasker_task_namespace_scopes.sql`
- `tasker_task_scopes.sql`
- `tasker_task_transition_scopes.sql`
- `tasker_workflow_step_edge_scopes.sql`
- `tasker_workflow_step_scopes.sql`
- `tasker_workflow_step_transition_scopes.sql`

#### Documentation Updates
- Architecture docs referencing table names
- SQL examples in code comments
- README and guides

### Phase 6: CI/CD Updates

#### GitHub Actions Matrix

Update `build-postgres.yml` to support both versions:

```yaml
strategy:
  matrix:
    postgres-version: [17, 18]
    
steps:
  - name: Build PostgreSQL image
    uses: docker/build-push-action@v5
    with:
      file: ./docker/db/Dockerfile.pg${{ matrix.postgres-version }}
      tags: |
        ghcr.io/${{ github.repository_owner }}/tasker-pgmq:pg${{ matrix.postgres-version }}-${{ github.sha }}
```

#### Fallback Image Updates
Update fallback images in CI:
- pg17: `ghcr.io/pgmq/pg17-pgmq:v1.5.1`
- pg18: `ghcr.io/pgmq/pg18-pgmq:v1.7.0`

#### Docker Compose Updates
Update all compose files to reference the correct Dockerfile:
- `docker-compose.test.yml`
- `docker-compose.dev.yml`
- `docker-compose.ci.yml`
- `docker-compose.prod.yml`

## Implementation Plan

### Phase 1: Dual Dockerfile (1-2 hours)
1. Rename existing `docker/db/Dockerfile` → `docker/db/Dockerfile.pg17`
2. Create `docker/db/Dockerfile.pg18` with native UUIDv7 and alias function
3. Create symlink `docker/db/Dockerfile` → `Dockerfile.pg18`
4. Test both images locally with `docker build`
5. Verify `uuid_generate_v7()` works on both versions

### Phase 2: Schema Export and Analysis (2-3 hours)
1. Run local database with current migrations
2. Export schema: `pg_dump --schema-only -f db/structure.sql`
3. Analyze exported schema for transformation needs
4. Document all object names and dependencies

### Phase 3: Create Flattened Migration (3-4 hours)
1. Create `migrations/V1__initial_schema.sql`
2. Add `tasker` schema creation
3. Transform all table definitions:
   - Use `tasker` schema
   - Remove `tasker_` prefix from table names
   - Update all references (FKs, indexes, etc.)
4. Transform all function definitions
5. Add UUID compatibility function

### Phase 4: Codebase Updates (4-6 hours)
1. Update Rust model files with new table names
2. Update query scope SQL files
3. Update all sqlx queries
4. Run `cargo sqlx prepare` to regenerate query cache
5. Update documentation

### Phase 5: CI/CD Updates (2-3 hours)
1. Update GitHub Actions workflows for matrix builds
2. Update docker-compose files
3. Test full CI pipeline locally

### Phase 6: Testing and Validation (2-3 hours)
1. Run full test suite against pg17
2. Run full test suite against pg18
3. Verify all migrations apply cleanly
4. Verify all SQLx queries compile
5. Run E2E tests

## Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| SQLx query cache invalidation | Run `cargo sqlx prepare` after all changes, verify in CI |
| Foreign key constraint issues during rename | Use transaction-based migration with proper ordering |
| Missed table references in codebase | Use comprehensive grep/search before finalizing |
| CI pipeline breakage | Maintain pg17 compatibility throughout, test both versions |
| Performance regression | Benchmark key queries before/after schema changes |

## Success Criteria

1. ✅ Both pg17 and pg18 Dockerfiles build successfully
2. ✅ `uuid_generate_v7()` works identically on both PostgreSQL versions
3. ✅ Single flattened migration creates complete schema
4. ✅ All tables exist in `tasker` schema (not `public`)
5. ✅ No `tasker_` prefix on table names within `tasker` schema
6. ✅ All SQLx queries compile and pass tests
7. ✅ CI matrix tests pass for both pg17 and pg18
8. ✅ E2E tests pass on both database versions
9. ✅ Documentation updated to reflect new schema structure
10. ✅ Archived migrations preserved for historical reference

## Migration Compatibility Note

Since this is a greenfield pre-alpha project, no backward compatibility or data migration is required. The flattened migration creates the schema from scratch. Existing development databases can be dropped and recreated.

## Future Considerations

1. **Production pg17 → pg18 Migration**: If pg17 is deployed to production before pg18 migration, a separate migration path would be needed. This spec assumes greenfield deployment.

2. **Schema Versioning**: Consider using a version prefix (e.g., `tasker_v1`) if major schema changes are anticipated.

3. **Podman Compatibility**: Podman is a drop-in replacement for Docker CLI. All Dockerfile and compose configurations work unchanged. The only difference is the container runtime.

## Dependencies

- PostgreSQL 18 availability in pgmq base image (`ghcr.io/pgmq/pg18-pgmq:v1.7.0`)
- SQLx CLI for query cache regeneration
- CI runner access to build and push container images

## Notes

- The UUID alias function `uuid_generate_v7()` → `uuidv7()` ensures zero code changes for UUID generation
- The `tasker` schema with search_path configuration allows unqualified table names in queries
- Flattening migrations removes historical baggage but preserves archived copies for reference
- Matrix testing ensures both pg17 and pg18 remain supported for deployment flexibility
