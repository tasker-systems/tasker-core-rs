# TAS-148: Orchestration Command Processor Refactor

## Problem Statement

`tasker-orchestration/src/orchestration/command_processor.rs` is 1349 lines with three distinct responsibilities:
1. **Command Types**: `OrchestrationCommand` enum and result types (`TaskInitializeResult`, `StepProcessResult`, etc.)
2. **Processor**: `OrchestrationProcessor` struct managing channel lifecycle and task spawning
3. **Command Handler**: `OrchestrationProcessorCommandHandler` with `process_command()` routing and all handler methods

The `process_command()` function (line 439) follows a repetitive pattern: route to handler → update stats → send response. This pattern is repeated 14 times with nearly identical boilerplate.

### Comparison with Worker System

The worker system has a cleaner separation:
- `tasker-worker/src/worker/command_processor.rs` (~128 lines): Pure command types
- `tasker-worker/src/worker/actor_command_processor.rs` (~579 lines): Actor-based command routing

## Goals

1. **Separate command types from command handling** for clarity and maintainability
2. **Unify processor and handler** into the actor pattern used throughout the codebase
3. **Reduce boilerplate** in the repetitive `process_command()` routing function

## Proposed Solution

### File Structure

```
tasker-orchestration/src/orchestration/
├── commands/
│   ├── mod.rs              # Module exports
│   └── types.rs            # OrchestrationCommand, result types, stats (~175 lines)
└── mod.rs                  # Re-exports for backward compatibility

tasker-orchestration/src/actors/
├── command_processor_actor.rs  # New actor combining processor + handler (~400 lines)
└── mod.rs                      # Add export
```

This structure:
- Follows the existing actor pattern in `tasker-orchestration/src/actors/`
- Mirrors the worker's separation of command types from processing
- Keeps command types in the orchestration module (they're orchestration-specific)
- Places the actor in the actors module (consistent with other actors)

### Phase 1: Extract Command Types to `orchestration/commands/types.rs`

Move the following from `command_processor.rs`:

```rust
// Types to extract (~175 lines total)
pub type CommandResponder<T> = oneshot::Sender<TaskerResult<T>>;

pub enum OrchestrationCommand { ... }      // Lines 44-126
pub enum TaskInitializeResult { ... }       // Lines 129-134
pub enum StepProcessResult { ... }          // Lines 136-141
pub struct TaskReadinessResult { ... }      // Lines 144-152
pub enum TaskFinalizationResult { ... }     // Lines 154-168
pub struct OrchestrationProcessingStats { ... }  // Lines 170-178
pub struct SystemHealth { ... }             // Lines 184-222
```

### Phase 2: Create `actors/command_processor_actor.rs`

Create a new actor that combines `OrchestrationProcessor` and `OrchestrationProcessorCommandHandler`:

```rust
/// TAS-133: Actor-based orchestration command processor
///
/// Combines OrchestrationProcessor (channel management) and
/// OrchestrationProcessorCommandHandler (command routing) into
/// a single actor following the TAS-46 actor pattern.
pub struct OrchestrationCommandProcessorActor {
    // Core dependencies (from OrchestrationProcessor)
    context: Arc<SystemContext>,
    actors: Arc<ActorRegistry>,
    message_client: Arc<MessageClient>,
    health_caches: HealthStatusCaches,
    channel_monitor: ChannelMonitor,
    
    // Stats tracking (from OrchestrationProcessorCommandHandler)
    stats: Arc<std::sync::RwLock<OrchestrationProcessingStats>>,
    
    // Hydrators (from OrchestrationProcessorCommandHandler)
    step_result_hydrator: StepResultHydrator,
    task_request_hydrator: TaskRequestHydrator,
    finalization_hydrator: FinalizationHydrator,
}
```

#### Simplified Command Routing

Replace the repetitive `process_command()` with a cleaner pattern using a helper:

```rust
impl OrchestrationCommandProcessorActor {
    /// Process command with stats tracking
    async fn process_command(&self, command: OrchestrationCommand) {
        match command {
            OrchestrationCommand::InitializeTask { request, resp } => {
                self.execute_with_stats(
                    || self.handle_initialize_task(request),
                    |stats| &mut stats.task_requests_processed,
                    resp,
                ).await;
            }
            // ... other commands follow same pattern
        }
    }
    
    /// Execute handler with automatic stats tracking and response sending
    async fn execute_with_stats<T, F, Fut>(
        &self,
        handler: F,
        stat_selector: impl FnOnce(&mut OrchestrationProcessingStats) -> &mut u64,
        resp: CommandResponder<T>,
    )
    where
        F: FnOnce() -> Fut,
        Fut: Future<Output = TaskerResult<T>>,
    {
        let result = handler().await;
        {
            let mut stats = self.stats.write().unwrap_or_else(|p| p.into_inner());
            if result.is_ok() {
                *stat_selector(&mut stats) += 1;
            } else {
                stats.processing_errors += 1;
            }
        }
        let _ = resp.send(result);
    }
}
```

### Phase 3: Update Module Exports

#### `orchestration/commands/mod.rs`
```rust
//! Orchestration command types and result structures
pub mod types;
pub use types::*;
```

#### `orchestration/mod.rs`
```rust
// Command types module
pub mod commands;

// Re-export command types at orchestration level
pub use commands::{
    CommandResponder, OrchestrationCommand, OrchestrationProcessingStats,
    StepProcessResult, SystemHealth, TaskFinalizationResult, TaskInitializeResult,
    TaskReadinessResult,
};
```

#### `actors/mod.rs`
```rust
pub mod command_processor_actor;
pub use command_processor_actor::OrchestrationCommandProcessorActor;
```

### Phase 4: Migrate Callers and Remove Legacy

Update all callers of `OrchestrationProcessor` to use `OrchestrationCommandProcessorActor`:
- `OrchestrationCore` in `core.rs`
- `OrchestrationBootstrap` in `bootstrap.rs`
- Any tests referencing the old types

Then delete `orchestration/command_processor.rs`.

The actor's public interface remains similar:
```rust
// Old: OrchestrationProcessor::new() -> (Self, Sender)
// New: OrchestrationCommandProcessorActor::new() -> (Self, Sender)
```

## File Size Estimates

| File | Lines | Purpose |
|------|-------|---------|
| `commands/types.rs` | ~175 | Command enum, result types, stats |
| `commands/mod.rs` | ~10 | Module exports |
| `actors/command_processor_actor.rs` | ~400 | Combined processor + handler |

**Total**: ~585 lines (vs. 1349 original = 57% reduction)

## Testing Strategy

1. **Unit Tests**: Existing tests in `command_processor.rs` move to `command_processor_actor.rs`
2. **Integration Tests**: Verify command routing still works end-to-end
3. **Backward Compatibility**: Ensure re-exports compile with existing import paths

## Implementation Order

1. Create `orchestration/commands/` directory and extract types
2. Create `actors/command_processor_actor.rs` with combined implementation
3. Update `orchestration/mod.rs` - add `commands` module, remove `command_processor` module
4. Update `actors/mod.rs` to export new actor
5. Migrate callers in `core.rs` and `bootstrap.rs`
6. Delete old `orchestration/command_processor.rs`
7. Run full test suite (`cargo make check`)
8. Update `tasker-orchestration/AGENTS.md` to reflect new structure

## Related Documentation

- Actor pattern: `docs/architecture/actors.md`
- Worker command separation: `tasker-worker/src/worker/command_processor.rs`
- TAS-46: Original actor pattern implementation
- TAS-69: Worker actor-based command processor
