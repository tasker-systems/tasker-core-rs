# Tasker Configuration Reference — common
# Environment: production
#
# This is an annotated configuration file showing all available parameters
# with their default values and documentation.
#
# Generate a deployable config: tasker-cli config generate
# Look up a parameter:         tasker-cli docs explain -p <path>


# ─────────────────────────────────────────────────────────────
# backoff
# ─────────────────────────────────────────────────────────────
[common.backoff]
# Multiplier applied to the previous delay for exponential backoff calculations
# Type: f64 | Range: 1.0-10.0
backoff_multiplier = 2.0
# Sequence of backoff delays in seconds for successive retry attempts
# Type: Vec<u32> | Range: non-empty array of positive integers
default_backoff_seconds = [1, 5, 15, 30, 60]
# Add random jitter to backoff delays to prevent thundering herd on retry
# Type: bool | Range: true/false
jitter_enabled = true
# Maximum jitter as a fraction of the computed backoff delay
# Type: f64 | Range: 0.0-1.0
jitter_max_percentage = 0.15
# Hard upper limit on any single backoff delay
# Type: u32 | Range: 1-3600
max_backoff_seconds = 3600


# reenqueue_delays
[common.backoff.reenqueue_delays]
# Delay in seconds before re-evaluating a task that is blocked due to step failures
# Type: u32 | Range: 0-3600
blocked_by_failures = 120
# Delay in seconds before re-enqueueing a task stuck in the EnqueuingSteps state
# Type: u32 | Range: 0-300
enqueuing_steps = 5
# Delay in seconds before re-evaluating a task stuck in the EvaluatingResults state
# Type: u32 | Range: 0-300
evaluating_results = 10
# Delay in seconds before re-enqueueing a task stuck in the Initializing state
# Type: u32 | Range: 0-300
initializing = 10
# Delay in seconds before re-checking a task whose steps are still being processed
# Type: u32 | Range: 0-300
steps_in_process = 15
# Delay in seconds before re-checking a task that is waiting for upstream step dependencies
# Type: u32 | Range: 0-3600
waiting_for_dependencies = 60
# Delay in seconds before re-processing a task that is waiting for step retries
# Type: u32 | Range: 0-3600
waiting_for_retry = 30

# ─────────────────────────────────────────────────────────────
# cache
# ─────────────────────────────────────────────────────────────
[common.cache]
# Time-to-live in seconds for cached analytics and metrics data
# Type: u32 | Range: 1-3600
analytics_ttl_seconds = 60
# Cache backend implementation: 'redis' (distributed) or 'moka' (in-process)
# Type: String | Range: redis | moka
backend = "redis"
# Default time-to-live in seconds for cached entries
# Type: u32 | Range: 1-86400
default_ttl_seconds = 3600
# Enable the distributed cache layer for template and analytics data
# Type: bool | Range: true/false
enabled = false
# Prefix applied to all cache keys to namespace entries
# Type: String | Range: non-empty string
key_prefix = "tasker"
# Time-to-live in seconds for cached task template definitions
# Type: u32 | Range: 1-86400
template_ttl_seconds = 3600


# moka
[common.cache.moka]
# Maximum number of entries the in-process Moka cache can hold
# Type: u64 | Range: 1-1000000
max_capacity = 10000

# redis
[common.cache.redis]
# Maximum time to wait when establishing a new Redis connection
# Type: u32 | Range: 1-60
connection_timeout_seconds = 5
# Redis database number (0-15)
# Type: u32 | Range: 0-15
database = 0
# Maximum number of connections in the Redis connection pool
# Type: u32 | Range: 1-500
max_connections = 10
# Redis connection URL
# Type: String | Range: valid Redis URI
url = "${REDIS_URL:-redis://localhost:6379}"

# ─────────────────────────────────────────────────────────────
# circuit_breakers
# ─────────────────────────────────────────────────────────────
[common.circuit_breakers]
# Master switch for the circuit breaker subsystem
# Type: bool | Range: true/false
enabled = true


# component_configs

[common.circuit_breakers.component_configs.cache]
# Failures before the cache circuit breaker trips to Open
# Type: u32 | Range: 1-100
failure_threshold = 5
# Successes in Half-Open required to close the cache breaker
# Type: u32 | Range: 1-100
success_threshold = 2
# Time the cache breaker stays Open before probing
# Type: u32 | Range: 1-300
timeout_seconds = 15

[common.circuit_breakers.component_configs.pgmq]
# Failures before the PGMQ circuit breaker trips to Open
# Type: u32 | Range: 1-100
failure_threshold = 5
# Successes in Half-Open required to close the PGMQ breaker
# Type: u32 | Range: 1-100
success_threshold = 2
# Time the PGMQ breaker stays Open before probing
# Type: u32 | Range: 1-300
timeout_seconds = 30

[common.circuit_breakers.component_configs.task_readiness]
# Failures before the task readiness circuit breaker trips to Open
# Type: u32 | Range: 1-100
failure_threshold = 10
# Successes in Half-Open required to close the task readiness breaker
# Type: u32 | Range: 1-100
success_threshold = 3
# Time the task readiness breaker stays Open before probing
# Type: u32 | Range: 1-300
timeout_seconds = 60

# default_config
[common.circuit_breakers.default_config]
# Number of consecutive failures before a circuit breaker trips to the Open state
# Type: u32 | Range: 1-100
failure_threshold = 5
# Number of consecutive successes in Half-Open state required to close the circuit breaker
# Type: u32 | Range: 1-100
success_threshold = 2
# Time the circuit breaker remains in Open state before transitioning to Half-Open for a probe
# Type: u32 | Range: 1-300
timeout_seconds = 30

# global_settings
[common.circuit_breakers.global_settings]
# Maximum number of circuit breaker instances that can be registered
# Type: u32 | Range: 1-1000
max_circuit_breakers = 50
# Interval in seconds between circuit breaker metrics collection sweeps
# Type: u32 | Range: 1-3600
metrics_collection_interval_seconds = 30
# Minimum time in seconds between circuit breaker state transitions
# Type: f64 | Range: 0.0-60.0
min_state_transition_interval_seconds = 5.0

# ─────────────────────────────────────────────────────────────
# database
# ─────────────────────────────────────────────────────────────
[common.database]
# Database name used for display and connection verification logging
# Type: String | Range: valid PostgreSQL database name
database = "tasker_development"
# Skip database migration version check at startup
# Type: bool | Range: true/false
skip_migration_check = false
# PostgreSQL connection URL for the primary database
# Type: String | Range: valid PostgreSQL connection URI
url = "${DATABASE_URL:-postgresql://localhost/tasker}"


# pool
[common.database.pool]
# Maximum time to wait when acquiring a connection from the pool
# Type: u32 | Range: 1-300
acquire_timeout_seconds = 10
# Time before an idle connection is closed and removed from the pool
# Type: u32 | Range: 1-3600
idle_timeout_seconds = 300
# Maximum number of concurrent database connections in the pool
# Type: u32 | Range: 1-1000
max_connections = 25
# Maximum total lifetime of a connection before it is closed and replaced
# Type: u32 | Range: 60-86400
max_lifetime_seconds = 1800
# Minimum number of idle connections maintained in the pool
# Type: u32 | Range: 0-100
min_connections = 5
# Threshold in milliseconds above which connection acquisition is logged as slow
# Type: u32 | Range: 10-60000
slow_acquire_threshold_ms = 100

# variables
[common.database.variables]
# PostgreSQL statement_timeout in milliseconds, set per-connection via SET statement_timeout
# Type: u32 | Range: 100-600000
statement_timeout = 30000

# ─────────────────────────────────────────────────────────────
# execution
# ─────────────────────────────────────────────────────────────
[common.execution]
# Default timeout in seconds for establishing external connections during step execution
# Type: u32 | Range: 1-300
connection_timeout_seconds = 30
# Default maximum wall-clock time for an entire task to complete
# Type: u32 | Range: 1-86400
default_timeout_seconds = 3600
# Runtime environment identifier used for configuration context selection and logging
# Type: String | Range: test | development | production
environment = "development"
# Maximum number of steps that can be executing simultaneously across all tasks
# Type: u32 | Range: 1-1000000
max_concurrent_steps = 1000
# Maximum number of tasks that can be actively processed simultaneously
# Type: u32 | Range: 1-100000
max_concurrent_tasks = 100
# Maximum number of attempts to discover step handlers during task initialization
# Type: u32 | Range: 1-50
max_discovery_attempts = 5
# Default maximum number of retry attempts for a failed step
# Type: u32 | Range: 0-100
max_retries = 3
# Maximum number of steps allowed in a single workflow definition
# Type: u32 | Range: 1-100000
max_workflow_steps = 10000
# Number of steps to enqueue in a single batch during task initialization
# Type: u32 | Range: 1-1000
step_batch_size = 50
# Default maximum time for a single step execution before it is considered timed out
# Type: u32 | Range: 1-3600
step_execution_timeout_seconds = 600


# ─────────────────────────────────────────────────────────────
# mpsc_channels
# ─────────────────────────────────────────────────────────────


# event_publisher
[common.mpsc_channels.event_publisher]
# Bounded channel capacity for the event publisher MPSC channel
# Type: usize | Range: 100-100000
event_queue_buffer_size = 5000

# ffi
[common.mpsc_channels.ffi]
# Bounded channel capacity for Ruby FFI event delivery
# Type: usize | Range: 100-50000
ruby_event_buffer_size = 1000

# overflow_policy
[common.mpsc_channels.overflow_policy]
# Behavior when a bounded MPSC channel is full
# Type: String | Range: block | drop_oldest
drop_policy = "block"
# Channel saturation fraction at which warning logs are emitted
# Type: f64 | Range: 0.0-1.0
log_warning_threshold = 0.8

[common.mpsc_channels.overflow_policy.metrics]
# Enable periodic channel saturation metrics collection
# Type: bool | Range: true/false
enabled = true
# Interval in seconds between channel saturation metric samples
# Type: u32 | Range: 1-3600
saturation_check_interval_seconds = 30

# ─────────────────────────────────────────────────────────────
# pgmq_database
# ─────────────────────────────────────────────────────────────
[common.pgmq_database]
# Enable PGMQ messaging subsystem
# Type: bool | Range: true/false
enabled = true
# Skip PGMQ database migration version check at startup
# Type: bool | Range: true/false
skip_migration_check = false
# PostgreSQL connection URL for a dedicated PGMQ database; when empty, PGMQ shares the primary database
# Type: String | Range: valid PostgreSQL connection URI or empty string
url = "${PGMQ_DATABASE_URL:-}"


# pool
[common.pgmq_database.pool]
# Maximum time to wait when acquiring a connection from the PGMQ pool
# Type: u32 | Range: 1-300
acquire_timeout_seconds = 5
# Time before an idle PGMQ connection is closed and removed from the pool
# Type: u32 | Range: 1-3600
idle_timeout_seconds = 300
# Maximum number of concurrent connections in the PGMQ database pool
# Type: u32 | Range: 1-500
max_connections = 15
# Maximum total lifetime of a PGMQ database connection before replacement
# Type: u32 | Range: 60-86400
max_lifetime_seconds = 1800
# Minimum idle connections maintained in the PGMQ database pool
# Type: u32 | Range: 0-100
min_connections = 3
# Threshold in milliseconds above which PGMQ pool acquisition is logged as slow
# Type: u32 | Range: 10-60000
slow_acquire_threshold_ms = 100

# ─────────────────────────────────────────────────────────────
# queues
# ─────────────────────────────────────────────────────────────
[common.queues]
# Messaging backend: 'pgmq' (PostgreSQL-based, LISTEN/NOTIFY) or 'rabbitmq' (AMQP broker)
# Type: String | Range: pgmq | rabbitmq
backend = "${TASKER_MESSAGING_BACKEND:-pgmq}"
# Default number of messages to dequeue in a single batch read
# Type: u32 | Range: 1-1000
default_batch_size = 10
# Default time a dequeued message remains invisible to other consumers
# Type: u32 | Range: 1-3600
default_visibility_timeout_seconds = 30
# Interval in seconds between queue health check probes
# Type: u32 | Range: 1-3600
health_check_interval = 60
# Hard upper limit on batch size for any single dequeue operation
# Type: u32 | Range: 1-10000
max_batch_size = 100
# Template pattern for constructing queue names from namespace and name
# Type: String | Range: string containing {namespace} and {name} placeholders
naming_pattern = "{namespace}_{name}_queue"
# Namespace prefix for orchestration queue names
# Type: String | Range: non-empty string
orchestration_namespace = "orchestration"
# Namespace prefix for worker queue names
# Type: String | Range: non-empty string
worker_namespace = "worker"


# orchestration_queues
[common.queues.orchestration_queues]
# Queue name for step execution results returned by workers
# Type: String | Range: valid queue name
step_results = "orchestration_step_results"
# Queue name for task finalization messages
# Type: String | Range: valid queue name
task_finalizations = "orchestration_task_finalizations"
# Queue name for incoming task execution requests
# Type: String | Range: valid queue name
task_requests = "orchestration_task_requests"

# pgmq
[common.queues.pgmq]
# Maximum number of times a failed PGMQ operation is retried before giving up
# Type: u32 | Range: 0-100
max_retries = 3
# Interval in milliseconds between PGMQ polling cycles when no LISTEN/NOTIFY events arrive
# Type: u32 | Range: 10-10000
poll_interval_ms = 500
# Maximum time to wait for in-flight PGMQ operations to complete during graceful shutdown
# Type: u32 | Range: 1-300
shutdown_timeout_seconds = 10

[common.queues.pgmq.queue_depth_thresholds]
# Queue depth at which the API returns HTTP 503 Service Unavailable for new task submissions
# Type: i64 | Range: 1+
critical_threshold = 5000
# Queue depth indicating an emergency condition requiring manual intervention
# Type: i64 | Range: 1+
overflow_threshold = 10000
# Queue depth at which warning-level log messages are emitted
# Type: i64 | Range: 1+
warning_threshold = 1000

# rabbitmq
[common.queues.rabbitmq]
# Maximum time to wait when establishing a new RabbitMQ connection
# Type: u32 | Range: 1-300
connection_timeout_seconds = 10
# AMQP heartbeat interval for connection liveness detection
# Type: u16 | Range: 0-3600
heartbeat_seconds = 30
# Number of unacknowledged messages RabbitMQ will deliver before waiting for acks
# Type: u16 | Range: 1-65535
prefetch_count = 100
# AMQP connection URL for RabbitMQ; %2F is the URL-encoded default vhost '/'
# Type: String | Range: valid AMQP URI
url = "${RABBITMQ_URL:-amqp://guest:guest@localhost:5672/%2F}"

# ─────────────────────────────────────────────────────────────
# system
# ─────────────────────────────────────────────────────────────
[common.system]
# Default system name assigned to tasks that do not specify a dependent system
# Type: String | Range: non-empty string
default_dependent_system = "default"
# Maximum depth for recursive dependency resolution in workflow graphs
# Type: u32 | Range: 1-1000
max_recursion_depth = 50
# Tasker configuration schema version
# Type: String | Range: semver
version = "0.1.0"


# ─────────────────────────────────────────────────────────────
# task_templates
# ─────────────────────────────────────────────────────────────
[common.task_templates]
# Glob patterns for discovering task template YAML files
# Type: Vec<String> | Range: valid glob patterns
search_paths = ["config/tasks/**/*.{yml,yaml}"]


# ─────────────────────────────────────────────────────────────
# telemetry
# ─────────────────────────────────────────────────────────────
[common.telemetry]
# Enable OpenTelemetry-based telemetry collection (currently unused; see comment above)
# Type: bool | Range: true/false
enabled = true
# Fraction of traces to sample (currently unused; see comment above)
# Type: f64 | Range: 0.0-1.0
sample_rate = 0.1
# Service name reported in telemetry spans and metrics (currently unused; see comment above)
# Type: String | Range: non-empty string
service_name = "tasker-core"

# Tasker Configuration Reference — orchestration
# Environment: production
#
# This is an annotated configuration file showing all available parameters
# with their default values and documentation.
#
# Generate a deployable config: tasker-cli config generate
# Look up a parameter:         tasker-cli docs explain -p <path>


# ─────────────────────────────────────────────────────────────
# orchestration
# ─────────────────────────────────────────────────────────────
[orchestration]
# Enable detailed performance logging for orchestration actors
# Type: bool | Range: true/false
enable_performance_logging = true
# Orchestration deployment mode
# Type: String | Range: standalone
mode = "standalone"


# ─────────────────────────────────────────────────────────────
# batch_processing
# ─────────────────────────────────────────────────────────────
[orchestration.batch_processing]
# Minutes without a checkpoint update before a batch is considered stalled
# Type: u32 | Range: 1-1440
checkpoint_stall_minutes = 15
# Default number of items in a single batch when not specified by the handler
# Type: u32 | Range: 1-100000
default_batch_size = 1000
# Enable the batch processing subsystem for large-scale step execution
# Type: bool | Range: true/false
enabled = true
# Maximum number of batch operations that can execute concurrently
# Type: u32 | Range: 1-1000
max_parallel_batches = 50


# ─────────────────────────────────────────────────────────────
# decision_points
# ─────────────────────────────────────────────────────────────
[orchestration.decision_points]
# Enable verbose logging of decision point evaluation including expression results
# Type: bool | Range: true/false
enable_detailed_logging = false
# Enable metrics collection for decision point evaluations
# Type: bool | Range: true/false
enable_metrics = true
# Enable the decision point evaluation subsystem for conditional workflow branching
# Type: bool | Range: true/false
enabled = true
# Maximum depth of nested decision point chains
# Type: u32 | Range: 1-100
max_decision_depth = 20
# Maximum number of steps that can be generated by a single decision point evaluation
# Type: u32 | Range: 1-10000
max_steps_per_decision = 100
# Decision depth above which a warning is logged
# Type: u32 | Range: 1-100
warn_threshold_depth = 10
# Number of steps per decision above which a warning is logged
# Type: u32 | Range: 1-10000
warn_threshold_steps = 50


# ─────────────────────────────────────────────────────────────
# dlq
# ─────────────────────────────────────────────────────────────
[orchestration.dlq]
# Automatically move stale tasks to the DLQ when staleness detection identifies them
# Type: bool | Range: true/false
auto_dlq_on_staleness = true
# Enable the Dead Letter Queue subsystem for handling unrecoverable tasks
# Type: bool | Range: true/false
enabled = true
# Include a complete task state snapshot when moving a task to the DLQ
# Type: bool | Range: true/false
include_full_task_snapshot = true
# Maximum age in hours a task can remain in a pending-like state before being considered stale
# Type: u32 | Range: 1-720
max_pending_age_hours = 168


# reasons
[orchestration.dlq.reasons]
# Enable DLQ routing for tasks with circular step dependency graphs
# Type: bool | Range: true/false
dependency_cycle_detected = true
# Allow manual DLQ routing via the API
# Type: bool | Range: true/false
manual_dlq = true
# Enable DLQ routing for tasks whose steps have exhausted all retry attempts
# Type: bool | Range: true/false
max_retries_exceeded = true
# Enable DLQ routing for tasks that exceed staleness time thresholds
# Type: bool | Range: true/false
staleness_timeout = true
# Enable DLQ routing for tasks whose required worker becomes unavailable
# Type: bool | Range: true/false
worker_unavailable = true

# staleness_detection
[orchestration.dlq.staleness_detection]
# Number of potentially stale tasks to evaluate in a single detection sweep
# Type: u32 | Range: 1-10000
batch_size = 100
# Interval in seconds between staleness detection sweeps
# Type: u32 | Range: 30-3600
detection_interval_seconds = 300
# Run staleness detection in observation-only mode without taking action
# Type: bool | Range: true/false
dry_run = false
# Enable periodic scanning for stale tasks
# Type: bool | Range: true/false
enabled = true

[orchestration.dlq.staleness_detection.actions]
# Automatically move stale tasks to the DLQ after transitioning to error
# Type: bool | Range: true/false
auto_move_to_dlq = true
# Automatically transition stale tasks to the Error state
# Type: bool | Range: true/false
auto_transition_to_error = true
# Emit domain events when staleness is detected
# Type: bool | Range: true/false
emit_events = true
# PGMQ channel name for staleness detection events
# Type: String | Range: 1-255 characters
event_channel = "task_staleness_detected"

[orchestration.dlq.staleness_detection.thresholds]
# Minutes a task can have steps in process before being considered stale
# Type: u32 | Range: 1-1440
steps_in_process_minutes = 30
# Absolute maximum lifetime for any task regardless of state
# Type: u32 | Range: 1-168
task_max_lifetime_hours = 24
# Minutes a task can wait for step dependencies before being considered stale
# Type: u32 | Range: 1-1440
waiting_for_dependencies_minutes = 60
# Minutes a task can wait for step retries before being considered stale
# Type: u32 | Range: 1-1440
waiting_for_retry_minutes = 30

# ─────────────────────────────────────────────────────────────
# event_systems
# ─────────────────────────────────────────────────────────────


# orchestration
[orchestration.event_systems.orchestration]
# Event delivery mode: 'Hybrid' (LISTEN/NOTIFY + polling fallback), 'EventDrivenOnly', or 'PollingOnly'
# Type: DeploymentMode | Range: Hybrid | EventDrivenOnly | PollingOnly
deployment_mode = "Hybrid"
# Unique identifier for the orchestration event system instance
# Type: String | Range: non-empty string
system_id = "orchestration-event-system"

[orchestration.event_systems.orchestration.health]
# Enable health monitoring for the orchestration event system
# Type: bool | Range: true/false
enabled = true
# Error rate per minute above which the event system reports as unhealthy
# Type: u32 | Range: 1-10000
error_rate_threshold_per_minute = 20
# Number of consecutive errors before the event system reports as unhealthy
# Type: u32 | Range: 1-1000
max_consecutive_errors = 10
# Enable detailed performance metrics collection for event processing
# Type: bool | Range: true/false
performance_monitoring_enabled = true

[orchestration.event_systems.orchestration.processing]
# Number of events dequeued in a single batch read
# Type: u32 | Range: 1-1000
batch_size = 20
# Maximum number of events processed concurrently by the orchestration event system
# Type: u32 | Range: 1-10000
max_concurrent_operations = 50
# Maximum retry attempts for a failed event processing operation
# Type: u32 | Range: 0-100
max_retries = 3

[orchestration.event_systems.orchestration.processing.backoff]
# Initial backoff delay in milliseconds after first event processing failure
# Type: u64 | Range: 10-60000
initial_delay_ms = 100
# Maximum jitter as a fraction of the computed backoff delay
# Type: f64 | Range: 0.0-1.0
jitter_percent = 0.1
# Maximum backoff delay in milliseconds between event processing retries
# Type: u64 | Range: 100-300000
max_delay_ms = 10000
# Multiplier applied to the backoff delay after each consecutive failure
# Type: f64 | Range: 1.0-10.0
multiplier = 2.0

[orchestration.event_systems.orchestration.timing]
# Maximum time in seconds an event claim remains valid
# Type: u32 | Range: 1-3600
claim_timeout_seconds = 300
# Interval in seconds between fallback polling cycles when LISTEN/NOTIFY is unavailable
# Type: u32 | Range: 1-60
fallback_polling_interval_seconds = 5
# Interval in seconds between health check probes for the orchestration event system
# Type: u32 | Range: 1-3600
health_check_interval_seconds = 30
# Maximum time in seconds allowed for processing a single event
# Type: u32 | Range: 1-3600
processing_timeout_seconds = 60
# Time in seconds a dequeued message remains invisible to other consumers
# Type: u32 | Range: 1-3600
visibility_timeout_seconds = 30

# task_readiness
[orchestration.event_systems.task_readiness]
# Event delivery mode for task readiness: 'Hybrid', 'EventDrivenOnly', or 'PollingOnly'
# Type: DeploymentMode | Range: Hybrid | EventDrivenOnly | PollingOnly
deployment_mode = "Hybrid"
# Unique identifier for the task readiness event system instance
# Type: String | Range: non-empty string
system_id = "task-readiness-event-system"

[orchestration.event_systems.task_readiness.health]
# Enable health monitoring for the task readiness event system
# Type: bool | Range: true/false
enabled = true
# Error rate per minute above which the task readiness system reports as unhealthy
# Type: u32 | Range: 1-10000
error_rate_threshold_per_minute = 20
# Number of consecutive errors before the task readiness system reports as unhealthy
# Type: u32 | Range: 1-1000
max_consecutive_errors = 10
# Enable detailed performance metrics for task readiness event processing
# Type: bool | Range: true/false
performance_monitoring_enabled = true

[orchestration.event_systems.task_readiness.processing]
# Number of task readiness events dequeued in a single batch
# Type: u32 | Range: 1-1000
batch_size = 50
# Maximum number of task readiness events processed concurrently
# Type: u32 | Range: 1-10000
max_concurrent_operations = 100
# Maximum retry attempts for a failed task readiness event
# Type: u32 | Range: 0-100
max_retries = 3

[orchestration.event_systems.task_readiness.processing.backoff]
# Initial backoff delay in milliseconds after first task readiness processing failure
# Type: u64 | Range: 10-60000
initial_delay_ms = 100
# Maximum jitter as a fraction of the computed backoff delay for readiness retries
# Type: f64 | Range: 0.0-1.0
jitter_percent = 0.1
# Maximum backoff delay in milliseconds for task readiness retries
# Type: u64 | Range: 100-300000
max_delay_ms = 10000
# Multiplier applied to the backoff delay after each consecutive readiness failure
# Type: f64 | Range: 1.0-10.0
multiplier = 2.0

[orchestration.event_systems.task_readiness.timing]
# Maximum time in seconds a task readiness event claim remains valid
# Type: u32 | Range: 1-3600
claim_timeout_seconds = 300
# Interval in seconds between fallback polling cycles for task readiness
# Type: u32 | Range: 1-60
fallback_polling_interval_seconds = 5
# Interval in seconds between health check probes for the task readiness event system
# Type: u32 | Range: 1-3600
health_check_interval_seconds = 30
# Maximum time in seconds allowed for processing a single task readiness event
# Type: u32 | Range: 1-3600
processing_timeout_seconds = 60
# Time in seconds a dequeued task readiness message remains invisible to other consumers
# Type: u32 | Range: 1-3600
visibility_timeout_seconds = 30

# ─────────────────────────────────────────────────────────────
# grpc
# ─────────────────────────────────────────────────────────────
[orchestration.grpc]
# Socket address for the gRPC server
# Type: String | Range: host:port
bind_address = "${TASKER_ORCHESTRATION_GRPC_BIND_ADDRESS:-0.0.0.0:9190}"
# Enable the gRPC health checking service (grpc.health.v1)
# Type: bool | Range: true/false
enable_health_service = true
# Enable gRPC server reflection for service discovery
# Type: bool | Range: true/false
enable_reflection = true
# Enable the gRPC API server alongside the REST API
# Type: bool | Range: true/false
enabled = true
# Interval in seconds between gRPC keepalive ping frames
# Type: u32 | Range: 1-3600
keepalive_interval_seconds = 30
# Time in seconds to wait for a keepalive ping acknowledgment before closing the connection
# Type: u32 | Range: 1-300
keepalive_timeout_seconds = 20
# Maximum number of concurrent gRPC streams per connection
# Type: u32 | Range: 1-10000
max_concurrent_streams = 200
# Maximum size in bytes of a single HTTP/2 frame
# Type: u32 | Range: 16384-16777215
max_frame_size = 16384
# Enable TLS encryption for gRPC connections
# Type: bool | Range: true/false
tls_enabled = false


# ─────────────────────────────────────────────────────────────
# mpsc_channels
# ─────────────────────────────────────────────────────────────


# command_processor
[orchestration.mpsc_channels.command_processor]
# Bounded channel capacity for the orchestration command processor
# Type: usize | Range: 100-100000
command_buffer_size = 5000

# event_listeners
[orchestration.mpsc_channels.event_listeners]
# Bounded channel capacity for PGMQ event listener notifications
# Type: usize | Range: 1000-1000000
pgmq_event_buffer_size = 50000

# event_systems
[orchestration.mpsc_channels.event_systems]
# Bounded channel capacity for the orchestration event system internal channel
# Type: usize | Range: 100-100000
event_channel_buffer_size = 10000

# ─────────────────────────────────────────────────────────────
# web
# ─────────────────────────────────────────────────────────────
[orchestration.web]
# Socket address for the REST API server
# Type: String | Range: host:port
bind_address = "${TASKER_WEB_BIND_ADDRESS:-0.0.0.0:8080}"
# Enable the REST API server for the orchestration service
# Type: bool | Range: true/false
enabled = true
# Maximum time in milliseconds for an HTTP request to complete before timeout
# Type: u32 | Range: 100-300000
request_timeout_ms = 30000


# auth
[orchestration.web.auth]
# Static API key for simple key-based authentication
# Type: String | Range: non-empty string or empty to disable
api_key = ""
# HTTP header name for API key authentication
# Type: String | Range: valid HTTP header name
api_key_header = "X-API-Key"
# Enable authentication for the REST API
# Type: bool | Range: true/false
enabled = false
# Expected 'aud' claim in JWT tokens
# Type: String | Range: non-empty string
jwt_audience = "tasker-api"
# Expected 'iss' claim in JWT tokens
# Type: String | Range: non-empty string
jwt_issuer = "tasker-core"
# PEM-encoded private key for signing JWT tokens (if this service issues tokens)
# Type: String | Range: valid PEM private key or empty
jwt_private_key = ""
# PEM-encoded public key for verifying JWT token signatures
# Type: String | Range: valid PEM public key or empty
jwt_public_key = "${TASKER_JWT_PUBLIC_KEY:-}"
# File path to a PEM-encoded public key for JWT verification
# Type: String | Range: valid file path or empty
jwt_public_key_path = "${TASKER_JWT_PUBLIC_KEY_PATH:-}"
# Default JWT token validity period in hours
# Type: u32 | Range: 1-720
jwt_token_expiry_hours = 24

# database_pools
[orchestration.web.database_pools]
# Advisory hint for the total number of database connections across all orchestration pools
# Type: u32 | Range: 1-1000
max_total_connections_hint = 50
# Maximum time to wait when acquiring a connection from the web API pool
# Type: u32 | Range: 1-300
web_api_connection_timeout_seconds = 30
# Time before an idle web API connection is closed
# Type: u32 | Range: 1-3600
web_api_idle_timeout_seconds = 600
# Maximum number of connections the web API pool can grow to under load
# Type: u32 | Range: 1-500
web_api_max_connections = 30
# Target number of connections in the web API database pool
# Type: u32 | Range: 1-200
web_api_pool_size = 20

# resilience
[orchestration.web.resilience]
# Enable circuit breaker protection for the orchestration REST API
# Type: bool | Range: true/false
circuit_breaker_enabled = true
# Tasker Configuration Reference — worker
# Environment: production
#
# This is an annotated configuration file showing all available parameters
# with their default values and documentation.
#
# Generate a deployable config: tasker-cli config generate
# Look up a parameter:         tasker-cli docs explain -p <path>


# ─────────────────────────────────────────────────────────────
# worker
# ─────────────────────────────────────────────────────────────
[worker]
# Unique identifier for this worker instance
# Type: String | Range: non-empty string
worker_id = "worker-default-001"
# Worker type classification for routing and reporting
# Type: String | Range: non-empty string
worker_type = "general"


# ─────────────────────────────────────────────────────────────
# circuit_breakers
# ─────────────────────────────────────────────────────────────


# ffi_completion_send
[worker.circuit_breakers.ffi_completion_send]
# Number of consecutive FFI completion send failures before the circuit breaker trips
# Type: u32 | Range: 1-100
failure_threshold = 5
# Time the FFI completion breaker stays Open before probing with a test send
# Type: u32 | Range: 1-300
recovery_timeout_seconds = 5
# Threshold in milliseconds above which FFI completion channel sends are logged as slow
# Type: u32 | Range: 10-10000
slow_send_threshold_ms = 100
# Consecutive successful sends in Half-Open required to close the breaker
# Type: u32 | Range: 1-100
success_threshold = 2

# ─────────────────────────────────────────────────────────────
# event_systems
# ─────────────────────────────────────────────────────────────


# worker
[worker.event_systems.worker]
# Event delivery mode: 'Hybrid' (LISTEN/NOTIFY + polling fallback), 'EventDrivenOnly', or 'PollingOnly'
# Type: DeploymentMode | Range: Hybrid | EventDrivenOnly | PollingOnly
deployment_mode = "Hybrid"
# Unique identifier for the worker event system instance
# Type: String | Range: non-empty string
system_id = "worker-event-system"

[worker.event_systems.worker.health]
# Enable health monitoring for the worker event system
# Type: bool | Range: true/false
enabled = true
# Error rate per minute above which the worker event system reports as unhealthy
# Type: u32 | Range: 1-10000
error_rate_threshold_per_minute = 20
# Number of consecutive errors before the worker event system reports as unhealthy
# Type: u32 | Range: 1-1000
max_consecutive_errors = 10
# Enable detailed performance metrics for worker event processing
# Type: bool | Range: true/false
performance_monitoring_enabled = true

[worker.event_systems.worker.metadata]

[worker.event_systems.worker.metadata.fallback_poller]
# Minimum age in seconds of a message before the fallback poller will pick it up
# Type: u32 | Range: 1-3600
age_threshold_seconds = 5
# Number of messages to dequeue in a single fallback poll
# Type: u32 | Range: 1-1000
batch_size = 20
# Enable the fallback polling mechanism for step dispatch
# Type: bool | Range: true/false
enabled = true
# Maximum age in hours of messages the fallback poller will process
# Type: u32 | Range: 1-168
max_age_hours = 24
# Interval in milliseconds between fallback polling cycles
# Type: u32 | Range: 100-60000
polling_interval_ms = 1000
# List of queue namespaces the fallback poller monitors; empty means all namespaces
# Type: Vec<String> | Range: list of namespace strings
supported_namespaces = []
# Time in seconds a message polled by the fallback mechanism remains invisible
# Type: u32 | Range: 1-3600
visibility_timeout_seconds = 30

[worker.event_systems.worker.metadata.in_process_events]
# Number of event IDs to cache for deduplication of in-process events
# Type: usize | Range: 100-1000000
deduplication_cache_size = 10000
# Enable FFI integration for in-process event delivery to Ruby/Python workers
# Type: bool | Range: true/false
ffi_integration_enabled = true

[worker.event_systems.worker.metadata.listener]
# Enable batch processing of accumulated LISTEN/NOTIFY events
# Type: bool | Range: true/false
batch_processing = true
# Maximum time to wait when establishing the LISTEN/NOTIFY PostgreSQL connection
# Type: u32 | Range: 1-300
connection_timeout_seconds = 30
# Maximum time to wait for a LISTEN/NOTIFY event before yielding
# Type: u32 | Range: 1-300
event_timeout_seconds = 60
# Maximum number of listener reconnection attempts before falling back to polling
# Type: u32 | Range: 1-100
max_retry_attempts = 5
# Interval in seconds between LISTEN/NOTIFY listener reconnection attempts
# Type: u32 | Range: 1-300
retry_interval_seconds = 5

[worker.event_systems.worker.metadata.resource_limits]
# Maximum CPU utilization percentage the worker event system should target
# Type: f64 | Range: 1.0-100.0
max_cpu_percent = 80.0
# Maximum number of database connections the worker event system can use
# Type: u32 | Range: 1-1000
max_database_connections = 100
# Maximum memory in megabytes the worker event system is expected to use
# Type: u32 | Range: 256-65536
max_memory_mb = 4096
# Maximum number of queue connections the worker event system can use
# Type: u32 | Range: 1-500
max_queue_connections = 50

[worker.event_systems.worker.processing]
# Number of events dequeued in a single batch read by the worker
# Type: u32 | Range: 1-1000
batch_size = 20
# Maximum number of events processed concurrently by the worker event system
# Type: u32 | Range: 1-10000
max_concurrent_operations = 100
# Maximum retry attempts for a failed worker event processing operation
# Type: u32 | Range: 0-100
max_retries = 3

[worker.event_systems.worker.processing.backoff]
# Initial backoff delay in milliseconds after first worker event processing failure
# Type: u64 | Range: 10-60000
initial_delay_ms = 100
# Maximum jitter as a fraction of the computed backoff delay
# Type: f64 | Range: 0.0-1.0
jitter_percent = 0.1
# Maximum backoff delay in milliseconds between worker event retries
# Type: u64 | Range: 100-300000
max_delay_ms = 10000
# Multiplier applied to the backoff delay after each consecutive failure
# Type: f64 | Range: 1.0-10.0
multiplier = 2.0

[worker.event_systems.worker.timing]
# Maximum time in seconds a worker event claim remains valid
# Type: u32 | Range: 1-3600
claim_timeout_seconds = 300
# Interval in seconds between fallback polling cycles for step dispatch
# Type: u32 | Range: 1-60
fallback_polling_interval_seconds = 2
# Interval in seconds between health check probes for the worker event system
# Type: u32 | Range: 1-3600
health_check_interval_seconds = 30
# Maximum time in seconds allowed for processing a single worker event
# Type: u32 | Range: 1-3600
processing_timeout_seconds = 60
# Time in seconds a dequeued step dispatch message remains invisible to other workers
# Type: u32 | Range: 1-3600
visibility_timeout_seconds = 30

# ─────────────────────────────────────────────────────────────
# grpc
# ─────────────────────────────────────────────────────────────
[worker.grpc]
# Socket address for the worker gRPC server
# Type: String | Range: host:port
bind_address = "${TASKER_WORKER_GRPC_BIND_ADDRESS:-0.0.0.0:9191}"
# Enable the gRPC health checking service on the worker
# Type: bool | Range: true/false
enable_health_service = true
# Enable gRPC server reflection for the worker service
# Type: bool | Range: true/false
enable_reflection = true
# Enable the gRPC API server for the worker service
# Type: bool | Range: true/false
enabled = true
# Interval in seconds between gRPC keepalive ping frames on the worker
# Type: u32 | Range: 1-3600
keepalive_interval_seconds = 30
# Time in seconds to wait for a keepalive ping acknowledgment before closing the connection
# Type: u32 | Range: 1-300
keepalive_timeout_seconds = 20
# Maximum number of concurrent gRPC streams per connection
# Type: u32 | Range: 1-10000
max_concurrent_streams = 1000
# Maximum size in bytes of a single HTTP/2 frame for the worker gRPC server
# Type: u32 | Range: 16384-16777215
max_frame_size = 16384
# Enable TLS encryption for worker gRPC connections
# Type: bool | Range: true/false
tls_enabled = false


# ─────────────────────────────────────────────────────────────
# health_monitoring
# ─────────────────────────────────────────────────────────────
[worker.health_monitoring]
# Error rate threshold (0.0-1.0) above which the worker reports as unhealthy
# Type: f64 | Range: 0.0-1.0
error_rate_threshold = 0.05
# Interval in seconds between worker health self-checks
# Type: u32 | Range: 1-3600
health_check_interval_seconds = 30
# Enable detailed performance metrics collection for worker health monitoring
# Type: bool | Range: true/false
performance_monitoring_enabled = true


# ─────────────────────────────────────────────────────────────
# mpsc_channels
# ─────────────────────────────────────────────────────────────


# command_processor
[worker.mpsc_channels.command_processor]
# Bounded channel capacity for the worker command processor
# Type: usize | Range: 100-100000
command_buffer_size = 2000

# domain_events
[worker.mpsc_channels.domain_events]
# Bounded channel capacity for domain event system commands
# Type: usize | Range: 100-50000
command_buffer_size = 1000
# Log a warning when domain events are dropped due to channel saturation
# Type: bool | Range: true/false
log_dropped_events = true
# Maximum time in milliseconds to drain pending domain events during shutdown
# Type: u32 | Range: 100-60000
shutdown_drain_timeout_ms = 5000

# event_listeners
[worker.mpsc_channels.event_listeners]
# Bounded channel capacity for PGMQ event listener notifications on the worker
# Type: usize | Range: 1000-1000000
pgmq_event_buffer_size = 10000

# event_subscribers
[worker.mpsc_channels.event_subscribers]
# Bounded channel capacity for step completion event subscribers
# Type: usize | Range: 100-50000
completion_buffer_size = 1000
# Bounded channel capacity for step result event subscribers
# Type: usize | Range: 100-50000
result_buffer_size = 1000

# event_systems
[worker.mpsc_channels.event_systems]
# Bounded channel capacity for the worker event system internal channel
# Type: usize | Range: 100-100000
event_channel_buffer_size = 2000

# ffi_dispatch
[worker.mpsc_channels.ffi_dispatch]
# Maximum time in milliseconds for FFI fire-and-forget domain event callbacks
# Type: u32 | Range: 100-60000
callback_timeout_ms = 5000
# Maximum time in milliseconds to retry sending FFI completion results when the channel is full
# Type: u32 | Range: 1000-300000
completion_send_timeout_ms = 10000
# Maximum time in milliseconds to wait for an FFI step handler to complete
# Type: u32 | Range: 1000-600000
completion_timeout_ms = 30000
# Bounded channel capacity for FFI step dispatch requests
# Type: usize | Range: 100-50000
dispatch_buffer_size = 1000
# Age in milliseconds of pending FFI events that triggers a starvation warning
# Type: u32 | Range: 1000-300000
starvation_warning_threshold_ms = 10000

# handler_dispatch
[worker.mpsc_channels.handler_dispatch]
# Bounded channel capacity for step handler completion notifications
# Type: usize | Range: 100-50000
completion_buffer_size = 1000
# Bounded channel capacity for step handler dispatch requests
# Type: usize | Range: 100-50000
dispatch_buffer_size = 1000
# Maximum time in milliseconds for a step handler to complete execution
# Type: u32 | Range: 1000-600000
handler_timeout_ms = 30000
# Maximum number of step handlers executing simultaneously
# Type: u32 | Range: 1-10000
max_concurrent_handlers = 10

[worker.mpsc_channels.handler_dispatch.load_shedding]
# Handler capacity percentage above which new step claims are refused
# Type: f64 | Range: 0.0-100.0
capacity_threshold_percent = 80.0
# Enable load shedding to refuse step claims when handler capacity is nearly exhausted
# Type: bool | Range: true/false
enabled = true
# Handler capacity percentage at which warning logs are emitted
# Type: f64 | Range: 0.0-100.0
warning_threshold_percent = 70.0

# in_process_events
[worker.mpsc_channels.in_process_events]
# Bounded broadcast channel capacity for in-process domain event delivery
# Type: usize | Range: 100-100000
broadcast_buffer_size = 2000
# Maximum time in milliseconds to wait when dispatching an in-process event
# Type: u32 | Range: 100-60000
dispatch_timeout_ms = 5000
# Log errors when in-process event subscribers fail to receive events
# Type: bool | Range: true/false
log_subscriber_errors = true

# ─────────────────────────────────────────────────────────────
# orchestration_client
# ─────────────────────────────────────────────────────────────
[worker.orchestration_client]
# Base URL of the orchestration REST API that this worker reports to
# Type: String | Range: valid HTTP(S) URL
base_url = "http://localhost:8080"
# Maximum retry attempts for failed orchestration API calls
# Type: u32 | Range: 0-10
max_retries = 3
# HTTP request timeout in milliseconds for orchestration API calls
# Type: u32 | Range: 100-300000
timeout_ms = 30000


# ─────────────────────────────────────────────────────────────
# step_processing
# ─────────────────────────────────────────────────────────────
[worker.step_processing]
# Maximum time in seconds a step claim remains valid before expiring
# Type: u32 | Range: 1-3600
claim_timeout_seconds = 300
# Maximum number of steps this worker processes simultaneously
# Type: u32 | Range: 1-100000
max_concurrent_steps = 50
# Maximum number of retry attempts for a failed step at the worker level
# Type: u32 | Range: 0-100
max_retries = 3


# ─────────────────────────────────────────────────────────────
# web
# ─────────────────────────────────────────────────────────────
[worker.web]
# Socket address for the worker REST API server
# Type: String | Range: host:port
bind_address = "${TASKER_WEB_BIND_ADDRESS:-0.0.0.0:8081}"
# Enable the REST API server for the worker service
# Type: bool | Range: true/false
enabled = true
# Maximum time in milliseconds for a worker HTTP request to complete before timeout
# Type: u32 | Range: 100-300000
request_timeout_ms = 30000


# auth
[worker.web.auth]
# Static API key for simple key-based authentication on the worker API
# Type: String | Range: non-empty string or empty to disable
api_key = ""
# HTTP header name for API key authentication on the worker API
# Type: String | Range: valid HTTP header name
api_key_header = "X-API-Key"
# Enable authentication for the worker REST API
# Type: bool | Range: true/false
enabled = false
# Expected 'aud' claim in JWT tokens for the worker API
# Type: String | Range: non-empty string
jwt_audience = "worker-api"
# Expected 'iss' claim in JWT tokens for the worker API
# Type: String | Range: non-empty string
jwt_issuer = "tasker-worker"
# PEM-encoded private key for signing JWT tokens (if the worker issues tokens)
# Type: String | Range: valid PEM private key or empty
jwt_private_key = ""
# PEM-encoded public key for verifying JWT token signatures on the worker API
# Type: String | Range: valid PEM public key or empty
jwt_public_key = "${TASKER_JWT_PUBLIC_KEY:-}"
# File path to a PEM-encoded public key for worker JWT verification
# Type: String | Range: valid file path or empty
jwt_public_key_path = "${TASKER_JWT_PUBLIC_KEY_PATH:-}"
# Default JWT token validity period in hours for worker API tokens
# Type: u32 | Range: 1-720
jwt_token_expiry_hours = 24

# database_pools
[worker.web.database_pools]
# Advisory hint for the total number of database connections across all worker pools
# Type: u32 | Range: 1-1000
max_total_connections_hint = 25
# Maximum time to wait when acquiring a connection from the worker web API pool
# Type: u32 | Range: 1-300
web_api_connection_timeout_seconds = 30
# Time before an idle worker web API connection is closed
# Type: u32 | Range: 1-3600
web_api_idle_timeout_seconds = 600
# Maximum number of connections the worker web API pool can grow to under load
# Type: u32 | Range: 1-500
web_api_max_connections = 15
# Target number of connections in the worker web API database pool
# Type: u32 | Range: 1-200
web_api_pool_size = 10

# resilience
[worker.web.resilience]
# Enable circuit breaker protection for the worker REST API
# Type: bool | Range: true/false
circuit_breaker_enabled = true