#!/usr/bin/env ruby
# frozen_string_literal: true

# Batch Worker CLI - Runs the BatchWorkerManager for processing pgmq batches
#
# Usage:
#   batch_worker                                    # Run with default config
#   batch_worker --namespaces fulfillment,inventory # Run for specific namespaces
#   batch_worker --workers 3                       # Run 3 workers per namespace
#   batch_worker --config config.yml               # Load config from file

require 'optparse'
require 'yaml'
require 'logger'

# Add lib to load path
lib_path = File.expand_path('../lib', __dir__)
$LOAD_PATH.unshift(lib_path) unless $LOAD_PATH.include?(lib_path)

require 'tasker_core'
require 'tasker_core/messaging/batch_worker_manager'
require 'tasker_core/step_handler/example_handlers'

class BatchWorkerCLI
  def initialize
    @options = {
      namespaces: %w[fulfillment inventory notifications payments analytics],
      workers_per_namespace: 2,
      config_file: nil,
      log_level: :info,
      daemonize: false,
      pid_file: nil
    }
  end

  def run(args = ARGV)
    parse_options(args)
    setup_logging
    load_config_file if @options[:config_file]
    
    puts "üöÄ Starting Tasker Core Batch Workers"
    puts "Namespaces: #{@options[:namespaces].join(', ')}"
    puts "Workers per namespace: #{@options[:workers_per_namespace]}"
    puts "Log level: #{@options[:log_level]}"
    
    daemonize if @options[:daemonize]
    write_pid_file if @options[:pid_file]
    
    # Create and start the worker manager
    manager_config = {
      namespaces: @options[:namespaces],
      workers_per_namespace: @options[:workers_per_namespace],
      worker_config: {
        polling_interval_seconds: @options[:polling_interval] || 1,
        batch_size: @options[:batch_size] || 5,
        visibility_timeout_seconds: @options[:visibility_timeout] || 300,
        max_concurrent_steps: @options[:max_concurrent_steps] || 4,
        step_timeout_seconds: @options[:step_timeout] || 60,
        error_retry_delay_seconds: @options[:error_retry_delay] || 5,
        results_queue_name: @options[:results_queue] || 'orchestration_batch_results',
        log_level: @options[:log_level]
      },
      log_level: @options[:log_level],
      monitoring_enabled: @options[:monitoring] != false,
      monitoring_interval_seconds: @options[:monitoring_interval] || 30
    }
    
    @manager = TaskerCore::Messaging::BatchWorkerManager.new(manager_config)
    
    # Setup graceful shutdown
    setup_signal_handlers
    
    # Start the manager (this will block)
    @manager.start
    
  rescue Interrupt
    puts "\nüëã Received interrupt signal, shutting down gracefully..."
    shutdown
  rescue => e
    puts "‚ùå Error: #{e.message}"
    puts e.backtrace.join("\n") if @options[:log_level] == :debug
    exit(1)
  ensure
    cleanup
  end

  private

  def parse_options(args)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{$0} [options]"
      opts.separator ""
      opts.separator "Batch Worker Options:"

      opts.on("-n", "--namespaces NAMESPACES", Array, 
              "Comma-separated list of namespaces to process") do |namespaces|
        @options[:namespaces] = namespaces
      end

      opts.on("-w", "--workers COUNT", Integer,
              "Number of workers per namespace (default: 2)") do |workers|
        @options[:workers_per_namespace] = workers
      end

      opts.on("-c", "--config FILE", String,
              "Load configuration from YAML file") do |config_file|
        @options[:config_file] = config_file
      end

      opts.separator ""
      opts.separator "Queue Options:"

      opts.on("--polling-interval SECONDS", Integer,
              "Polling interval in seconds (default: 1)") do |interval|
        @options[:polling_interval] = interval
      end

      opts.on("--batch-size SIZE", Integer,
              "Number of messages to read per batch (default: 5)") do |size|
        @options[:batch_size] = size
      end

      opts.on("--visibility-timeout SECONDS", Integer,
              "Message visibility timeout in seconds (default: 300)") do |timeout|
        @options[:visibility_timeout] = timeout
      end

      opts.on("--max-concurrent-steps COUNT", Integer,
              "Maximum concurrent steps per batch (default: 4)") do |count|
        @options[:max_concurrent_steps] = count
      end

      opts.on("--results-queue QUEUE", String,
              "Results queue name (default: orchestration_batch_results)") do |queue|
        @options[:results_queue] = queue
      end

      opts.separator ""
      opts.separator "Process Options:"

      opts.on("-d", "--daemonize", "Run as daemon") do
        @options[:daemonize] = true
      end

      opts.on("-p", "--pid-file FILE", String, "Write PID to file") do |file|
        @options[:pid_file] = file
      end

      opts.on("-l", "--log-level LEVEL", String,
              "Log level: debug, info, warn, error (default: info)") do |level|
        @options[:log_level] = level.to_sym
      end

      opts.on("--no-monitoring", "Disable worker monitoring") do
        @options[:monitoring] = false
      end

      opts.separator ""
      opts.separator "Help:"

      opts.on("-h", "--help", "Show this help") do
        puts opts
        exit
      end

      opts.on("--version", "Show version") do
        puts "Tasker Core Batch Worker v#{TaskerCore::VERSION || '0.1.0'}"
        exit
      end
    end

    parser.parse!(args)
  end

  def load_config_file
    unless File.exist?(@options[:config_file])
      puts "‚ùå Config file not found: #{@options[:config_file]}"
      exit(1)
    end

    config = YAML.load_file(@options[:config_file])
    @options.merge!(symbolize_keys(config))
  rescue => e
    puts "‚ùå Error loading config file: #{e.message}"
    exit(1)
  end

  def symbolize_keys(hash)
    hash.each_with_object({}) do |(key, value), result|
      new_key = key.to_sym
      new_value = value.is_a?(Hash) ? symbolize_keys(value) : value
      result[new_key] = new_value
    end
  end

  def setup_logging
    # Configure Ruby logger
    logger = Logger.new($stdout)
    logger.level = case @options[:log_level]
                   when :debug then Logger::DEBUG
                   when :info then Logger::INFO
                   when :warn then Logger::WARN
                   when :error then Logger::ERROR
                   else Logger::INFO
                   end
    
    # Set logger format
    logger.formatter = proc do |severity, datetime, progname, msg|
      "[#{datetime.strftime('%Y-%m-%d %H:%M:%S')}] #{severity.ljust(5)} #{progname}: #{msg}\n"
    end
    
    # Make logger available globally (if needed)
    @logger = logger
  end

  def daemonize
    return if @options[:daemonize] != true
    
    puts "üîÑ Daemonizing process..."
    
    # Fork and exit parent
    exit if fork
    
    # Become session leader
    Process.setsid
    
    # Fork again and exit parent
    exit if fork
    
    # Change directory
    Dir.chdir('/')
    
    # Redirect streams
    $stdin.reopen('/dev/null')
    $stdout.reopen('/dev/null', 'w')
    $stderr.reopen('/dev/null', 'w')
  end

  def write_pid_file
    return unless @options[:pid_file]
    
    File.write(@options[:pid_file], Process.pid)
    puts "üìù PID written to #{@options[:pid_file]}"
  end

  def setup_signal_handlers
    %w[INT TERM].each do |signal|
      Signal.trap(signal) do
        puts "\nüõë Received #{signal} signal, initiating graceful shutdown..."
        shutdown
        exit(0)
      end
    end
    
    # Handle USR1 for stats
    Signal.trap('USR1') do
      print_statistics
    end
    
    # Handle USR2 for health check
    Signal.trap('USR2') do
      print_health_check
    end
  end

  def shutdown
    return unless @manager
    
    puts "‚èπÔ∏è  Stopping worker manager..."
    @manager.stop
    puts "‚úÖ Worker manager stopped"
  end

  def cleanup
    if @options[:pid_file] && File.exist?(@options[:pid_file])
      File.delete(@options[:pid_file])
    end
  end

  def print_statistics
    return unless @manager
    
    stats = @manager.statistics
    puts "\nüìä Worker Statistics:"
    puts "Manager: #{stats[:manager][:running] ? 'Running' : 'Stopped'}"
    puts "Uptime: #{stats[:manager][:uptime_seconds]}s"
    puts "Total processed batches: #{stats[:totals][:processed_batches]}"
    puts "Total processed steps: #{stats[:totals][:processed_steps]}"
    puts "Total failed batches: #{stats[:totals][:failed_batches]}"
    puts "Total failed steps: #{stats[:totals][:failed_steps]}"
    puts "Active workers: #{stats[:totals][:active_workers]}"
    
    stats[:namespaces].each do |namespace, namespace_stats|
      puts "\n#{namespace.capitalize}:"
      puts "  Workers: #{namespace_stats[:workers].size}"
      puts "  Batches: #{namespace_stats[:totals][:processed_batches]}"
      puts "  Steps: #{namespace_stats[:totals][:processed_steps]}"
      puts "  Failures: #{namespace_stats[:totals][:failed_batches]} batches, #{namespace_stats[:totals][:failed_steps]} steps"
    end
    puts
  end

  def print_health_check
    return unless @manager
    
    health = @manager.health_check
    puts "\nüè• Health Check:"
    puts "Status: #{health[:status].upcase}"
    puts "Message: #{health[:message]}"
    puts "Healthy workers: #{health[:healthy_workers]}/#{health[:total_workers]}" if health[:total_workers]
    
    if health[:unhealthy_workers]&.any?
      puts "Unhealthy workers: #{health[:unhealthy_workers].join(', ')}"
    end
    puts
  end
end

# Run the CLI if this file is executed directly
if __FILE__ == $0
  cli = BatchWorkerCLI.new
  cli.run(ARGV)
end